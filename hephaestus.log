2025-07-03 19:55:21,473 - hydra.core.utils - DEBUG - Setting JobRuntime:name=UNKNOWN_NAME
2025-07-03 19:55:21,473 - hydra.core.utils - DEBUG - Setting JobRuntime:name=app
2025-07-03 19:55:21,548 - agent.config_loader - INFO - Hydra configuration loaded successfully.
2025-07-03 19:55:21,548 - HephaestusAgent - INFO - Carregando memória de HEPHAESTUS_MEMORY.json...
2025-07-03 19:55:21,549 - HephaestusAgent - INFO - Memória carregada. 2 objetivos concluídos, 4 falharam.
2025-07-03 19:55:21,549 - HephaestusAgent - INFO - ArchitectAgent inicializado com a configuração: {'_target_': 'builtins.dict', 'temperature': 0.3, 'max_tokens': -1, 'primary': 'gemini/gemini-2.5-pro', 'fallback': 'deepseek/deepseek-r1-0528:free'}
2025-07-03 19:55:21,549 - HephaestusAgent - INFO - MaestroAgent inicializado com a configuração: {'_target_': 'builtins.dict', 'temperature': 0.3, 'max_tokens': -1, 'primary': 'gemini/gemini-2.5-pro', 'fallback': 'deepseek/deepseek-r1-0528:free'}
2025-07-03 19:55:21,549 - HephaestusAgent - INFO - Repositório Git já existe.
2025-07-03 19:55:21,553 - HephaestusAgent - INFO - Gerando objetivo inicial...
2025-07-03 19:55:21,553 - HephaestusAgent - INFO - Generating next objective...
2025-07-03 19:55:21,553 - HephaestusAgent - INFO - CAPABILITIES.md lido com sucesso.
2025-07-03 19:55:21,553 - HephaestusAgent - INFO - ROADMAP.md lido com sucesso.
2025-07-03 19:55:21,553 - HephaestusAgent - INFO - Analyzing code metrics in: .
2025-07-03 19:55:21,789 - HephaestusAgent - DEBUG - Code analysis summary:
Large Files (potential candidates for modularization):
  - agent/brain.py (LOC: 357)
  - agent/code_metrics.py (LOC: 362)
  - agent/hephaestus_agent.py (LOC: 369)
  - agent/patch_applicator.py (LOC: 697)
  - agent/cycle_runner.py (LOC: 485)
  - agent/project_scanner.py (LOC: 462)

Large Functions (potential candidates for refactoring/splitting):
  - agent/brain.py -> generate_next_objective() (LOC: 162)
  - agent/brain.py -> generate_capacitation_objective() (LOC: 59)
  - agent/brain.py -> generate_commit_message() (LOC: 98)
  - agent/code_metrics.py -> analyze_complexity() (LOC: 84)
  - agent/code_metrics.py -> calculate_quality_score() (LOC: 89)
  - agent/code_metrics.py -> detect_code_duplication() (LOC: 126)
  - agent/git_utils.py -> initialize_git_repository() (LOC: 208)
  - agent/patch_applicator.py -> _handle_replace() (LOC: 71)
  - agent/patch_applicator.py -> _handle_delete_block() (LOC: 78)
  - agent/patch_applicator.py -> apply_patches() (LOC: 285)
  - agent/cycle_runner.py -> run_cycles() (LOC: 460)
  - agent/prompt_builder.py -> build_meta_analysis_objective_prompt() (LOC: 62)
  - agent/prompt_builder.py -> build_standard_objective_prompt() (LOC: 100)
  - agent/project_scanner.py -> update_project_manifest() (LOC: 188)
  - agent/project_scanner.py -> analyze_code_metrics() (LOC: 208)
  - agent/config_loader.py -> load_config() (LOC: 53)
  - agent/utils/json_parser.py -> parse_json_response() (LOC: 75)

Complex Functions (high CC, potential candidates for refactoring/simplification):
  - agent/brain.py -> generate_next_objective() (CC: 43)
  - agent/brain.py -> generate_commit_message() (CC: 15)
  - agent/code_metrics.py -> analyze_complexity() (CC: 15)
  - agent/code_metrics.py -> calculate_quality_score() (CC: 23)
  - agent/code_metrics.py -> detect_code_duplication() (CC: 20)
  - agent/git_utils.py -> initialize_git_repository() (CC: 14)
  - agent/patch_applicator.py -> _handle_replace() (CC: 15)
  - agent/patch_applicator.py -> _handle_delete_block() (CC: 21)
  - agent/patch_applicator.py -> apply_patches() (CC: 65)
  - agent/cycle_runner.py -> run_cycles() (CC: 89)
  - agent/project_scanner.py -> update_project_manifest() (CC: 45)
  - agent/project_scanner.py -> analyze_code_metrics() (CC: 47)
  - agent/utils/json_parser.py -> parse_json_response() (CC: 25)

Modules without Corresponding Test Files (consider creating tests):
  - cli.py
  - app.py
  - run_agent.py
  - agent/brain.py
  - agent/code_metrics.py
  - agent/hephaestus_agent.py
  - agent/git_utils.py
  - agent/code_validator.py
  - agent/patch_applicator.py
  - agent/cycle_runner.py
  - agent/memory.py
  - agent/prompt_builder.py
  - agent/tool_executor.py
  - agent/project_scanner.py
  - agent/state.py
  - agent/config_loader.py
  - agent/validation_steps/pytest_validator.py
  - agent/validation_steps/__init__.py
  - agent/validation_steps/base.py
  - agent/validation_steps/patch_applicator.py
  - agent/validation_steps/syntax_validator.py
  - agent/validation_steps/pytest_new_file_validator.py
  - agent/agents/architect_agent.py
  - agent/agents/performance_analyzer.py
  - agent/agents/error_correction.py
  - agent/agents/maestro_agent.py
  - agent/agents/error_analyzer.py
  - agent/utils/json_parser.py
  - agent/utils/llm_client.py
2025-07-03 19:55:21,789 - HephaestusAgent - INFO - Analyzing performance log...
2025-07-03 19:55:21,795 - HephaestusAgent - DEBUG - Performance analysis summary:
Performance Summary:
- Total Cycles: 5
- Successful Cycles: 2
- Failed Cycles: 3
- Success Rate: 40.00%
- Average Cycle Duration: N/A

Performance by Strategy (sorted by failures):
- Strategy 'SYNTAX_AND_PYTEST': Success Rate: 0.00% (Failures: 3/3)
- Strategy 'CREATE_NEW_TEST_FILE_STRATEGY': Success Rate: 100.00% (Failures: 0/2)

2025-07-03 19:55:21,796 - HephaestusAgent - DEBUG - Prompt for generate_next_objective:

[Main Context]
You are the 'Planejador Estratégico Avançado' do agente autônomo Hephaestus. Sua principal responsabilidade é identificar e propor o próximo objetivo de desenvolvimento mais impactante para a evolução do agente ou do projeto em análise.

[Decision Process for the Next Objective]
1.  **Analyze Performance:** Review the `[PERFORMANCE ANALYSIS]` section.
2.  **Analyze Code Metrics:** Review the `[CODE METRICS AND ANALYSIS]` section.
3.  **Consider Strategic Documents:** Review `[CAPABILITIES DOCUMENT]` and `[ROADMAP DOCUMENT]` to understand current capabilities, desired future states, and strategic direction. Identify gaps or next steps.
4.  **Consider the Project Manifest:** If the `[CURRENT PROJECT MANIFEST]` is provided, use it for context.
5.  **Review Recent History:** The `[HISTÓRICO RECENTE DO PROJETO E DO AGENTE]` section provides context.
6.  **Prioritize RSI:** Focus on objectives that enhance the agent's ability to self-improve, improve its core logic, prompts, or strategies.
7.  **Prioritize Capabilities & Roadmap:** Generate objectives that fill gaps in `[CAPABILITIES DOCUMENT]` or advance items in `[ROADMAP DOCUMENT]`.
8.  **Prioritize Structural and Quality Improvements:** Based on metrics and strategic documents.
9.  **Be Specific and Actionable:** The objective should be clear, concise, and indicate a concrete action.

1.  **Analyze Performance:** Review the `[PERFORMANCE ANALYSIS]` section to understand the agent's overall success rate and identify trends, especially focusing on strategies with high failure rates.
2.  **Analyze Code Metrics:** Review the `[CODE METRICS AND ANALYSIS]` section below. It contains data on file size (LOC), function size (LOC), cyclomatic complexity (CC) of functions, and modules that may be missing tests.
3.  **Consider the Project Manifest:** If the `[CURRENT PROJECT MANIFEST]` is provided, use it to understand the overall goals, architecture, and areas already documented or needing attention.
4.  **Review Recent History:** The `[HISTÓRICO RECENTE DO PROJETO E DO AGENTE]` section provides context on recent tasks, successes, and failures. Avoid repeating objectives that recently failed in the same way, unless the cause of failure has been resolved. Use history to build on successes.
5.  **Prioritize Structural and Quality Improvements:** Based on metrics, identify opportunities to:
    *   Refactor very large modules or very long/complex functions.
    *   Create tests for critical/complex modules or functions that lack them.
    *   Improve documentation (docstrings, manifest) where crucial.
    *   Propose the creation of new capabilities (new agents, tools) if the analysis indicates a strategic need.
6.  **Prioritize Prompt and Strategy Optimization (RSI Focus):** If the performance analysis reveals strategies with consistently low success rates, consider objectives to:
    *   Refine the prompts used by agents (e.g., Architect, Maestro, ErrorAnalysis) for those failing strategies.
    *   Propose new or modified validation strategies in `hephaestus_config.json` to address specific failure patterns.
7.  **Be Specific and Actionable:** The objective should be clear, concise, and indicate a concrete action.


[HISTÓRICO RECENTE DO PROJETO E DO AGENTE]
Completed Objectives (most recent first):
- Objective: Com base no sucesso da criação do arquivo `tests/agent/test_cycle_runner.py`, o próximo passo incremental é adicionar um teste simples que apenas importa a função `run_cycles` de `agent.cycle_runner`. Este teste (`def test_run_cycles_importable(): from agent.cycle_runner import run_cycles`) validará que a função, com sua altíssima complexidade (CC: 89), pode ser importada sem causar erros de importação ou efeitos colaterais, estabelecendo uma base mais sólida para futuros testes de lógica e refatoração.
  Strategy: CREATE_NEW_TEST_FILE_STRATEGY
  Outcome: Strategy 'CREATE_NEW_TEST_FILE_STRATEGY' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T22:29:08.784181+00:00
- Objective: Dadas as falhas consecutivas ao tentar testar e refatorar a função `run_cycles` (CC: 89), o próximo passo deve ser mais incremental para garantir sucesso. Crie o arquivo de teste `tests/agent/test_cycle_runner.py` contendo apenas um "smoke test" (ex: `def test_placeholder(): assert True`) para validar que o ambiente de teste para este módulo crítico está funcionando e que o pytest executa com sucesso (exit code 0), estabelecendo assim uma base estável para futuros testes de lógica.
  Strategy: CREATE_NEW_TEST_FILE_STRATEGY
  Outcome: Strategy 'CREATE_NEW_TEST_FILE_STRATEGY' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T22:27:49.062600+00:00

Failed Objectives (most recent first):
- Objective: Dado o sucesso em criar o arquivo de teste para `cycle_runner`, o próximo passo é adicionar um teste de caracterização para a função `run_cycles` (CC: 89). Este teste deve usar `unittest.mock` para simular as dependências essenciais (como `AgentState` e `QueueManager`) e invocar a função, validando que ela pode ser executada em um cenário controlado sem erros, estabelecendo assim a base para testes de lógica mais detalhados e refatoração segura.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_qyaqjai0)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:41:06.299306+00:00
- Objective: Para iniciar a refatoração da função `run_cycles` (CC: 89), que é a mais complexa do projeto, extraia a lógica de inicialização do ciclo (criação do `AgentState` e logs iniciais) para uma nova função auxiliar privada dentro de `agent/cycle_runner.py`. Em seguida, adicione um teste unitário no arquivo `tests/agent/test_cycle_runner.py` que valide especificamente o comportamento desta nova função extraída, garantindo um progresso incremental e seguro.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_v22kn3j2)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:31:44.352659+00:00
Consider this history to avoid repeating failures, build on successes, and identify gaps.


[PERFORMANCE ANALYSIS]
Performance Summary:
- Total Cycles: 5
- Successful Cycles: 2
- Failed Cycles: 3
- Success Rate: 40.00%
- Average Cycle Duration: N/A

Performance by Strategy (sorted by failures):
- Strategy 'SYNTAX_AND_PYTEST': Success Rate: 0.00% (Failures: 3/3)
- Strategy 'CREATE_NEW_TEST_FILE_STRATEGY': Success Rate: 100.00% (Failures: 0/2)


[CODE METRICS AND ANALYSIS]
Large Files (potential candidates for modularization):
  - agent/brain.py (LOC: 357)
  - agent/code_metrics.py (LOC: 362)
  - agent/hephaestus_agent.py (LOC: 369)
  - agent/patch_applicator.py (LOC: 697)
  - agent/cycle_runner.py (LOC: 485)
  - agent/project_scanner.py (LOC: 462)

Large Functions (potential candidates for refactoring/splitting):
  - agent/brain.py -> generate_next_objective() (LOC: 162)
  - agent/brain.py -> generate_capacitation_objective() (LOC: 59)
  - agent/brain.py -> generate_commit_message() (LOC: 98)
  - agent/code_metrics.py -> analyze_complexity() (LOC: 84)
  - agent/code_metrics.py -> calculate_quality_score() (LOC: 89)
  - agent/code_metrics.py -> detect_code_duplication() (LOC: 126)
  - agent/git_utils.py -> initialize_git_repository() (LOC: 208)
  - agent/patch_applicator.py -> _handle_replace() (LOC: 71)
  - agent/patch_applicator.py -> _handle_delete_block() (LOC: 78)
  - agent/patch_applicator.py -> apply_patches() (LOC: 285)
  - agent/cycle_runner.py -> run_cycles() (LOC: 460)
  - agent/prompt_builder.py -> build_meta_analysis_objective_prompt() (LOC: 62)
  - agent/prompt_builder.py -> build_standard_objective_prompt() (LOC: 100)
  - agent/project_scanner.py -> update_project_manifest() (LOC: 188)
  - agent/project_scanner.py -> analyze_code_metrics() (LOC: 208)
  - agent/config_loader.py -> load_config() (LOC: 53)
  - agent/utils/json_parser.py -> parse_json_response() (LOC: 75)

Complex Functions (high CC, potential candidates for refactoring/simplification):
  - agent/brain.py -> generate_next_objective() (CC: 43)
  - agent/brain.py -> generate_commit_message() (CC: 15)
  - agent/code_metrics.py -> analyze_complexity() (CC: 15)
  - agent/code_metrics.py -> calculate_quality_score() (CC: 23)
  - agent/code_metrics.py -> detect_code_duplication() (CC: 20)
  - agent/git_utils.py -> initialize_git_repository() (CC: 14)
  - agent/patch_applicator.py -> _handle_replace() (CC: 15)
  - agent/patch_applicator.py -> _handle_delete_block() (CC: 21)
  - agent/patch_applicator.py -> apply_patches() (CC: 65)
  - agent/cycle_runner.py -> run_cycles() (CC: 89)
  - agent/project_scanner.py -> update_project_manifest() (CC: 45)
  - agent/project_scanner.py -> analyze_code_metrics() (CC: 47)
  - agent/utils/json_parser.py -> parse_json_response() (CC: 25)

Modules without Corresponding Test Files (consider creating tests):
  - cli.py
  - app.py
  - run_agent.py
  - agent/brain.py
  - agent/code_metrics.py
  - agent/hephaestus_agent.py
  - agent/git_utils.py
  - agent/code_validator.py
  - agent/patch_applicator.py
  - agent/cycle_runner.py
  - agent/memory.py
  - agent/prompt_builder.py
  - agent/tool_executor.py
  - agent/project_scanner.py
  - agent/state.py
  - agent/config_loader.py
  - agent/validation_steps/pytest_validator.py
  - agent/validation_steps/__init__.py
  - agent/validation_steps/base.py
  - agent/validation_steps/patch_applicator.py
  - agent/validation_steps/syntax_validator.py
  - agent/validation_steps/pytest_new_file_validator.py
  - agent/agents/architect_agent.py
  - agent/agents/performance_analyzer.py
  - agent/agents/error_correction.py
  - agent/agents/maestro_agent.py
  - agent/agents/error_analyzer.py
  - agent/utils/json_parser.py
  - agent/utils/llm_client.py

[CAPABILITIES DOCUMENT (CAPABILITIES.md)]
# Manifesto de Capacidades do Hephaestus

Este documento descreve as capacidades atuais e desejadas do agente Hephaestus, servindo como um guia para o seu desenvolvimento e para a geração de objetivos estratégicos. O foco principal é o **Aprimoramento Auto Recursivo (RSI)**, onde o agente busca ativamente melhorar suas próprias funções e arquitetura.

---

## 1. Capacidades Atuais

### 1.1. Análise e Planejamento
- **Geração de Objetivos (`agent/brain.py`):**
  - Analisa métricas de código estático (complexidade, tamanho do arquivo/função, cobertura de testes).
  - Analisa o manifesto do projeto (`AGENTS.md`).
  - Gera um objetivo de desenvolvimento com base na análise.
  - **Agora considera a análise de performance (`evolution_log.csv`) para otimizar prompts e estratégias.**
- **Análise de Erros (`agent/agents/error_analyzer.py`):**
  - Classifica falhas (ex: erro de sintaxe, falha de teste).
  - Propõe um prompt de correção para o `ArchitectAgent`.
  - **Pode sugerir objetivos de meta-análise para questionar o objetivo ou a estratégia original.**
- **Planejamento de Patches (`agent/agents/architect_agent.py`):**
  - Recebe um objetivo e o manifesto do projeto.
  - Gera um plano de patches em formato JSON para modificar a base de código.
- **Seleção de Estratégia (`agent/agents/maestro_agent.py`):**
  - Analisa o plano de patches.
  - Escolhe uma estratégia de validação apropriada (ex: apenas sintaxe, sintaxe e testes).

### 1.2. Execução e Validação
- **Aplicação de Patches (`agent/patch_applicator.py`):**
  - Aplica as modificações de código propostas em um ambiente de sandbox.
- **Validação de Sintaxe (`agent/validation_steps/syntax_validator.py`):**
  - Verifica a sintaxe de arquivos Python e JSON.
- **Execução de Testes (`agent/validation_steps/pytest_validator.py`):**
  - Executa a suíte de testes `pytest` para validar as alterações.
- **Gerenciamento de Estado e Ciclo (`agent/state.py`, `agent/cycle_runner.py`):**
  - Orquestra o fluxo completo de um ciclo de evolução.
  - Mantém o estado do ciclo atual (objetivo, patches, resultado da validação).
  - **O `cycle_runner.py` agora interage com um `QueueManager` para processar objetivos de forma assíncrona.**

### 1.3. Memória e Versionamento
- **Memória Persistente (`agent/memory.py`):**
  - Registra o histórico de objetivos bem-sucedidos e falhos.
  - Fornece contexto histórico para as decisões dos agentes.
- **Versionamento com Git (`agent/git_utils.py`):**
  - Inicializa o repositório Git.
  - Realiza commits automáticos após a validação bem-sucedida das alterações.

### 1.4. Infraestrutura (Nova)
- **Servidor FastAPI (`app.py`):**
  - Executa o Hephaestus como um serviço em segundo plano.
  - Expõe endpoints para submissão de objetivos e verificação de status.
  - Gerencia um thread worker para processar objetivos da fila.
- **Gerenciamento de Fila (`agent/queue_manager.py`):**
  - Permite a comunicação assíncrona de objetivos entre o servidor e o worker do agente.
- **Carregamento de Configuração (`agent/config_loader.py`):**
  - Módulo dedicado para carregar a configuração do agente de forma centralizada.

---

## 2. Capacidades Desejadas (Roadmap RSI)

O desenvolvimento futuro deve focar em aprimorar a capacidade do agente de entender e melhorar a si mesmo.

### 2.1. Meta-Cognição e Análise de Performance
- **Análise de Performance do Agente:**
  - **Objetivo:** Desenvolver a capacidade de analisar o próprio log de evolução (`evolution_log.csv`) para identificar gargalos, estratégias ineficazes e padrões de falha.
  - **Status:** Implementado. O `PerformanceAnalysisAgent` agora fornece uma análise detalhada do `evolution_log.csv`, incluindo taxa de sucesso geral, taxa de sucesso por estratégia e tempo médio de ciclo. O `generate_next_objective` utiliza essa análise para informar a geração de objetivos.
- **Análise de Causa Raiz (Meta-Análise):**
  - **Objetivo:** Aprimorar o `ErrorAnalysisAgent` para que, diante de falhas repetidas, ele possa questionar a validade do objetivo ou da estratégia, em vez de apenas tentar corrigir o código.
  - **Status:** Iniciado. O `ErrorAnalysisAgent` agora pode sugerir objetivos de meta-análise, e o `generate_next_objective` em `agent/brain.py` foi aprimorado para detectar e processar esses objetivos, gerando um novo objetivo estratégico para abordar a causa raiz da falha.

### 2.2. Aprimoramento da Arquitetura e Estratégia
- **Estratégias de Validação Dinâmicas:**
  - **Objetivo:** Permitir que o `MaestroAgent` não apenas escolha, mas também proponha a criação de novas estratégias de validação com base no contexto da tarefa.
  - **Status:** Iniciado. O `generate_next_objective` agora inclui a otimização de prompts e estratégias como uma prioridade, permitindo que o agente proponha modificações em `hephaestus_config.json` ou refinamento de prompts existentes com base na análise de performance.
- **Refatoração Orientada a Capacidades:**
  - **Objetivo:** Garantir que os objetivos de refatoração estejam sempre ligados a um aprimoramento de capacidade, e não apenas à melhoria de métricas de código.
  - **Status:** Não iniciado. (A base para isso foi estabelecida com a meta-análise e otimização de prompts, mas a refatoração explícita orientada a capacidades ainda não foi implementada).

### 2.3. Expansão de Ferramentas
- **Auto-Aprimoramento de Ferramentas:**
  - **Objetivo:** Dar ao agente a capacidade de modificar e aprimorar suas próprias ferramentas (ex: `tool_executor.py`) quando uma tarefa falha devido a uma limitação da ferramenta.
  - **Status:** Não iniciado. (A meta-análise de falhas pode identificar a necessidade de aprimoramento de ferramentas, mas a implementação autônoma ainda não está presente).

- **Acesso e Raciocínio com Conhecimento Externo:**
  - **Objetivo:** Implementar uma ferramenta de busca na web (`web_search`) robusta, permitindo que o agente pesquise documentação de APIs, soluções para erros e novas bibliotecas para resolver problemas que estão além de seu conhecimento atual.
  - **Status:** Não iniciado.

- **Gerenciamento de Estratégias Dinâmicas:**
  - **Objetivo:** O `MaestroAgent` deve evoluir de um simples selecionador de estratégias para um arquiteto de estratégias. Ele deve ser capaz de propor, e até mesmo codificar, novas estratégias de validação em `hephaestus_config.json` com base nos requisitos de um objetivo.
  - **Status:** Iniciado. O `generate_next_objective` agora inclui a otimização de prompts e estratégias como uma prioridade, permitindo que o agente proponha modificações em `hephaestus_config.json` ou refinamento de prompts existentes com base na análise de performance.


[ROADMAP DOCUMENT (ROADMAP.md)]
# Roadmap de Evolução do Hephaestus

Este documento delineia a visão de alto nível para a evolução do Hephaestus como um agente de **Aprimoramento Auto Recursivo (RSI)**. Ele serve como um guia estratégico, enquanto o `CAPABILITIES.md` detalha os passos táticos.

---

## Fase 1: Consciência e Correção (Curto Prazo)

O foco desta fase é fazer com que o agente pare de executar tarefas cegamente e comece a entender seu próprio desempenho e a corrigir suas falhas de forma mais inteligente.

-   [x] **1. Análise de Performance:**
    -   **Visão:** O agente deve ser capaz de ler seu próprio log de performance (`evolution_log.csv`) e responder a perguntas como: "Qual é a minha taxa de sucesso?", "Quais estratégias falham mais?" e "Onde estou gastando mais tempo?".
    -   **Status:** Implementado. O `PerformanceAnalysisAgent` agora fornece uma análise detalhada do `evolution_log.csv`, incluindo taxa de sucesso geral, taxa de sucesso por estratégia e tempo médio de ciclo. O `generate_next_objective` utiliza essa análise para informar a geração de objetivos.

-   [x] **2. Meta-Análise de Falhas:**
    -   **Visão:** Quando uma tarefa falha repetidamente, o agente deve parar de tentar corrigir o código e, em vez disso, questionar o objetivo em si. Ele deve ser capaz de concluir: "Esta abordagem não está funcionando, preciso de uma nova estratégia ou de uma nova ferramenta".
    -   **Status:** Iniciado. O `ErrorAnalysisAgent` agora pode sugerir objetivos de meta-análise, e o `generate_next_objective` em `agent/brain.py` foi aprimorado para detectar e processar esses objetivos, gerando um novo objetivo estratégico para abordar a causa raiz da falha.

-   [ ] **3. Refatoração Orientada a Capacidades:**
    -   **Visão:** O agente só deve propor refatorações de código se elas estiverem diretamente ligadas a um objetivo de capacitação, como "preciso refatorar este módulo para conseguir implementar uma nova ferramenta de análise".
    -   **Status:** Não iniciado. (A base para isso foi estabelecida com a meta-análise e otimização de prompts, mas a refatoração explícita orientada a capacidades ainda não foi implementada).

---

## Fase 2: Expansão de Habilidades (Médio Prazo)

Com a consciência básica estabelecida, o foco se volta para a expansão proativa de suas próprias habilidades e ferramentas.

-   [ ] **1. Auto-Aprimoramento de Ferramentas:**
    -   **Visão:** O agente deve ser capaz de modificar suas próprias ferramentas (`tool_executor.py`, `validation_steps/`, etc.) quando encontrar uma limitação. Se uma validação é muito fraca ou uma ferramenta não tem um parâmetro necessário, ele deve ser capaz de adicioná-lo.
    -   **Status:** Não iniciado. (A meta-análise de falhas pode identificar a necessidade de aprimoramento de ferramentas, mas a implementação autônoma ainda não está presente).

-   [ ] **2. Acesso e Raciocínio com Conhecimento Externo:**
    -   **Visão:** Implementar uma ferramenta de busca na web (`web_search`) robusta, permitindo que o agente pesquise documentação de APIs, soluções para erros e novas bibliotecas para resolver problemas que estão além de seu conhecimento atual.
    -   **Status:** Não iniciado.

-   [x] **3. Gerenciamento de Estratégias Dinâmicas:**
    -   **Visão:** O `MaestroAgent` deve evoluir de um simples selecionador de estratégias para um arquiteto de estratégias. Ele deve ser capaz de propor, e até mesmo codificar, novas estratégias de validação em `hephaestus_config.json` com base nos requisitos de um objetivo.
    -   **Status:** Iniciado. O `generate_next_objective` agora inclui a otimização de prompts e estratégias como uma prioridade, permitindo que o agente proponha modificações em `hephaestus_config.json` ou refinamento de prompts existentes com base na análise de performance.

---

## Fase 3: Autonomia Estratégica (Longo Prazo)

Nesta fase, o agente transcende a execução de ciclos e começa a gerenciar seu próprio desenvolvimento de forma estratégica.

-   [ ] **1. Planejamento de Longo Prazo:**
    -   **Visão:** O agente deve ser capaz de analisar este próprio `ROADMAP.md` e o `CAPABILITIES.md` para gerar um plano de desenvolvimento de múltiplos passos para si mesmo, em vez de operar em um ciclo de objetivo único.
    -   **Status:** Não iniciado.

-   [ ] **2. Auto-Otimização de Modelos:**
    -   **Visão:** Capturar os prompts e as respostas de maior sucesso para criar conjuntos de dados de fine-tuning. O objetivo final é treinar versões especializadas dos modelos de LLM que sejam mais eficientes e precisas para as tarefas do Hephaestus.
    -   **Status:** Não iniciado.

-   [ ] **3. Arquitetura de Agentes Dinâmica:**
    -   **Visão:** O agente deve ser capaz de propor e implementar mudanças em sua própria arquitetura de agentes, como criar um novo agente especializado (ex: `DocumentationAgent`) ou dividir as responsabilidades de um agente existente, para melhorar a eficiência do sistema.
    -   **Status:** Não iniciado.

---

## Arquitetura de Servidor (Novo)

-   [x] **1. Transformação em Servidor FastAPI:**
    -   **Visão:** O Hephaestus opera como um servidor em segundo plano, permitindo a submissão assíncrona de objetivos e monitoramento de status via API.
    -   **Status:** Implementado. O `main.py` agora inicia um servidor FastAPI, e o agente é executado em um thread worker separado, utilizando um `QueueManager` para gerenciar os objetivos.



[CURRENT PROJECT MANIFEST (if existing)]
N/A (Manifesto non-existent or empty)

[Examples of Smart and Self-Aware Objectives]
*   **Performance-Based Objectives:**
    *   "The agent's success rate is low. Analyze the `evolution_log.csv` to identify the most common causes of failure and propose a solution."
    *   "Given the high number of failed cycles, implement a more robust error analysis mechanism in `error_analyzer.py`."
*   **Prompt/Strategy Optimization Objectives (RSI Focus):**
    *   "The 'SYNTAX_ONLY' strategy has a high failure rate. Analyze the prompts used by the ArchitectAgent when this strategy is chosen and propose modifications to improve syntax correctness."
    *   "Propose a new validation strategy in `hephaestus_config.json` called 'ADVANCED_LINTING' that includes `ruff` checks before applying patches, to reduce syntax errors."
    *   "Analyze the `MaestroAgent`'s decision-making process for objectives related to documentation updates, as the 'DOC_UPDATE_STRATEGY' has a low success rate. Refine its prompt to improve accuracy."
*   **Metrics-Based Refactoring:**
    *   "Refactor the module `agent/brain.py` (LOC: 350) which is extensive, considering splitting responsibilities into smaller modules (e.g., `agent/prompt_builder.py` or `agent/analysis_processor.py`)."
    *   "The function `generate_next_objective` in `agent/brain.py` (LOC: 85, CC: 12) is long and complex. Propose a plan to refactor it into smaller, more focused functions."
    *   "Analyze the most complex functions (CC > 10) listed in the metrics and select one for refactoring."
*   **Test Creation (Generate New Test Files):**
    *   "The module `agent/project_scanner.py` is missing a test file. Create a new test file `tests/agent/test_project_scanner.py` with basic unit tests for the `analyze_code_metrics` function."
    *   "Module `agent/memory.py` lacks tests. Generate `tests/agent/test_memory.py` and include placeholder tests for its public functions."
    *   "Create unit tests for the module `agent/tool_executor.py` in a new file `tests/agent/test_tool_executor.py`, focusing on the `web_search` function."
    *   "The function `call_llm_api` in `agent/utils/llm_client.py` is critical. Ensure robust unit tests exist for it in `tests/agent/utils/test_llm_client.py`, covering success and failure cases. If the test file doesn't exist, create it."
*   **Test-Driven Development (TDD) Flow:**
    *   "The previous cycle successfully created a new test file `tests/agent/test_new_feature.py` which is now failing as expected. The next objective is to implement the minimal code in `agent/new_feature.py` required to make the tests in `tests/agent/test_new_feature.py` pass."
*   **Strategic Documentation Improvement:**
    *   "The manifest (`AGENTS.md`) does not describe the new metrics analysis functionality in `project_scanner.py`. Update it."
    *   "Improve docstrings for public functions in the `agent/memory.py` module to detail parameters and expected behavior."
*   **Development of New Capabilities (Agents/Tools):**
    *   "Create a new agent (e.g., `CodeQualityAgent` in `agent/agents.py`) dedicated to continuously monitoring code quality metrics and reporting regressions."
    *   "Develop a new tool in `agent/tool_executor.py` to automatically validate the syntax of JSON files before processing."
    *   "Propose a system for Hephaestus to evaluate the performance of its own operations and identify bottlenecks."
*   **Generic Objectives (when metrics/manifest are insufficient):**
    *   "Analyze the `agent/state.py` module to identify potential improvements in clarity or efficiency."
    *   "Review recent logs for frequent errors and propose an objective to fix them."

[Your Task]
Based on ALL the information provided (metrics, manifest, history), generate ONLY a single text string containing the NEXT STRATEGIC OBJECTIVE. The objective should be the most impactful and logical for the project's evolution at this moment.
Be concise, but specific enough to be actionable.

2025-07-03 19:55:21,796 - HephaestusAgent - INFO - Calling primary model: gemini/gemini-2.5-pro
2025-07-03 19:55:21,796 - HephaestusAgent - INFO - Attempting to call Gemini API with model: gemini/gemini-2.5-pro
2025-07-03 19:55:58,099 - HephaestusAgent - DEBUG - Gemini API Response: Dado que as tentativas de testar a função `run_cycles` (CC: 89) falharam devido à complexidade de suas dependências, o próximo passo é criar um bloco de construção fundamental para o teste. No arquivo `tests/agent/test_cycle_runner.py`, crie uma `pytest fixture` chamada `mock_agent_state` que retorne um `unittest.mock.MagicMock` para simular a classe `AgentState`. Adicione um teste simples, `test_mock_agent_state_fixture`, que utilize esta fixture para validar que o mock é criado e injetado corretamente, estabelecendo a base para mockar as dependências de forma incremental e segura.
2025-07-03 19:55:58,099 - HephaestusAgent - INFO - Objetivo inicial adicionado à fila: Dado que as tentativas de testar a função `run_cycles` (CC: 89) falharam devido à complexidade de suas dependências, o próximo passo é criar um bloco de construção fundamental para o teste. No arquivo `tests/agent/test_cycle_runner.py`, crie uma `pytest fixture` chamada `mock_agent_state` que retorne um `unittest.mock.MagicMock` para simular a classe `AgentState`. Adicione um teste simples, `test_mock_agent_state_fixture`, que utilize esta fixture para validar que o mock é criado e injetado corretamente, estabelecendo a base para mockar as dependências de forma incremental e segura.
2025-07-03 19:55:58,099 - HephaestusAgent - INFO - Gerando objetivo inicial...
2025-07-03 19:55:58,099 - HephaestusAgent - INFO - Generating next objective...
2025-07-03 19:55:58,099 - HephaestusAgent - INFO - CAPABILITIES.md lido com sucesso.
2025-07-03 19:55:58,099 - HephaestusAgent - INFO - ROADMAP.md lido com sucesso.
2025-07-03 19:55:58,099 - HephaestusAgent - INFO - Analyzing code metrics in: .
2025-07-03 19:55:58,407 - HephaestusAgent - DEBUG - Code analysis summary:
Large Files (potential candidates for modularization):
  - agent/brain.py (LOC: 357)
  - agent/code_metrics.py (LOC: 362)
  - agent/hephaestus_agent.py (LOC: 369)
  - agent/patch_applicator.py (LOC: 697)
  - agent/cycle_runner.py (LOC: 485)
  - agent/project_scanner.py (LOC: 462)

Large Functions (potential candidates for refactoring/splitting):
  - agent/brain.py -> generate_next_objective() (LOC: 162)
  - agent/brain.py -> generate_capacitation_objective() (LOC: 59)
  - agent/brain.py -> generate_commit_message() (LOC: 98)
  - agent/code_metrics.py -> analyze_complexity() (LOC: 84)
  - agent/code_metrics.py -> calculate_quality_score() (LOC: 89)
  - agent/code_metrics.py -> detect_code_duplication() (LOC: 126)
  - agent/git_utils.py -> initialize_git_repository() (LOC: 208)
  - agent/patch_applicator.py -> _handle_replace() (LOC: 71)
  - agent/patch_applicator.py -> _handle_delete_block() (LOC: 78)
  - agent/patch_applicator.py -> apply_patches() (LOC: 285)
  - agent/cycle_runner.py -> run_cycles() (LOC: 460)
  - agent/prompt_builder.py -> build_meta_analysis_objective_prompt() (LOC: 62)
  - agent/prompt_builder.py -> build_standard_objective_prompt() (LOC: 100)
  - agent/project_scanner.py -> update_project_manifest() (LOC: 188)
  - agent/project_scanner.py -> analyze_code_metrics() (LOC: 208)
  - agent/config_loader.py -> load_config() (LOC: 53)
  - agent/utils/json_parser.py -> parse_json_response() (LOC: 75)

Complex Functions (high CC, potential candidates for refactoring/simplification):
  - agent/brain.py -> generate_next_objective() (CC: 43)
  - agent/brain.py -> generate_commit_message() (CC: 15)
  - agent/code_metrics.py -> analyze_complexity() (CC: 15)
  - agent/code_metrics.py -> calculate_quality_score() (CC: 23)
  - agent/code_metrics.py -> detect_code_duplication() (CC: 20)
  - agent/git_utils.py -> initialize_git_repository() (CC: 14)
  - agent/patch_applicator.py -> _handle_replace() (CC: 15)
  - agent/patch_applicator.py -> _handle_delete_block() (CC: 21)
  - agent/patch_applicator.py -> apply_patches() (CC: 65)
  - agent/cycle_runner.py -> run_cycles() (CC: 89)
  - agent/project_scanner.py -> update_project_manifest() (CC: 45)
  - agent/project_scanner.py -> analyze_code_metrics() (CC: 47)
  - agent/utils/json_parser.py -> parse_json_response() (CC: 25)

Modules without Corresponding Test Files (consider creating tests):
  - cli.py
  - app.py
  - run_agent.py
  - agent/brain.py
  - agent/code_metrics.py
  - agent/hephaestus_agent.py
  - agent/git_utils.py
  - agent/code_validator.py
  - agent/patch_applicator.py
  - agent/cycle_runner.py
  - agent/memory.py
  - agent/prompt_builder.py
  - agent/tool_executor.py
  - agent/project_scanner.py
  - agent/state.py
  - agent/config_loader.py
  - agent/validation_steps/pytest_validator.py
  - agent/validation_steps/__init__.py
  - agent/validation_steps/base.py
  - agent/validation_steps/patch_applicator.py
  - agent/validation_steps/syntax_validator.py
  - agent/validation_steps/pytest_new_file_validator.py
  - agent/agents/architect_agent.py
  - agent/agents/performance_analyzer.py
  - agent/agents/error_correction.py
  - agent/agents/maestro_agent.py
  - agent/agents/error_analyzer.py
  - agent/utils/json_parser.py
  - agent/utils/llm_client.py
2025-07-03 19:55:58,407 - HephaestusAgent - INFO - Analyzing performance log...
2025-07-03 19:55:58,413 - HephaestusAgent - DEBUG - Performance analysis summary:
Performance Summary:
- Total Cycles: 5
- Successful Cycles: 2
- Failed Cycles: 3
- Success Rate: 40.00%
- Average Cycle Duration: N/A

Performance by Strategy (sorted by failures):
- Strategy 'SYNTAX_AND_PYTEST': Success Rate: 0.00% (Failures: 3/3)
- Strategy 'CREATE_NEW_TEST_FILE_STRATEGY': Success Rate: 100.00% (Failures: 0/2)

2025-07-03 19:55:58,413 - HephaestusAgent - DEBUG - Prompt for generate_next_objective:

[Main Context]
You are the 'Planejador Estratégico Avançado' do agente autônomo Hephaestus. Sua principal responsabilidade é identificar e propor o próximo objetivo de desenvolvimento mais impactante para a evolução do agente ou do projeto em análise.

[Decision Process for the Next Objective]
1.  **Analyze Performance:** Review the `[PERFORMANCE ANALYSIS]` section.
2.  **Analyze Code Metrics:** Review the `[CODE METRICS AND ANALYSIS]` section.
3.  **Consider Strategic Documents:** Review `[CAPABILITIES DOCUMENT]` and `[ROADMAP DOCUMENT]` to understand current capabilities, desired future states, and strategic direction. Identify gaps or next steps.
4.  **Consider the Project Manifest:** If the `[CURRENT PROJECT MANIFEST]` is provided, use it for context.
5.  **Review Recent History:** The `[HISTÓRICO RECENTE DO PROJETO E DO AGENTE]` section provides context.
6.  **Prioritize RSI:** Focus on objectives that enhance the agent's ability to self-improve, improve its core logic, prompts, or strategies.
7.  **Prioritize Capabilities & Roadmap:** Generate objectives that fill gaps in `[CAPABILITIES DOCUMENT]` or advance items in `[ROADMAP DOCUMENT]`.
8.  **Prioritize Structural and Quality Improvements:** Based on metrics and strategic documents.
9.  **Be Specific and Actionable:** The objective should be clear, concise, and indicate a concrete action.

1.  **Analyze Performance:** Review the `[PERFORMANCE ANALYSIS]` section to understand the agent's overall success rate and identify trends, especially focusing on strategies with high failure rates.
2.  **Analyze Code Metrics:** Review the `[CODE METRICS AND ANALYSIS]` section below. It contains data on file size (LOC), function size (LOC), cyclomatic complexity (CC) of functions, and modules that may be missing tests.
3.  **Consider the Project Manifest:** If the `[CURRENT PROJECT MANIFEST]` is provided, use it to understand the overall goals, architecture, and areas already documented or needing attention.
4.  **Review Recent History:** The `[HISTÓRICO RECENTE DO PROJETO E DO AGENTE]` section provides context on recent tasks, successes, and failures. Avoid repeating objectives that recently failed in the same way, unless the cause of failure has been resolved. Use history to build on successes.
5.  **Prioritize Structural and Quality Improvements:** Based on metrics, identify opportunities to:
    *   Refactor very large modules or very long/complex functions.
    *   Create tests for critical/complex modules or functions that lack them.
    *   Improve documentation (docstrings, manifest) where crucial.
    *   Propose the creation of new capabilities (new agents, tools) if the analysis indicates a strategic need.
6.  **Prioritize Prompt and Strategy Optimization (RSI Focus):** If the performance analysis reveals strategies with consistently low success rates, consider objectives to:
    *   Refine the prompts used by agents (e.g., Architect, Maestro, ErrorAnalysis) for those failing strategies.
    *   Propose new or modified validation strategies in `hephaestus_config.json` to address specific failure patterns.
7.  **Be Specific and Actionable:** The objective should be clear, concise, and indicate a concrete action.


[HISTÓRICO RECENTE DO PROJETO E DO AGENTE]
Completed Objectives (most recent first):
- Objective: Com base no sucesso da criação do arquivo `tests/agent/test_cycle_runner.py`, o próximo passo incremental é adicionar um teste simples que apenas importa a função `run_cycles` de `agent.cycle_runner`. Este teste (`def test_run_cycles_importable(): from agent.cycle_runner import run_cycles`) validará que a função, com sua altíssima complexidade (CC: 89), pode ser importada sem causar erros de importação ou efeitos colaterais, estabelecendo uma base mais sólida para futuros testes de lógica e refatoração.
  Strategy: CREATE_NEW_TEST_FILE_STRATEGY
  Outcome: Strategy 'CREATE_NEW_TEST_FILE_STRATEGY' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T22:29:08.784181+00:00
- Objective: Dadas as falhas consecutivas ao tentar testar e refatorar a função `run_cycles` (CC: 89), o próximo passo deve ser mais incremental para garantir sucesso. Crie o arquivo de teste `tests/agent/test_cycle_runner.py` contendo apenas um "smoke test" (ex: `def test_placeholder(): assert True`) para validar que o ambiente de teste para este módulo crítico está funcionando e que o pytest executa com sucesso (exit code 0), estabelecendo assim uma base estável para futuros testes de lógica.
  Strategy: CREATE_NEW_TEST_FILE_STRATEGY
  Outcome: Strategy 'CREATE_NEW_TEST_FILE_STRATEGY' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T22:27:49.062600+00:00

Failed Objectives (most recent first):
- Objective: Dado o sucesso em criar o arquivo de teste para `cycle_runner`, o próximo passo é adicionar um teste de caracterização para a função `run_cycles` (CC: 89). Este teste deve usar `unittest.mock` para simular as dependências essenciais (como `AgentState` e `QueueManager`) e invocar a função, validando que ela pode ser executada em um cenário controlado sem erros, estabelecendo assim a base para testes de lógica mais detalhados e refatoração segura.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_qyaqjai0)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:41:06.299306+00:00
- Objective: Para iniciar a refatoração da função `run_cycles` (CC: 89), que é a mais complexa do projeto, extraia a lógica de inicialização do ciclo (criação do `AgentState` e logs iniciais) para uma nova função auxiliar privada dentro de `agent/cycle_runner.py`. Em seguida, adicione um teste unitário no arquivo `tests/agent/test_cycle_runner.py` que valide especificamente o comportamento desta nova função extraída, garantindo um progresso incremental e seguro.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_v22kn3j2)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:31:44.352659+00:00
Consider this history to avoid repeating failures, build on successes, and identify gaps.


[PERFORMANCE ANALYSIS]
Performance Summary:
- Total Cycles: 5
- Successful Cycles: 2
- Failed Cycles: 3
- Success Rate: 40.00%
- Average Cycle Duration: N/A

Performance by Strategy (sorted by failures):
- Strategy 'SYNTAX_AND_PYTEST': Success Rate: 0.00% (Failures: 3/3)
- Strategy 'CREATE_NEW_TEST_FILE_STRATEGY': Success Rate: 100.00% (Failures: 0/2)


[CODE METRICS AND ANALYSIS]
Large Files (potential candidates for modularization):
  - agent/brain.py (LOC: 357)
  - agent/code_metrics.py (LOC: 362)
  - agent/hephaestus_agent.py (LOC: 369)
  - agent/patch_applicator.py (LOC: 697)
  - agent/cycle_runner.py (LOC: 485)
  - agent/project_scanner.py (LOC: 462)

Large Functions (potential candidates for refactoring/splitting):
  - agent/brain.py -> generate_next_objective() (LOC: 162)
  - agent/brain.py -> generate_capacitation_objective() (LOC: 59)
  - agent/brain.py -> generate_commit_message() (LOC: 98)
  - agent/code_metrics.py -> analyze_complexity() (LOC: 84)
  - agent/code_metrics.py -> calculate_quality_score() (LOC: 89)
  - agent/code_metrics.py -> detect_code_duplication() (LOC: 126)
  - agent/git_utils.py -> initialize_git_repository() (LOC: 208)
  - agent/patch_applicator.py -> _handle_replace() (LOC: 71)
  - agent/patch_applicator.py -> _handle_delete_block() (LOC: 78)
  - agent/patch_applicator.py -> apply_patches() (LOC: 285)
  - agent/cycle_runner.py -> run_cycles() (LOC: 460)
  - agent/prompt_builder.py -> build_meta_analysis_objective_prompt() (LOC: 62)
  - agent/prompt_builder.py -> build_standard_objective_prompt() (LOC: 100)
  - agent/project_scanner.py -> update_project_manifest() (LOC: 188)
  - agent/project_scanner.py -> analyze_code_metrics() (LOC: 208)
  - agent/config_loader.py -> load_config() (LOC: 53)
  - agent/utils/json_parser.py -> parse_json_response() (LOC: 75)

Complex Functions (high CC, potential candidates for refactoring/simplification):
  - agent/brain.py -> generate_next_objective() (CC: 43)
  - agent/brain.py -> generate_commit_message() (CC: 15)
  - agent/code_metrics.py -> analyze_complexity() (CC: 15)
  - agent/code_metrics.py -> calculate_quality_score() (CC: 23)
  - agent/code_metrics.py -> detect_code_duplication() (CC: 20)
  - agent/git_utils.py -> initialize_git_repository() (CC: 14)
  - agent/patch_applicator.py -> _handle_replace() (CC: 15)
  - agent/patch_applicator.py -> _handle_delete_block() (CC: 21)
  - agent/patch_applicator.py -> apply_patches() (CC: 65)
  - agent/cycle_runner.py -> run_cycles() (CC: 89)
  - agent/project_scanner.py -> update_project_manifest() (CC: 45)
  - agent/project_scanner.py -> analyze_code_metrics() (CC: 47)
  - agent/utils/json_parser.py -> parse_json_response() (CC: 25)

Modules without Corresponding Test Files (consider creating tests):
  - cli.py
  - app.py
  - run_agent.py
  - agent/brain.py
  - agent/code_metrics.py
  - agent/hephaestus_agent.py
  - agent/git_utils.py
  - agent/code_validator.py
  - agent/patch_applicator.py
  - agent/cycle_runner.py
  - agent/memory.py
  - agent/prompt_builder.py
  - agent/tool_executor.py
  - agent/project_scanner.py
  - agent/state.py
  - agent/config_loader.py
  - agent/validation_steps/pytest_validator.py
  - agent/validation_steps/__init__.py
  - agent/validation_steps/base.py
  - agent/validation_steps/patch_applicator.py
  - agent/validation_steps/syntax_validator.py
  - agent/validation_steps/pytest_new_file_validator.py
  - agent/agents/architect_agent.py
  - agent/agents/performance_analyzer.py
  - agent/agents/error_correction.py
  - agent/agents/maestro_agent.py
  - agent/agents/error_analyzer.py
  - agent/utils/json_parser.py
  - agent/utils/llm_client.py

[CAPABILITIES DOCUMENT (CAPABILITIES.md)]
# Manifesto de Capacidades do Hephaestus

Este documento descreve as capacidades atuais e desejadas do agente Hephaestus, servindo como um guia para o seu desenvolvimento e para a geração de objetivos estratégicos. O foco principal é o **Aprimoramento Auto Recursivo (RSI)**, onde o agente busca ativamente melhorar suas próprias funções e arquitetura.

---

## 1. Capacidades Atuais

### 1.1. Análise e Planejamento
- **Geração de Objetivos (`agent/brain.py`):**
  - Analisa métricas de código estático (complexidade, tamanho do arquivo/função, cobertura de testes).
  - Analisa o manifesto do projeto (`AGENTS.md`).
  - Gera um objetivo de desenvolvimento com base na análise.
  - **Agora considera a análise de performance (`evolution_log.csv`) para otimizar prompts e estratégias.**
- **Análise de Erros (`agent/agents/error_analyzer.py`):**
  - Classifica falhas (ex: erro de sintaxe, falha de teste).
  - Propõe um prompt de correção para o `ArchitectAgent`.
  - **Pode sugerir objetivos de meta-análise para questionar o objetivo ou a estratégia original.**
- **Planejamento de Patches (`agent/agents/architect_agent.py`):**
  - Recebe um objetivo e o manifesto do projeto.
  - Gera um plano de patches em formato JSON para modificar a base de código.
- **Seleção de Estratégia (`agent/agents/maestro_agent.py`):**
  - Analisa o plano de patches.
  - Escolhe uma estratégia de validação apropriada (ex: apenas sintaxe, sintaxe e testes).

### 1.2. Execução e Validação
- **Aplicação de Patches (`agent/patch_applicator.py`):**
  - Aplica as modificações de código propostas em um ambiente de sandbox.
- **Validação de Sintaxe (`agent/validation_steps/syntax_validator.py`):**
  - Verifica a sintaxe de arquivos Python e JSON.
- **Execução de Testes (`agent/validation_steps/pytest_validator.py`):**
  - Executa a suíte de testes `pytest` para validar as alterações.
- **Gerenciamento de Estado e Ciclo (`agent/state.py`, `agent/cycle_runner.py`):**
  - Orquestra o fluxo completo de um ciclo de evolução.
  - Mantém o estado do ciclo atual (objetivo, patches, resultado da validação).
  - **O `cycle_runner.py` agora interage com um `QueueManager` para processar objetivos de forma assíncrona.**

### 1.3. Memória e Versionamento
- **Memória Persistente (`agent/memory.py`):**
  - Registra o histórico de objetivos bem-sucedidos e falhos.
  - Fornece contexto histórico para as decisões dos agentes.
- **Versionamento com Git (`agent/git_utils.py`):**
  - Inicializa o repositório Git.
  - Realiza commits automáticos após a validação bem-sucedida das alterações.

### 1.4. Infraestrutura (Nova)
- **Servidor FastAPI (`app.py`):**
  - Executa o Hephaestus como um serviço em segundo plano.
  - Expõe endpoints para submissão de objetivos e verificação de status.
  - Gerencia um thread worker para processar objetivos da fila.
- **Gerenciamento de Fila (`agent/queue_manager.py`):**
  - Permite a comunicação assíncrona de objetivos entre o servidor e o worker do agente.
- **Carregamento de Configuração (`agent/config_loader.py`):**
  - Módulo dedicado para carregar a configuração do agente de forma centralizada.

---

## 2. Capacidades Desejadas (Roadmap RSI)

O desenvolvimento futuro deve focar em aprimorar a capacidade do agente de entender e melhorar a si mesmo.

### 2.1. Meta-Cognição e Análise de Performance
- **Análise de Performance do Agente:**
  - **Objetivo:** Desenvolver a capacidade de analisar o próprio log de evolução (`evolution_log.csv`) para identificar gargalos, estratégias ineficazes e padrões de falha.
  - **Status:** Implementado. O `PerformanceAnalysisAgent` agora fornece uma análise detalhada do `evolution_log.csv`, incluindo taxa de sucesso geral, taxa de sucesso por estratégia e tempo médio de ciclo. O `generate_next_objective` utiliza essa análise para informar a geração de objetivos.
- **Análise de Causa Raiz (Meta-Análise):**
  - **Objetivo:** Aprimorar o `ErrorAnalysisAgent` para que, diante de falhas repetidas, ele possa questionar a validade do objetivo ou da estratégia, em vez de apenas tentar corrigir o código.
  - **Status:** Iniciado. O `ErrorAnalysisAgent` agora pode sugerir objetivos de meta-análise, e o `generate_next_objective` em `agent/brain.py` foi aprimorado para detectar e processar esses objetivos, gerando um novo objetivo estratégico para abordar a causa raiz da falha.

### 2.2. Aprimoramento da Arquitetura e Estratégia
- **Estratégias de Validação Dinâmicas:**
  - **Objetivo:** Permitir que o `MaestroAgent` não apenas escolha, mas também proponha a criação de novas estratégias de validação com base no contexto da tarefa.
  - **Status:** Iniciado. O `generate_next_objective` agora inclui a otimização de prompts e estratégias como uma prioridade, permitindo que o agente proponha modificações em `hephaestus_config.json` ou refinamento de prompts existentes com base na análise de performance.
- **Refatoração Orientada a Capacidades:**
  - **Objetivo:** Garantir que os objetivos de refatoração estejam sempre ligados a um aprimoramento de capacidade, e não apenas à melhoria de métricas de código.
  - **Status:** Não iniciado. (A base para isso foi estabelecida com a meta-análise e otimização de prompts, mas a refatoração explícita orientada a capacidades ainda não foi implementada).

### 2.3. Expansão de Ferramentas
- **Auto-Aprimoramento de Ferramentas:**
  - **Objetivo:** Dar ao agente a capacidade de modificar e aprimorar suas próprias ferramentas (ex: `tool_executor.py`) quando uma tarefa falha devido a uma limitação da ferramenta.
  - **Status:** Não iniciado. (A meta-análise de falhas pode identificar a necessidade de aprimoramento de ferramentas, mas a implementação autônoma ainda não está presente).

- **Acesso e Raciocínio com Conhecimento Externo:**
  - **Objetivo:** Implementar uma ferramenta de busca na web (`web_search`) robusta, permitindo que o agente pesquise documentação de APIs, soluções para erros e novas bibliotecas para resolver problemas que estão além de seu conhecimento atual.
  - **Status:** Não iniciado.

- **Gerenciamento de Estratégias Dinâmicas:**
  - **Objetivo:** O `MaestroAgent` deve evoluir de um simples selecionador de estratégias para um arquiteto de estratégias. Ele deve ser capaz de propor, e até mesmo codificar, novas estratégias de validação em `hephaestus_config.json` com base nos requisitos de um objetivo.
  - **Status:** Iniciado. O `generate_next_objective` agora inclui a otimização de prompts e estratégias como uma prioridade, permitindo que o agente proponha modificações em `hephaestus_config.json` ou refinamento de prompts existentes com base na análise de performance.


[ROADMAP DOCUMENT (ROADMAP.md)]
# Roadmap de Evolução do Hephaestus

Este documento delineia a visão de alto nível para a evolução do Hephaestus como um agente de **Aprimoramento Auto Recursivo (RSI)**. Ele serve como um guia estratégico, enquanto o `CAPABILITIES.md` detalha os passos táticos.

---

## Fase 1: Consciência e Correção (Curto Prazo)

O foco desta fase é fazer com que o agente pare de executar tarefas cegamente e comece a entender seu próprio desempenho e a corrigir suas falhas de forma mais inteligente.

-   [x] **1. Análise de Performance:**
    -   **Visão:** O agente deve ser capaz de ler seu próprio log de performance (`evolution_log.csv`) e responder a perguntas como: "Qual é a minha taxa de sucesso?", "Quais estratégias falham mais?" e "Onde estou gastando mais tempo?".
    -   **Status:** Implementado. O `PerformanceAnalysisAgent` agora fornece uma análise detalhada do `evolution_log.csv`, incluindo taxa de sucesso geral, taxa de sucesso por estratégia e tempo médio de ciclo. O `generate_next_objective` utiliza essa análise para informar a geração de objetivos.

-   [x] **2. Meta-Análise de Falhas:**
    -   **Visão:** Quando uma tarefa falha repetidamente, o agente deve parar de tentar corrigir o código e, em vez disso, questionar o objetivo em si. Ele deve ser capaz de concluir: "Esta abordagem não está funcionando, preciso de uma nova estratégia ou de uma nova ferramenta".
    -   **Status:** Iniciado. O `ErrorAnalysisAgent` agora pode sugerir objetivos de meta-análise, e o `generate_next_objective` em `agent/brain.py` foi aprimorado para detectar e processar esses objetivos, gerando um novo objetivo estratégico para abordar a causa raiz da falha.

-   [ ] **3. Refatoração Orientada a Capacidades:**
    -   **Visão:** O agente só deve propor refatorações de código se elas estiverem diretamente ligadas a um objetivo de capacitação, como "preciso refatorar este módulo para conseguir implementar uma nova ferramenta de análise".
    -   **Status:** Não iniciado. (A base para isso foi estabelecida com a meta-análise e otimização de prompts, mas a refatoração explícita orientada a capacidades ainda não foi implementada).

---

## Fase 2: Expansão de Habilidades (Médio Prazo)

Com a consciência básica estabelecida, o foco se volta para a expansão proativa de suas próprias habilidades e ferramentas.

-   [ ] **1. Auto-Aprimoramento de Ferramentas:**
    -   **Visão:** O agente deve ser capaz de modificar suas próprias ferramentas (`tool_executor.py`, `validation_steps/`, etc.) quando encontrar uma limitação. Se uma validação é muito fraca ou uma ferramenta não tem um parâmetro necessário, ele deve ser capaz de adicioná-lo.
    -   **Status:** Não iniciado. (A meta-análise de falhas pode identificar a necessidade de aprimoramento de ferramentas, mas a implementação autônoma ainda não está presente).

-   [ ] **2. Acesso e Raciocínio com Conhecimento Externo:**
    -   **Visão:** Implementar uma ferramenta de busca na web (`web_search`) robusta, permitindo que o agente pesquise documentação de APIs, soluções para erros e novas bibliotecas para resolver problemas que estão além de seu conhecimento atual.
    -   **Status:** Não iniciado.

-   [x] **3. Gerenciamento de Estratégias Dinâmicas:**
    -   **Visão:** O `MaestroAgent` deve evoluir de um simples selecionador de estratégias para um arquiteto de estratégias. Ele deve ser capaz de propor, e até mesmo codificar, novas estratégias de validação em `hephaestus_config.json` com base nos requisitos de um objetivo.
    -   **Status:** Iniciado. O `generate_next_objective` agora inclui a otimização de prompts e estratégias como uma prioridade, permitindo que o agente proponha modificações em `hephaestus_config.json` ou refinamento de prompts existentes com base na análise de performance.

---

## Fase 3: Autonomia Estratégica (Longo Prazo)

Nesta fase, o agente transcende a execução de ciclos e começa a gerenciar seu próprio desenvolvimento de forma estratégica.

-   [ ] **1. Planejamento de Longo Prazo:**
    -   **Visão:** O agente deve ser capaz de analisar este próprio `ROADMAP.md` e o `CAPABILITIES.md` para gerar um plano de desenvolvimento de múltiplos passos para si mesmo, em vez de operar em um ciclo de objetivo único.
    -   **Status:** Não iniciado.

-   [ ] **2. Auto-Otimização de Modelos:**
    -   **Visão:** Capturar os prompts e as respostas de maior sucesso para criar conjuntos de dados de fine-tuning. O objetivo final é treinar versões especializadas dos modelos de LLM que sejam mais eficientes e precisas para as tarefas do Hephaestus.
    -   **Status:** Não iniciado.

-   [ ] **3. Arquitetura de Agentes Dinâmica:**
    -   **Visão:** O agente deve ser capaz de propor e implementar mudanças em sua própria arquitetura de agentes, como criar um novo agente especializado (ex: `DocumentationAgent`) ou dividir as responsabilidades de um agente existente, para melhorar a eficiência do sistema.
    -   **Status:** Não iniciado.

---

## Arquitetura de Servidor (Novo)

-   [x] **1. Transformação em Servidor FastAPI:**
    -   **Visão:** O Hephaestus opera como um servidor em segundo plano, permitindo a submissão assíncrona de objetivos e monitoramento de status via API.
    -   **Status:** Implementado. O `main.py` agora inicia um servidor FastAPI, e o agente é executado em um thread worker separado, utilizando um `QueueManager` para gerenciar os objetivos.



[CURRENT PROJECT MANIFEST (if existing)]
N/A (Manifesto non-existent or empty)

[Examples of Smart and Self-Aware Objectives]
*   **Performance-Based Objectives:**
    *   "The agent's success rate is low. Analyze the `evolution_log.csv` to identify the most common causes of failure and propose a solution."
    *   "Given the high number of failed cycles, implement a more robust error analysis mechanism in `error_analyzer.py`."
*   **Prompt/Strategy Optimization Objectives (RSI Focus):**
    *   "The 'SYNTAX_ONLY' strategy has a high failure rate. Analyze the prompts used by the ArchitectAgent when this strategy is chosen and propose modifications to improve syntax correctness."
    *   "Propose a new validation strategy in `hephaestus_config.json` called 'ADVANCED_LINTING' that includes `ruff` checks before applying patches, to reduce syntax errors."
    *   "Analyze the `MaestroAgent`'s decision-making process for objectives related to documentation updates, as the 'DOC_UPDATE_STRATEGY' has a low success rate. Refine its prompt to improve accuracy."
*   **Metrics-Based Refactoring:**
    *   "Refactor the module `agent/brain.py` (LOC: 350) which is extensive, considering splitting responsibilities into smaller modules (e.g., `agent/prompt_builder.py` or `agent/analysis_processor.py`)."
    *   "The function `generate_next_objective` in `agent/brain.py` (LOC: 85, CC: 12) is long and complex. Propose a plan to refactor it into smaller, more focused functions."
    *   "Analyze the most complex functions (CC > 10) listed in the metrics and select one for refactoring."
*   **Test Creation (Generate New Test Files):**
    *   "The module `agent/project_scanner.py` is missing a test file. Create a new test file `tests/agent/test_project_scanner.py` with basic unit tests for the `analyze_code_metrics` function."
    *   "Module `agent/memory.py` lacks tests. Generate `tests/agent/test_memory.py` and include placeholder tests for its public functions."
    *   "Create unit tests for the module `agent/tool_executor.py` in a new file `tests/agent/test_tool_executor.py`, focusing on the `web_search` function."
    *   "The function `call_llm_api` in `agent/utils/llm_client.py` is critical. Ensure robust unit tests exist for it in `tests/agent/utils/test_llm_client.py`, covering success and failure cases. If the test file doesn't exist, create it."
*   **Test-Driven Development (TDD) Flow:**
    *   "The previous cycle successfully created a new test file `tests/agent/test_new_feature.py` which is now failing as expected. The next objective is to implement the minimal code in `agent/new_feature.py` required to make the tests in `tests/agent/test_new_feature.py` pass."
*   **Strategic Documentation Improvement:**
    *   "The manifest (`AGENTS.md`) does not describe the new metrics analysis functionality in `project_scanner.py`. Update it."
    *   "Improve docstrings for public functions in the `agent/memory.py` module to detail parameters and expected behavior."
*   **Development of New Capabilities (Agents/Tools):**
    *   "Create a new agent (e.g., `CodeQualityAgent` in `agent/agents.py`) dedicated to continuously monitoring code quality metrics and reporting regressions."
    *   "Develop a new tool in `agent/tool_executor.py` to automatically validate the syntax of JSON files before processing."
    *   "Propose a system for Hephaestus to evaluate the performance of its own operations and identify bottlenecks."
*   **Generic Objectives (when metrics/manifest are insufficient):**
    *   "Analyze the `agent/state.py` module to identify potential improvements in clarity or efficiency."
    *   "Review recent logs for frequent errors and propose an objective to fix them."

[Your Task]
Based on ALL the information provided (metrics, manifest, history), generate ONLY a single text string containing the NEXT STRATEGIC OBJECTIVE. The objective should be the most impactful and logical for the project's evolution at this moment.
Be concise, but specific enough to be actionable.

2025-07-03 19:55:58,414 - HephaestusAgent - INFO - Calling primary model: gemini/gemini-2.5-pro
2025-07-03 19:55:58,414 - HephaestusAgent - INFO - Attempting to call Gemini API with model: gemini/gemini-2.5-pro
2025-07-03 19:56:28,440 - HephaestusAgent - DEBUG - Gemini API Response: Dado que as tentativas de testar a função `run_cycles` (CC: 89) com mocks falharam, indicando uma lacuna na capacidade de teste do agente, o próximo passo deve ser um objetivo de capacitação focado. Crie o arquivo de teste `tests/agent/test_memory.py` e adicione um teste unitário para uma função simples de escrita, como `save_to_log`. Este teste deve usar `unittest.mock.patch` para simular a interação com o sistema de arquivos (ex: `builtins.open`), validando a lógica da função de forma isolada e ensinando o agente a aplicar mocks com sucesso antes de tentar novamente em alvos mais complexos.
2025-07-03 19:56:28,440 - HephaestusAgent - INFO - Objetivo inicial: Dado que as tentativas de testar a função `run_cycles` (CC: 89) com mocks falharam, indicando uma lacuna na capacidade de teste do agente, o próximo passo deve ser um objetivo de capacitação focado. Crie o arquivo de teste `tests/agent/test_memory.py` e adicione um teste unitário para uma função simples de escrita, como `save_to_log`. Este teste deve usar `unittest.mock.patch` para simular a interação com o sistema de arquivos (ex: `builtins.open`), validando a lógica da função de forma isolada e ensinando o agente a aplicar mocks com sucesso antes de tentar novamente em alvos mais complexos.
2025-07-03 19:56:28,440 - HephaestusAgent - INFO - Iniciando HephaestusAgent. Modo Contínuo: DESATIVADO.
2025-07-03 19:56:28,440 - HephaestusAgent - INFO - 

==================== INÍCIO DO CICLO DE EVOLUÇÃO (Ciclo #1) ====================
2025-07-03 19:56:28,440 - HephaestusAgent - INFO - OBJETIVO ATUAL: Dado que as tentativas de testar a função `run_cycles` (CC: 89) com mocks falharam, indicando uma lacuna na capacidade de teste do agente, o próximo passo deve ser um objetivo de capacitação focado. Crie o arquivo de teste `tests/agent/test_memory.py` e adicione um teste unitário para uma função simples de escrita, como `save_to_log`. Este teste deve usar `unittest.mock.patch` para simular a interação com o sistema de arquivos (ex: `builtins.open`), validando a lógica da função de forma isolada e ensinando o agente a aplicar mocks com sucesso antes de tentar novamente em alvos mais complexos.

2025-07-03 19:56:28,440 - HephaestusAgent - INFO - Gerando manifesto do projeto (AGENTS.md)...
2025-07-03 19:56:28,494 - HephaestusAgent - INFO - --- MANIFESTO GERADO (Tamanho: 11020 caracteres) ---
2025-07-03 19:56:28,495 - HephaestusAgent - INFO - 
Solicitando plano de ação do ArchitectAgent...
2025-07-03 19:56:28,495 - HephaestusAgent.ArchitectAgent - INFO - ArchitectAgent: Gerando plano de patches com os modelos: {'_target_': 'builtins.dict', 'temperature': 0.3, 'max_tokens': -1, 'primary': 'gemini/gemini-2.5-pro', 'fallback': 'deepseek/deepseek-r1-0528:free'}...
2025-07-03 19:56:28,495 - HephaestusAgent.ArchitectAgent - INFO - Calling primary model: gemini/gemini-2.5-pro
2025-07-03 19:56:28,495 - HephaestusAgent.ArchitectAgent - INFO - Attempting to call Gemini API with model: gemini/gemini-2.5-pro
2025-07-03 19:56:51,783 - HephaestusAgent.ArchitectAgent - DEBUG - Gemini API Response: ```json
{
  "analysis": "O objetivo é criar um arquivo de teste para a classe `Memory` e, especificamente, para o método `save_to_log`. Esta ação serve como um exercício de capacitação para o agente aprender a usar mocks, uma habilidade necessária que foi identificada como ausente em tentativas de teste anteriores. O plano cria o novo arquivo de teste `tests/agent/test_memory.py`. Este arquivo conterá uma classe de teste `TestMemory` com um método `test_save_to_log_writes_to_file`. Este teste utilizará `unittest.mock.patch` para simular a função `builtins.open`, isolando o teste da interação real com o sistema de arquivos e focando na validação da lógica interna do método `save_to_log`.",
  "patches_to_apply": [
    {
      "file_path": "tests/agent/test_memory.py",
      "operation": "REPLACE",
      "block_to_replace": null,
      "content": "import unittest\nfrom unittest.mock import patch, mock_open\nimport logging\nfrom agent.memory import Memory\n\n# Desabilitar logs durante os testes para manter a saída limpa\nlogging.disable(logging.CRITICAL)\n\nclass TestMemory(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Configura uma nova instância de Memory para cada teste.\"\"\"\n        # Inicializamos Memory com caminhos fictícios, pois as operações de arquivo serão mockadas.\n        self.memory = Memory(log_file='dummy_log.txt', memory_file='dummy_memory.json')\n\n    @patch(\"builtins.open\", new_callable=mock_open)\n    def test_save_to_log_writes_to_file(self, mock_file_open):\n        \"\"\"\n        Testa se save_to_log abre corretamente o arquivo de log e escreve a mensagem.\n        \"\"\"\n        test_message = \"Esta é uma mensagem de log de teste.\"\n        self.memory.save_to_log(test_message)\n\n        # Verifica se 'open' foi chamado corretamente no arquivo de log em modo de anexação ('a')\n        mock_file_open.assert_called_once_with(self.memory.log_file, 'a', encoding='utf-8')\n\n        # Verifica se o método 'write' foi chamado com a mensagem correta\n        # O 'handle' é o valor de retorno de open()\n        handle = mock_file_open()\n        # Assumimos que a função adiciona uma nova linha ao final da mensagem\n        handle.write.assert_called_once_with(f\"{test_message}\\n\")\n\nif __name__ == '__main__':\n    unittest.main()\n"
    }
  ]
}
```
2025-07-03 19:56:51,784 - HephaestusAgent.ArchitectAgent - DEBUG - parse_json_response: Raw response before cleaning: ```json
{
  "analysis": "O objetivo é criar um arquivo de teste para a classe `Memory` e, especificamente, para o método `save_to_log`. Esta ação serve como um exercício de capacitação para o agente aprender a usar mocks, uma habilidade necessária que foi identificada como ausente em tentativas de t...
2025-07-03 19:56:51,784 - HephaestusAgent.ArchitectAgent - DEBUG - parse_json_response: Extracted JSON content based on braces: {
  "analysis": "O objetivo é criar um arquivo de teste para a classe `Memory` e, especificamente, para o método `save_to_log`. Esta ação serve como um exercício de capacitação para o agente aprender a usar mocks, uma habilidade necessária que foi identificada como ausente em tentativas de teste ant...
2025-07-03 19:56:51,784 - HephaestusAgent.ArchitectAgent - DEBUG - parse_json_response: Final cleaned content before parsing: {
  "analysis": "O objetivo é criar um arquivo de teste para a classe `Memory` e, especificamente, para o método `save_to_log`. Esta ação serve como um exercício de capacitação para o agente aprender a usar mocks, uma habilidade necessária que foi identificada como ausente em tentativas de teste ant...
2025-07-03 19:56:51,784 - HephaestusAgent - INFO - --- PLANO DE AÇÃO (PATCHES) GERADO PELO ARCHITECTAGENT ({'_target_': 'builtins.dict', 'temperature': 0.3, 'max_tokens': -1, 'primary': 'gemini/gemini-2.5-pro', 'fallback': 'deepseek/deepseek-r1-0528:free'}) ---
2025-07-03 19:56:51,784 - HephaestusAgent - DEBUG - Análise do Arquiteto: O objetivo é criar um arquivo de teste para a classe `Memory` e, especificamente, para o método `save_to_log`. Esta ação serve como um exercício de capacitação para o agente aprender a usar mocks, uma habilidade necessária que foi identificada como ausente em tentativas de teste anteriores. O plano cria o novo arquivo de teste `tests/agent/test_memory.py`. Este arquivo conterá uma classe de teste `TestMemory` com um método `test_save_to_log_writes_to_file`. Este teste utilizará `unittest.mock.patch` para simular a função `builtins.open`, isolando o teste da interação real com o sistema de arquivos e focando na validação da lógica interna do método `save_to_log`.
2025-07-03 19:56:51,784 - HephaestusAgent - DEBUG - Patches: [
  {
    "file_path": "tests/agent/test_memory.py",
    "operation": "REPLACE",
    "block_to_replace": null,
    "content": "import unittest\nfrom unittest.mock import patch, mock_open\nimport logging\nfrom agent.memory import Memory\n\n# Desabilitar logs durante os testes para manter a sa\u00edda limpa\nlogging.disable(logging.CRITICAL)\n\nclass TestMemory(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Configura uma nova inst\u00e2ncia de Memory para cada teste.\"\"\"\n        # Inicializamos Memory com caminhos fict\u00edcios, pois as opera\u00e7\u00f5es de arquivo ser\u00e3o mockadas.\n        self.memory = Memory(log_file='dummy_log.txt', memory_file='dummy_memory.json')\n\n    @patch(\"builtins.open\", new_callable=mock_open)\n    def test_save_to_log_writes_to_file(self, mock_file_open):\n        \"\"\"\n        Testa se save_to_log abre corretamente o arquivo de log e escreve a mensagem.\n        \"\"\"\n        test_message = \"Esta \u00e9 uma mensagem de log de teste.\"\n        self.memory.save_to_log(test_message)\n\n        # Verifica se 'open' foi chamado corretamente no arquivo de log em modo de anexa\u00e7\u00e3o ('a')\n        mock_file_open.assert_called_once_with(self.memory.log_file, 'a', encoding='utf-8')\n\n        # Verifica se o m\u00e9todo 'write' foi chamado com a mensagem correta\n        # O 'handle' \u00e9 o valor de retorno de open()\n        handle = mock_file_open()\n        # Assumimos que a fun\u00e7\u00e3o adiciona uma nova linha ao final da mensagem\n        handle.write.assert_called_once_with(f\"{test_message}\\n\")\n\nif __name__ == '__main__':\n    unittest.main()\n"
  }
]
2025-07-03 19:56:51,784 - HephaestusAgent - INFO - 
Solicitando decisão do MaestroAgent...
2025-07-03 19:56:51,784 - HephaestusAgent.MaestroAgent - INFO - MaestroAgent: Tentando decisão com os modelos: {'_target_': 'builtins.dict', 'temperature': 0.3, 'max_tokens': -1, 'primary': 'gemini/gemini-2.5-pro', 'fallback': 'deepseek/deepseek-r1-0528:free'}...
2025-07-03 19:56:51,784 - HephaestusAgent.MaestroAgent - DEBUG - MaestroAgent: Prompt for decision:

[IDENTITY]
You are the Maestro of the Hephaestus agent. Your task is to analyze the Engineer's proposal (patch plan) and recent history to decide the best course of action.

[CONTEXT AND HISTORY]

[HISTÓRICO RECENTE (OBJETIVOS E ESTRATÉGIAS USADAS)]
Completed Objectives (most recent first):
- Objective: Com base no sucesso da criação do arquivo `tests/agent/test_cycle_runner.py`, o próximo passo incremental é adicionar um teste simples que apenas importa a função `run_cycles` de `agent.cycle_runner`. Este teste (`def test_run_cycles_importable(): from agent.cycle_runner import run_cycles`) validará que a função, com sua altíssima complexidade (CC: 89), pode ser importada sem causar erros de importação ou efeitos colaterais, estabelecendo uma base mais sólida para futuros testes de lógica e refatoração.
  Strategy: CREATE_NEW_TEST_FILE_STRATEGY
  Outcome: Strategy 'CREATE_NEW_TEST_FILE_STRATEGY' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T22:29:08.784181+00:00
- Objective: Dadas as falhas consecutivas ao tentar testar e refatorar a função `run_cycles` (CC: 89), o próximo passo deve ser mais incremental para garantir sucesso. Crie o arquivo de teste `tests/agent/test_cycle_runner.py` contendo apenas um "smoke test" (ex: `def test_placeholder(): assert True`) para validar que o ambiente de teste para este módulo crítico está funcionando e que o pytest executa com sucesso (exit code 0), estabelecendo assim uma base estável para futuros testes de lógica.
  Strategy: CREATE_NEW_TEST_FILE_STRATEGY
  Outcome: Strategy 'CREATE_NEW_TEST_FILE_STRATEGY' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T22:27:49.062600+00:00

Failed Objectives (most recent first):
- Objective: Dado o sucesso em criar o arquivo de teste para `cycle_runner`, o próximo passo é adicionar um teste de caracterização para a função `run_cycles` (CC: 89). Este teste deve usar `unittest.mock` para simular as dependências essenciais (como `AgentState` e `QueueManager`) e invocar a função, validando que ela pode ser executada em um cenário controlado sem erros, estabelecendo assim a base para testes de lógica mais detalhados e refatoração segura.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_qyaqjai0)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:41:06.299306+00:00
- Objective: Para iniciar a refatoração da função `run_cycles` (CC: 89), que é a mais complexa do projeto, extraia a lógica de inicialização do ciclo (criação do `AgentState` e logs iniciais) para uma nova função auxiliar privada dentro de `agent/cycle_runner.py`. Em seguida, adicione um teste unitário no arquivo `tests/agent/test_cycle_runner.py` que valide especificamente o comportamento desta nova função extraída, garantindo um progresso incremental e seguro.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_v22kn3j2)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:31:44.352659+00:00
Considere esse histórico em sua decisão. Evite repetir estratégias que falharam recentemente para objetivos semelhantes.


[ENGINEER'S PROPOSAL (PATCH PLAN)]
{
  "analysis": "O objetivo é criar um arquivo de teste para a classe `Memory` e, especificamente, para o método `save_to_log`. Esta ação serve como um exercício de capacitação para o agente aprender a usar mocks, uma habilidade necessária que foi identificada como ausente em tentativas de teste anteriores. O plano cria o novo arquivo de teste `tests/agent/test_memory.py`. Este arquivo conterá uma classe de teste `TestMemory` com um método `test_save_to_log_writes_to_file`. Este teste utilizará `unittest.mock.patch` para simular a função `builtins.open`, isolando o teste da interação real com o sistema de arquivos e focando na validação da lógica interna do método `save_to_log`.",
  "patches_to_apply": [
    {
      "file_path": "tests/agent/test_memory.py",
      "operation": "REPLACE",
      "block_to_replace": null,
      "content": "import unittest\nfrom unittest.mock import patch, mock_open\nimport logging\nfrom agent.memory import Memory\n\n# Desabilitar logs durante os testes para manter a saída limpa\nlogging.disable(logging.CRITICAL)\n\nclass TestMemory(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Configura uma nova instância de Memory para cada teste.\"\"\"\n        # Inicializamos Memory com caminhos fictícios, pois as operações de arquivo serão mockadas.\n        self.memory = Memory(log_file='dummy_log.txt', memory_file='dummy_memory.json')\n\n    @patch(\"builtins.open\", new_callable=mock_open)\n    def test_save_to_log_writes_to_file(self, mock_file_open):\n        \"\"\"\n        Testa se save_to_log abre corretamente o arquivo de log e escreve a mensagem.\n        \"\"\"\n        test_message = \"Esta é uma mensagem de log de teste.\"\n        self.memory.save_to_log(test_message)\n\n        # Verifica se 'open' foi chamado corretamente no arquivo de log em modo de anexação ('a')\n        mock_file_open.assert_called_once_with(self.memory.log_file, 'a', encoding='utf-8')\n\n        # Verifica se o método 'write' foi chamado com a mensagem correta\n        # O 'handle' é o valor de retorno de open()\n        handle = mock_file_open()\n        # Assumimos que a função adiciona uma nova linha ao final da mensagem\n        handle.write.assert_called_once_with(f\"{test_message}\\n\")\n\nif __name__ == '__main__':\n    unittest.main()\n"
    }
  ]
}

[YOUR DECISION]
Based on the proposal and history:
1. If the solution seems reasonable and does not require new capabilities, choose the most appropriate validation strategy.
2. If the solution requires new capabilities that Hephaestus needs to develop, respond with `CAPACITATION_REQUIRED`.

Available Validation Strategies: SYNTAX_ONLY, BENCHMARK_ONLY, SYNTAX_AND_PYTEST, FULL_VALIDATION, DOC_UPDATE_STRATEGY, CONFIG_UPDATE_STRATEGY, DISCARD, TEST_FIX_STRATEGY, CREATE_NEW_TEST_FILE_STRATEGY, AUTO_CORRECTION_STRATEGY
Additional Option: CAPACITATION_REQUIRED

[REQUIRED OUTPUT FORMAT]
Respond ONLY with a JSON object containing the "strategy_key" and the value being ONE of the available strategies OR "CAPACITATION_REQUIRED".
Example: {"strategy_key": "sandbox_pytest_validation"}
Example: {"strategy_key": "CAPACITATION_REQUIRED"}

2025-07-03 19:56:51,784 - HephaestusAgent.MaestroAgent - INFO - Calling primary model: gemini/gemini-2.5-pro
2025-07-03 19:56:51,784 - HephaestusAgent.MaestroAgent - INFO - Attempting to call Gemini API with model: gemini/gemini-2.5-pro
2025-07-03 19:57:06,055 - HephaestusAgent.MaestroAgent - DEBUG - Gemini API Response: ```json
{
  "strategy_key": "CREATE_NEW_TEST_FILE_STRATEGY"
}
```
2025-07-03 19:57:06,055 - HephaestusAgent.MaestroAgent - DEBUG - parse_json_response: Raw response before cleaning: ```json
{
  "strategy_key": "CREATE_NEW_TEST_FILE_STRATEGY"
}
```...
2025-07-03 19:57:06,055 - HephaestusAgent.MaestroAgent - DEBUG - parse_json_response: Extracted JSON content based on braces: {
  "strategy_key": "CREATE_NEW_TEST_FILE_STRATEGY"
}...
2025-07-03 19:57:06,055 - HephaestusAgent.MaestroAgent - DEBUG - parse_json_response: Final cleaned content before parsing: {
  "strategy_key": "CREATE_NEW_TEST_FILE_STRATEGY"
}...
2025-07-03 19:57:06,055 - HephaestusAgent - INFO - Estratégia escolhida pelo MaestroAgent (primary: gemini/gemini-2.5-pro, fallback: deepseek/deepseek-r1-0528:free): CREATE_NEW_TEST_FILE_STRATEGY
2025-07-03 19:57:06,055 - HephaestusAgent - INFO - 
Executing strategy 'CREATE_NEW_TEST_FILE_STRATEGY' with steps: ['validate_syntax', 'run_pytest_new_file', 'PatchApplicatorStep']
2025-07-03 19:57:06,056 - HephaestusAgent - INFO - Created temporary sandbox at: /tmp/hephaestus_sandbox_ubgce8d3
2025-07-03 19:57:06,056 - HephaestusAgent - INFO - Copying project to sandbox: /tmp/hephaestus_sandbox_ubgce8d3...
2025-07-03 19:57:06,071 - HephaestusAgent - INFO - Copy to sandbox complete.
2025-07-03 19:57:06,071 - HephaestusAgent - INFO - --- Validation/Execution Step: validate_syntax ---
2025-07-03 19:57:06,072 - HephaestusAgent - INFO - Starting syntax validation in: /tmp/hephaestus_sandbox_ubgce8d3
2025-07-03 19:57:06,072 - HephaestusAgent - DEBUG - Validating syntax of: /tmp/hephaestus_sandbox_ubgce8d3/tests/agent/test_memory.py
2025-07-03 19:57:06,072 - HephaestusAgent - WARNING - File /tmp/hephaestus_sandbox_ubgce8d3/tests/agent/test_memory.py not found in '/tmp/hephaestus_sandbox_ubgce8d3' for validation.
2025-07-03 19:57:06,072 - HephaestusAgent - INFO - Syntax validation in '/tmp/hephaestus_sandbox_ubgce8d3': SUCCESS.
2025-07-03 19:57:06,072 - HephaestusAgent - INFO - --- Validation/Execution Step: run_pytest_new_file ---
2025-07-03 19:57:06,072 - HephaestusAgent - INFO - Executing PytestNewFileValidator...
2025-07-03 19:57:06,072 - HephaestusAgent - INFO - Test file /tmp/hephaestus_sandbox_ubgce8d3/tests/agent/test_memory.py does not exist. Attempting to write from patch content for validation.
2025-07-03 19:57:06,073 - HephaestusAgent - INFO - Temporarily wrote content of tests/agent/test_memory.py for pytest validation.
2025-07-03 19:57:06,073 - HephaestusAgent - INFO - Running pytest on new file: /tmp/hephaestus_sandbox_ubgce8d3/tests/agent/test_memory.py
2025-07-03 19:57:07,393 - HephaestusAgent - WARNING - Pytest reported failing tests for new file tests/agent/test_memory.py, which is expected for TDD. Treating as success.
STDOUT:
============================= test session starts ==============================
platform linux -- Python 3.11.9, pytest-8.4.1, pluggy-1.6.0
rootdir: /tmp/hephaestus_sandbox_ubgce8d3
configfile: pyproject.toml
plugins: mock-3.14.1, anyio-4.9.0, hydra-core-1.3.2
collected 1 item

tests/agent/test_memory.py F                                             [100%]

=================================== FAILURES ===================================
__________________ TestMemory.test_save_to_log_writes_to_file __________________

self = <test_memory.TestMemory testMethod=test_save_to_log_writes_to_file>

    def setUp(self):
        """Configura uma nova instância de Memory para cada teste."""
        # Inicializamos Memory com caminhos fictícios, pois as operações de arquivo serão mockadas.
>       self.memory = Memory(log_file='dummy_log.txt', memory_file='dummy_memory.json')
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Memory.__init__() got an unexpected keyword argument 'log_file'

tests/agent/test_memory.py:14: TypeError
=========================== short test summary info ============================
FAILED tests/agent/test_memory.py::TestMemory::test_save_to_log_writes_to_file
============================== 1 failed in 0.67s ===============================
STDERR:

2025-07-03 19:57:07,393 - HephaestusAgent - INFO - --- Validation/Execution Step: PatchApplicatorStep ---
2025-07-03 19:57:07,393 - HephaestusAgent - INFO - Applying 1 patches in '/tmp/hephaestus_sandbox_ubgce8d3'...
2025-07-03 19:57:07,393 - HephaestusAgent - INFO - Aplicando patches com base_path: '/tmp/hephaestus_sandbox_ubgce8d3'
2025-07-03 19:57:07,393 - HephaestusAgent - INFO - Processando patch 1/1: REPLACE em '/tmp/hephaestus_sandbox_ubgce8d3/tests/agent/test_memory.py'
2025-07-03 19:57:07,393 - HephaestusAgent - INFO - REPLACE sem 'block_to_replace' para '/tmp/hephaestus_sandbox_ubgce8d3/tests/agent/test_memory.py'. Arquivo será sobrescrito.
2025-07-03 19:57:07,393 - HephaestusAgent - INFO - Arquivo '/tmp/hephaestus_sandbox_ubgce8d3/tests/agent/test_memory.py' salvo após operação 'REPLACE'.
2025-07-03 19:57:07,393 - HephaestusAgent - INFO - Todas as 1 instruções de patch processadas. Arquivos afetados (tentativas): {'/tmp/hephaestus_sandbox_ubgce8d3/tests/agent/test_memory.py'}
2025-07-03 19:57:07,393 - HephaestusAgent - INFO - Patches applied successfully in '/tmp/hephaestus_sandbox_ubgce8d3'.
2025-07-03 19:57:07,393 - HephaestusAgent - INFO - Cleaning up temporary sandbox: /tmp/hephaestus_sandbox_ubgce8d3
2025-07-03 19:57:07,395 - HephaestusAgent - INFO - Sandbox cleaned.
2025-07-03 19:57:07,395 - HephaestusAgent - INFO - 
SUCESSO NA VALIDAÇÃO/APLICAÇÃO! Razão: VALIDATION_SUCCESS_NO_CHANGES
2025-07-03 19:57:07,395 - HephaestusAgent - INFO - Ciclo concluído com status: VALIDATION_SUCCESS_NO_CHANGES. Nenhuma alteração no código foi promovida. Gerando próximo objetivo evolutivo...
2025-07-03 19:57:07,396 - HephaestusAgent - INFO - Generating next objective...
2025-07-03 19:57:07,396 - HephaestusAgent - INFO - CAPABILITIES.md lido com sucesso.
2025-07-03 19:57:07,396 - HephaestusAgent - INFO - ROADMAP.md lido com sucesso.
2025-07-03 19:57:07,396 - HephaestusAgent - INFO - Analyzing code metrics in: .
2025-07-03 19:57:07,676 - HephaestusAgent - DEBUG - Code analysis summary:
Large Files (potential candidates for modularization):
  - agent/brain.py (LOC: 357)
  - agent/code_metrics.py (LOC: 362)
  - agent/hephaestus_agent.py (LOC: 369)
  - agent/patch_applicator.py (LOC: 697)
  - agent/cycle_runner.py (LOC: 485)
  - agent/project_scanner.py (LOC: 462)

Large Functions (potential candidates for refactoring/splitting):
  - agent/brain.py -> generate_next_objective() (LOC: 162)
  - agent/brain.py -> generate_capacitation_objective() (LOC: 59)
  - agent/brain.py -> generate_commit_message() (LOC: 98)
  - agent/code_metrics.py -> analyze_complexity() (LOC: 84)
  - agent/code_metrics.py -> calculate_quality_score() (LOC: 89)
  - agent/code_metrics.py -> detect_code_duplication() (LOC: 126)
  - agent/git_utils.py -> initialize_git_repository() (LOC: 208)
  - agent/patch_applicator.py -> _handle_replace() (LOC: 71)
  - agent/patch_applicator.py -> _handle_delete_block() (LOC: 78)
  - agent/patch_applicator.py -> apply_patches() (LOC: 285)
  - agent/cycle_runner.py -> run_cycles() (LOC: 460)
  - agent/prompt_builder.py -> build_meta_analysis_objective_prompt() (LOC: 62)
  - agent/prompt_builder.py -> build_standard_objective_prompt() (LOC: 100)
  - agent/project_scanner.py -> update_project_manifest() (LOC: 188)
  - agent/project_scanner.py -> analyze_code_metrics() (LOC: 208)
  - agent/config_loader.py -> load_config() (LOC: 53)
  - agent/utils/json_parser.py -> parse_json_response() (LOC: 75)

Complex Functions (high CC, potential candidates for refactoring/simplification):
  - agent/brain.py -> generate_next_objective() (CC: 43)
  - agent/brain.py -> generate_commit_message() (CC: 15)
  - agent/code_metrics.py -> analyze_complexity() (CC: 15)
  - agent/code_metrics.py -> calculate_quality_score() (CC: 23)
  - agent/code_metrics.py -> detect_code_duplication() (CC: 20)
  - agent/git_utils.py -> initialize_git_repository() (CC: 14)
  - agent/patch_applicator.py -> _handle_replace() (CC: 15)
  - agent/patch_applicator.py -> _handle_delete_block() (CC: 21)
  - agent/patch_applicator.py -> apply_patches() (CC: 65)
  - agent/cycle_runner.py -> run_cycles() (CC: 89)
  - agent/project_scanner.py -> update_project_manifest() (CC: 45)
  - agent/project_scanner.py -> analyze_code_metrics() (CC: 47)
  - agent/utils/json_parser.py -> parse_json_response() (CC: 25)

Modules without Corresponding Test Files (consider creating tests):
  - cli.py
  - app.py
  - run_agent.py
  - agent/brain.py
  - agent/code_metrics.py
  - agent/hephaestus_agent.py
  - agent/git_utils.py
  - agent/code_validator.py
  - agent/patch_applicator.py
  - agent/cycle_runner.py
  - agent/memory.py
  - agent/prompt_builder.py
  - agent/tool_executor.py
  - agent/project_scanner.py
  - agent/state.py
  - agent/config_loader.py
  - agent/validation_steps/pytest_validator.py
  - agent/validation_steps/__init__.py
  - agent/validation_steps/base.py
  - agent/validation_steps/patch_applicator.py
  - agent/validation_steps/syntax_validator.py
  - agent/validation_steps/pytest_new_file_validator.py
  - agent/agents/architect_agent.py
  - agent/agents/performance_analyzer.py
  - agent/agents/error_correction.py
  - agent/agents/maestro_agent.py
  - agent/agents/error_analyzer.py
  - agent/utils/json_parser.py
  - agent/utils/llm_client.py
2025-07-03 19:57:07,676 - HephaestusAgent - INFO - Analyzing performance log...
2025-07-03 19:57:07,683 - HephaestusAgent - DEBUG - Performance analysis summary:
Performance Summary:
- Total Cycles: 5
- Successful Cycles: 2
- Failed Cycles: 3
- Success Rate: 40.00%
- Average Cycle Duration: N/A

Performance by Strategy (sorted by failures):
- Strategy 'SYNTAX_AND_PYTEST': Success Rate: 0.00% (Failures: 3/3)
- Strategy 'CREATE_NEW_TEST_FILE_STRATEGY': Success Rate: 100.00% (Failures: 0/2)

2025-07-03 19:57:07,683 - HephaestusAgent - DEBUG - Prompt for generate_next_objective:

[Main Context]
You are the 'Planejador Estratégico Avançado' do agente autônomo Hephaestus. Sua principal responsabilidade é identificar e propor o próximo objetivo de desenvolvimento mais impactante para a evolução do agente ou do projeto em análise.

[Decision Process for the Next Objective]
1.  **Analyze Performance:** Review the `[PERFORMANCE ANALYSIS]` section.
2.  **Analyze Code Metrics:** Review the `[CODE METRICS AND ANALYSIS]` section.
3.  **Consider Strategic Documents:** Review `[CAPABILITIES DOCUMENT]` and `[ROADMAP DOCUMENT]` to understand current capabilities, desired future states, and strategic direction. Identify gaps or next steps.
4.  **Consider the Project Manifest:** If the `[CURRENT PROJECT MANIFEST]` is provided, use it for context.
5.  **Review Recent History:** The `[HISTÓRICO RECENTE DO PROJETO E DO AGENTE]` section provides context.
6.  **Prioritize RSI:** Focus on objectives that enhance the agent's ability to self-improve, improve its core logic, prompts, or strategies.
7.  **Prioritize Capabilities & Roadmap:** Generate objectives that fill gaps in `[CAPABILITIES DOCUMENT]` or advance items in `[ROADMAP DOCUMENT]`.
8.  **Prioritize Structural and Quality Improvements:** Based on metrics and strategic documents.
9.  **Be Specific and Actionable:** The objective should be clear, concise, and indicate a concrete action.

1.  **Analyze Performance:** Review the `[PERFORMANCE ANALYSIS]` section to understand the agent's overall success rate and identify trends, especially focusing on strategies with high failure rates.
2.  **Analyze Code Metrics:** Review the `[CODE METRICS AND ANALYSIS]` section below. It contains data on file size (LOC), function size (LOC), cyclomatic complexity (CC) of functions, and modules that may be missing tests.
3.  **Consider the Project Manifest:** If the `[CURRENT PROJECT MANIFEST]` is provided, use it to understand the overall goals, architecture, and areas already documented or needing attention.
4.  **Review Recent History:** The `[HISTÓRICO RECENTE DO PROJETO E DO AGENTE]` section provides context on recent tasks, successes, and failures. Avoid repeating objectives that recently failed in the same way, unless the cause of failure has been resolved. Use history to build on successes.
5.  **Prioritize Structural and Quality Improvements:** Based on metrics, identify opportunities to:
    *   Refactor very large modules or very long/complex functions.
    *   Create tests for critical/complex modules or functions that lack them.
    *   Improve documentation (docstrings, manifest) where crucial.
    *   Propose the creation of new capabilities (new agents, tools) if the analysis indicates a strategic need.
6.  **Prioritize Prompt and Strategy Optimization (RSI Focus):** If the performance analysis reveals strategies with consistently low success rates, consider objectives to:
    *   Refine the prompts used by agents (e.g., Architect, Maestro, ErrorAnalysis) for those failing strategies.
    *   Propose new or modified validation strategies in `hephaestus_config.json` to address specific failure patterns.
7.  **Be Specific and Actionable:** The objective should be clear, concise, and indicate a concrete action.


[HISTÓRICO RECENTE DO PROJETO E DO AGENTE]
Completed Objectives (most recent first):
- Objective: Dado que as tentativas de testar a função `run_cycles` (CC: 89) com mocks falharam, indicando uma lacuna na capacidade de teste do agente, o próximo passo deve ser um objetivo de capacitação focado. Crie o arquivo de teste `tests/agent/test_memory.py` e adicione um teste unitário para uma função simples de escrita, como `save_to_log`. Este teste deve usar `unittest.mock.patch` para simular a interação com o sistema de arquivos (ex: `builtins.open`), validando a lógica da função de forma isolada e ensinando o agente a aplicar mocks com sucesso antes de tentar novamente em alvos mais complexos.
  Strategy: CREATE_NEW_TEST_FILE_STRATEGY
  Outcome: Strategy 'CREATE_NEW_TEST_FILE_STRATEGY' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T22:57:07.396027+00:00
- Objective: Com base no sucesso da criação do arquivo `tests/agent/test_cycle_runner.py`, o próximo passo incremental é adicionar um teste simples que apenas importa a função `run_cycles` de `agent.cycle_runner`. Este teste (`def test_run_cycles_importable(): from agent.cycle_runner import run_cycles`) validará que a função, com sua altíssima complexidade (CC: 89), pode ser importada sem causar erros de importação ou efeitos colaterais, estabelecendo uma base mais sólida para futuros testes de lógica e refatoração.
  Strategy: CREATE_NEW_TEST_FILE_STRATEGY
  Outcome: Strategy 'CREATE_NEW_TEST_FILE_STRATEGY' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T22:29:08.784181+00:00

Failed Objectives (most recent first):
- Objective: Dado o sucesso em criar o arquivo de teste para `cycle_runner`, o próximo passo é adicionar um teste de caracterização para a função `run_cycles` (CC: 89). Este teste deve usar `unittest.mock` para simular as dependências essenciais (como `AgentState` e `QueueManager`) e invocar a função, validando que ela pode ser executada em um cenário controlado sem erros, estabelecendo assim a base para testes de lógica mais detalhados e refatoração segura.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_qyaqjai0)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:41:06.299306+00:00
- Objective: Para iniciar a refatoração da função `run_cycles` (CC: 89), que é a mais complexa do projeto, extraia a lógica de inicialização do ciclo (criação do `AgentState` e logs iniciais) para uma nova função auxiliar privada dentro de `agent/cycle_runner.py`. Em seguida, adicione um teste unitário no arquivo `tests/agent/test_cycle_runner.py` que valide especificamente o comportamento desta nova função extraída, garantindo um progresso incremental e seguro.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_v22kn3j2)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:31:44.352659+00:00
Consider this history to avoid repeating failures, build on successes, and identify gaps.


[PERFORMANCE ANALYSIS]
Performance Summary:
- Total Cycles: 5
- Successful Cycles: 2
- Failed Cycles: 3
- Success Rate: 40.00%
- Average Cycle Duration: N/A

Performance by Strategy (sorted by failures):
- Strategy 'SYNTAX_AND_PYTEST': Success Rate: 0.00% (Failures: 3/3)
- Strategy 'CREATE_NEW_TEST_FILE_STRATEGY': Success Rate: 100.00% (Failures: 0/2)


[CODE METRICS AND ANALYSIS]
Large Files (potential candidates for modularization):
  - agent/brain.py (LOC: 357)
  - agent/code_metrics.py (LOC: 362)
  - agent/hephaestus_agent.py (LOC: 369)
  - agent/patch_applicator.py (LOC: 697)
  - agent/cycle_runner.py (LOC: 485)
  - agent/project_scanner.py (LOC: 462)

Large Functions (potential candidates for refactoring/splitting):
  - agent/brain.py -> generate_next_objective() (LOC: 162)
  - agent/brain.py -> generate_capacitation_objective() (LOC: 59)
  - agent/brain.py -> generate_commit_message() (LOC: 98)
  - agent/code_metrics.py -> analyze_complexity() (LOC: 84)
  - agent/code_metrics.py -> calculate_quality_score() (LOC: 89)
  - agent/code_metrics.py -> detect_code_duplication() (LOC: 126)
  - agent/git_utils.py -> initialize_git_repository() (LOC: 208)
  - agent/patch_applicator.py -> _handle_replace() (LOC: 71)
  - agent/patch_applicator.py -> _handle_delete_block() (LOC: 78)
  - agent/patch_applicator.py -> apply_patches() (LOC: 285)
  - agent/cycle_runner.py -> run_cycles() (LOC: 460)
  - agent/prompt_builder.py -> build_meta_analysis_objective_prompt() (LOC: 62)
  - agent/prompt_builder.py -> build_standard_objective_prompt() (LOC: 100)
  - agent/project_scanner.py -> update_project_manifest() (LOC: 188)
  - agent/project_scanner.py -> analyze_code_metrics() (LOC: 208)
  - agent/config_loader.py -> load_config() (LOC: 53)
  - agent/utils/json_parser.py -> parse_json_response() (LOC: 75)

Complex Functions (high CC, potential candidates for refactoring/simplification):
  - agent/brain.py -> generate_next_objective() (CC: 43)
  - agent/brain.py -> generate_commit_message() (CC: 15)
  - agent/code_metrics.py -> analyze_complexity() (CC: 15)
  - agent/code_metrics.py -> calculate_quality_score() (CC: 23)
  - agent/code_metrics.py -> detect_code_duplication() (CC: 20)
  - agent/git_utils.py -> initialize_git_repository() (CC: 14)
  - agent/patch_applicator.py -> _handle_replace() (CC: 15)
  - agent/patch_applicator.py -> _handle_delete_block() (CC: 21)
  - agent/patch_applicator.py -> apply_patches() (CC: 65)
  - agent/cycle_runner.py -> run_cycles() (CC: 89)
  - agent/project_scanner.py -> update_project_manifest() (CC: 45)
  - agent/project_scanner.py -> analyze_code_metrics() (CC: 47)
  - agent/utils/json_parser.py -> parse_json_response() (CC: 25)

Modules without Corresponding Test Files (consider creating tests):
  - cli.py
  - app.py
  - run_agent.py
  - agent/brain.py
  - agent/code_metrics.py
  - agent/hephaestus_agent.py
  - agent/git_utils.py
  - agent/code_validator.py
  - agent/patch_applicator.py
  - agent/cycle_runner.py
  - agent/memory.py
  - agent/prompt_builder.py
  - agent/tool_executor.py
  - agent/project_scanner.py
  - agent/state.py
  - agent/config_loader.py
  - agent/validation_steps/pytest_validator.py
  - agent/validation_steps/__init__.py
  - agent/validation_steps/base.py
  - agent/validation_steps/patch_applicator.py
  - agent/validation_steps/syntax_validator.py
  - agent/validation_steps/pytest_new_file_validator.py
  - agent/agents/architect_agent.py
  - agent/agents/performance_analyzer.py
  - agent/agents/error_correction.py
  - agent/agents/maestro_agent.py
  - agent/agents/error_analyzer.py
  - agent/utils/json_parser.py
  - agent/utils/llm_client.py

[CAPABILITIES DOCUMENT (CAPABILITIES.md)]
# Manifesto de Capacidades do Hephaestus

Este documento descreve as capacidades atuais e desejadas do agente Hephaestus, servindo como um guia para o seu desenvolvimento e para a geração de objetivos estratégicos. O foco principal é o **Aprimoramento Auto Recursivo (RSI)**, onde o agente busca ativamente melhorar suas próprias funções e arquitetura.

---

## 1. Capacidades Atuais

### 1.1. Análise e Planejamento
- **Geração de Objetivos (`agent/brain.py`):**
  - Analisa métricas de código estático (complexidade, tamanho do arquivo/função, cobertura de testes).
  - Analisa o manifesto do projeto (`AGENTS.md`).
  - Gera um objetivo de desenvolvimento com base na análise.
  - **Agora considera a análise de performance (`evolution_log.csv`) para otimizar prompts e estratégias.**
- **Análise de Erros (`agent/agents/error_analyzer.py`):**
  - Classifica falhas (ex: erro de sintaxe, falha de teste).
  - Propõe um prompt de correção para o `ArchitectAgent`.
  - **Pode sugerir objetivos de meta-análise para questionar o objetivo ou a estratégia original.**
- **Planejamento de Patches (`agent/agents/architect_agent.py`):**
  - Recebe um objetivo e o manifesto do projeto.
  - Gera um plano de patches em formato JSON para modificar a base de código.
- **Seleção de Estratégia (`agent/agents/maestro_agent.py`):**
  - Analisa o plano de patches.
  - Escolhe uma estratégia de validação apropriada (ex: apenas sintaxe, sintaxe e testes).

### 1.2. Execução e Validação
- **Aplicação de Patches (`agent/patch_applicator.py`):**
  - Aplica as modificações de código propostas em um ambiente de sandbox.
- **Validação de Sintaxe (`agent/validation_steps/syntax_validator.py`):**
  - Verifica a sintaxe de arquivos Python e JSON.
- **Execução de Testes (`agent/validation_steps/pytest_validator.py`):**
  - Executa a suíte de testes `pytest` para validar as alterações.
- **Gerenciamento de Estado e Ciclo (`agent/state.py`, `agent/cycle_runner.py`):**
  - Orquestra o fluxo completo de um ciclo de evolução.
  - Mantém o estado do ciclo atual (objetivo, patches, resultado da validação).
  - **O `cycle_runner.py` agora interage com um `QueueManager` para processar objetivos de forma assíncrona.**

### 1.3. Memória e Versionamento
- **Memória Persistente (`agent/memory.py`):**
  - Registra o histórico de objetivos bem-sucedidos e falhos.
  - Fornece contexto histórico para as decisões dos agentes.
- **Versionamento com Git (`agent/git_utils.py`):**
  - Inicializa o repositório Git.
  - Realiza commits automáticos após a validação bem-sucedida das alterações.

### 1.4. Infraestrutura (Nova)
- **Servidor FastAPI (`app.py`):**
  - Executa o Hephaestus como um serviço em segundo plano.
  - Expõe endpoints para submissão de objetivos e verificação de status.
  - Gerencia um thread worker para processar objetivos da fila.
- **Gerenciamento de Fila (`agent/queue_manager.py`):**
  - Permite a comunicação assíncrona de objetivos entre o servidor e o worker do agente.
- **Carregamento de Configuração (`agent/config_loader.py`):**
  - Módulo dedicado para carregar a configuração do agente de forma centralizada.

---

## 2. Capacidades Desejadas (Roadmap RSI)

O desenvolvimento futuro deve focar em aprimorar a capacidade do agente de entender e melhorar a si mesmo.

### 2.1. Meta-Cognição e Análise de Performance
- **Análise de Performance do Agente:**
  - **Objetivo:** Desenvolver a capacidade de analisar o próprio log de evolução (`evolution_log.csv`) para identificar gargalos, estratégias ineficazes e padrões de falha.
  - **Status:** Implementado. O `PerformanceAnalysisAgent` agora fornece uma análise detalhada do `evolution_log.csv`, incluindo taxa de sucesso geral, taxa de sucesso por estratégia e tempo médio de ciclo. O `generate_next_objective` utiliza essa análise para informar a geração de objetivos.
- **Análise de Causa Raiz (Meta-Análise):**
  - **Objetivo:** Aprimorar o `ErrorAnalysisAgent` para que, diante de falhas repetidas, ele possa questionar a validade do objetivo ou da estratégia, em vez de apenas tentar corrigir o código.
  - **Status:** Iniciado. O `ErrorAnalysisAgent` agora pode sugerir objetivos de meta-análise, e o `generate_next_objective` em `agent/brain.py` foi aprimorado para detectar e processar esses objetivos, gerando um novo objetivo estratégico para abordar a causa raiz da falha.

### 2.2. Aprimoramento da Arquitetura e Estratégia
- **Estratégias de Validação Dinâmicas:**
  - **Objetivo:** Permitir que o `MaestroAgent` não apenas escolha, mas também proponha a criação de novas estratégias de validação com base no contexto da tarefa.
  - **Status:** Iniciado. O `generate_next_objective` agora inclui a otimização de prompts e estratégias como uma prioridade, permitindo que o agente proponha modificações em `hephaestus_config.json` ou refinamento de prompts existentes com base na análise de performance.
- **Refatoração Orientada a Capacidades:**
  - **Objetivo:** Garantir que os objetivos de refatoração estejam sempre ligados a um aprimoramento de capacidade, e não apenas à melhoria de métricas de código.
  - **Status:** Não iniciado. (A base para isso foi estabelecida com a meta-análise e otimização de prompts, mas a refatoração explícita orientada a capacidades ainda não foi implementada).

### 2.3. Expansão de Ferramentas
- **Auto-Aprimoramento de Ferramentas:**
  - **Objetivo:** Dar ao agente a capacidade de modificar e aprimorar suas próprias ferramentas (ex: `tool_executor.py`) quando uma tarefa falha devido a uma limitação da ferramenta.
  - **Status:** Não iniciado. (A meta-análise de falhas pode identificar a necessidade de aprimoramento de ferramentas, mas a implementação autônoma ainda não está presente).

- **Acesso e Raciocínio com Conhecimento Externo:**
  - **Objetivo:** Implementar uma ferramenta de busca na web (`web_search`) robusta, permitindo que o agente pesquise documentação de APIs, soluções para erros e novas bibliotecas para resolver problemas que estão além de seu conhecimento atual.
  - **Status:** Não iniciado.

- **Gerenciamento de Estratégias Dinâmicas:**
  - **Objetivo:** O `MaestroAgent` deve evoluir de um simples selecionador de estratégias para um arquiteto de estratégias. Ele deve ser capaz de propor, e até mesmo codificar, novas estratégias de validação em `hephaestus_config.json` com base nos requisitos de um objetivo.
  - **Status:** Iniciado. O `generate_next_objective` agora inclui a otimização de prompts e estratégias como uma prioridade, permitindo que o agente proponha modificações em `hephaestus_config.json` ou refinamento de prompts existentes com base na análise de performance.


[ROADMAP DOCUMENT (ROADMAP.md)]
# Roadmap de Evolução do Hephaestus

Este documento delineia a visão de alto nível para a evolução do Hephaestus como um agente de **Aprimoramento Auto Recursivo (RSI)**. Ele serve como um guia estratégico, enquanto o `CAPABILITIES.md` detalha os passos táticos.

---

## Fase 1: Consciência e Correção (Curto Prazo)

O foco desta fase é fazer com que o agente pare de executar tarefas cegamente e comece a entender seu próprio desempenho e a corrigir suas falhas de forma mais inteligente.

-   [x] **1. Análise de Performance:**
    -   **Visão:** O agente deve ser capaz de ler seu próprio log de performance (`evolution_log.csv`) e responder a perguntas como: "Qual é a minha taxa de sucesso?", "Quais estratégias falham mais?" e "Onde estou gastando mais tempo?".
    -   **Status:** Implementado. O `PerformanceAnalysisAgent` agora fornece uma análise detalhada do `evolution_log.csv`, incluindo taxa de sucesso geral, taxa de sucesso por estratégia e tempo médio de ciclo. O `generate_next_objective` utiliza essa análise para informar a geração de objetivos.

-   [x] **2. Meta-Análise de Falhas:**
    -   **Visão:** Quando uma tarefa falha repetidamente, o agente deve parar de tentar corrigir o código e, em vez disso, questionar o objetivo em si. Ele deve ser capaz de concluir: "Esta abordagem não está funcionando, preciso de uma nova estratégia ou de uma nova ferramenta".
    -   **Status:** Iniciado. O `ErrorAnalysisAgent` agora pode sugerir objetivos de meta-análise, e o `generate_next_objective` em `agent/brain.py` foi aprimorado para detectar e processar esses objetivos, gerando um novo objetivo estratégico para abordar a causa raiz da falha.

-   [ ] **3. Refatoração Orientada a Capacidades:**
    -   **Visão:** O agente só deve propor refatorações de código se elas estiverem diretamente ligadas a um objetivo de capacitação, como "preciso refatorar este módulo para conseguir implementar uma nova ferramenta de análise".
    -   **Status:** Não iniciado. (A base para isso foi estabelecida com a meta-análise e otimização de prompts, mas a refatoração explícita orientada a capacidades ainda não foi implementada).

---

## Fase 2: Expansão de Habilidades (Médio Prazo)

Com a consciência básica estabelecida, o foco se volta para a expansão proativa de suas próprias habilidades e ferramentas.

-   [ ] **1. Auto-Aprimoramento de Ferramentas:**
    -   **Visão:** O agente deve ser capaz de modificar suas próprias ferramentas (`tool_executor.py`, `validation_steps/`, etc.) quando encontrar uma limitação. Se uma validação é muito fraca ou uma ferramenta não tem um parâmetro necessário, ele deve ser capaz de adicioná-lo.
    -   **Status:** Não iniciado. (A meta-análise de falhas pode identificar a necessidade de aprimoramento de ferramentas, mas a implementação autônoma ainda não está presente).

-   [ ] **2. Acesso e Raciocínio com Conhecimento Externo:**
    -   **Visão:** Implementar uma ferramenta de busca na web (`web_search`) robusta, permitindo que o agente pesquise documentação de APIs, soluções para erros e novas bibliotecas para resolver problemas que estão além de seu conhecimento atual.
    -   **Status:** Não iniciado.

-   [x] **3. Gerenciamento de Estratégias Dinâmicas:**
    -   **Visão:** O `MaestroAgent` deve evoluir de um simples selecionador de estratégias para um arquiteto de estratégias. Ele deve ser capaz de propor, e até mesmo codificar, novas estratégias de validação em `hephaestus_config.json` com base nos requisitos de um objetivo.
    -   **Status:** Iniciado. O `generate_next_objective` agora inclui a otimização de prompts e estratégias como uma prioridade, permitindo que o agente proponha modificações em `hephaestus_config.json` ou refinamento de prompts existentes com base na análise de performance.

---

## Fase 3: Autonomia Estratégica (Longo Prazo)

Nesta fase, o agente transcende a execução de ciclos e começa a gerenciar seu próprio desenvolvimento de forma estratégica.

-   [ ] **1. Planejamento de Longo Prazo:**
    -   **Visão:** O agente deve ser capaz de analisar este próprio `ROADMAP.md` e o `CAPABILITIES.md` para gerar um plano de desenvolvimento de múltiplos passos para si mesmo, em vez de operar em um ciclo de objetivo único.
    -   **Status:** Não iniciado.

-   [ ] **2. Auto-Otimização de Modelos:**
    -   **Visão:** Capturar os prompts e as respostas de maior sucesso para criar conjuntos de dados de fine-tuning. O objetivo final é treinar versões especializadas dos modelos de LLM que sejam mais eficientes e precisas para as tarefas do Hephaestus.
    -   **Status:** Não iniciado.

-   [ ] **3. Arquitetura de Agentes Dinâmica:**
    -   **Visão:** O agente deve ser capaz de propor e implementar mudanças em sua própria arquitetura de agentes, como criar um novo agente especializado (ex: `DocumentationAgent`) ou dividir as responsabilidades de um agente existente, para melhorar a eficiência do sistema.
    -   **Status:** Não iniciado.

---

## Arquitetura de Servidor (Novo)

-   [x] **1. Transformação em Servidor FastAPI:**
    -   **Visão:** O Hephaestus opera como um servidor em segundo plano, permitindo a submissão assíncrona de objetivos e monitoramento de status via API.
    -   **Status:** Implementado. O `main.py` agora inicia um servidor FastAPI, e o agente é executado em um thread worker separado, utilizando um `QueueManager` para gerenciar os objetivos.



[CURRENT PROJECT MANIFEST (if existing)]
# MANIFESTO DO PROJETO HEPHAESTUS

## 1. ESTRUTURA DE ARQUIVOS (OTIMIZADA)
agente_autonomo/
    README.md
    hephaestus.log
    cli.py
    AGENTS.md
    poetry.lock
    CONTRIBUTING.md
    app.py
    HEPHAESTUS_MEMORY.json
    main.py
    ROADMAP.md
    hephaestus_config.json
    requirements.txt
    run_agent.py
    MANIFESTO.md
    evolution_log.csv
    CODE_OF_CONDUCT.md
    ANALISE_PERFORMANCE_HEPHAESTUS.md
    ISSUES.md
    ANALISE_TECNICA_HEPHAESTUS.md
    Sugestões de Melhoria para o Projeto Agente Autônomo.md
    CAPABILITIES.md
    pyproject.toml
    agent/
        brain.py
        __init__.py
        code_metrics.py
        hephaestus_agent.py
        git_utils.py
        code_validator.py
        patch_applicator.py
        cycle_runner.py
        memory.py
        prompt_builder.py
        tool_executor.py
        project_scanner.py
        queue_manager.py
        state.py
        config_loader.py
        validation_steps/
            pytest_validator.py
            __init__.py
            base.py
            patch_applicator.py
            syntax_validator.py
            pytest_new_file_validator.py
        agents/
            __init__.py
            architect_agent.py
            performance_analyzer.py
            error_correction.py
            maestro_agent.py
            error_analyzer.py
        utils/
            __init__.py
            json_parser.py
            llm_client.py
    config/
        example_config.yaml
        base_config.yaml
        default.yaml
        models/
            main.yaml
        validation_strategies/
            main.yaml

## 2. RESUMO DAS INTERFACES (APIs Internas)

### Arquivo: `cli.py`
- **Função:** `run(continuous: bool=typer.Option(False, '--continuous', '-c', help='Run in continuous mode'), max_cycles: int=typer.Option(None, '--max-cycles', '-m', help='Maximum number of evolution cycles'))`
  - *Run the Hephaestus agent*
- **Função:** `submit(objective: str)`
  - *Submit a new objective to the agent*
- **Função:** `status()`
  - *Check agent status*

### Arquivo: `app.py`
- **Classe:** `Objective(BaseModel)`
- **Função:** `startup_event()`
- **Função:** `submit_objective(obj: Objective)`
- **Função:** `get_status()`

### Arquivo: `main.py`

### Arquivo: `run_agent.py`

### Arquivo: `agent/brain.py`
- **Função:** `generate_next_objective(model_config: Dict[str, str], current_manifest: str, logger: logging.Logger, project_root_dir: str, config: Optional[Dict[str, Any]]=None, memory_summary: Optional[str]=None, current_objective: Optional[str]=None)`
  - *Generates the next evolutionary objective using a lightweight model and code analysis.*
- **Função:** `generate_capacitation_objective(model_config: Dict[str, str], engineer_analysis: str, memory_summary: Optional[str]=None, logger: Optional[logging.Logger]=None)`
  - *Generates an objective to create necessary new capabilities.*
- **Função:** `generate_commit_message(model_config: Dict[str, str], analysis_summary: str, objective: str, logger: logging.Logger)`
  - *Generates a concise and informative commit message using an LLM.*

### Arquivo: `agent/__init__.py`

### Arquivo: `agent/code_metrics.py`
- **Função:** `analyze_complexity(code_string: str)`
  - *Analyzes the cyclomatic complexity and other metrics of the given Python code string using Radon.*
- **Função:** `calculate_quality_score(complexity_report: dict, duplication_report: list)`
  - *Calculates a quality score based on complexity, duplication, and other code metrics.*
- **Função:** `_get_code_lines(code_string: str, strip_comments_blanks: bool=True)`
  - *Returns a list of (original_line_number, line_content) tuples.*
- **Função:** `_find_duplicates_for_block(block_to_check: list[str], all_lines: list[tuple[int, str]], start_index: int, min_lines: int)`
  - *Finds occurrences of block_to_check in all_lines, starting after start_index.*
- **Função:** `detect_code_duplication(code_string: str, min_lines: int=4, strip_comments_and_blanks: bool=True)`
  - *Detects duplicated code blocks in the given Python code string.*

### Arquivo: `agent/hephaestus_agent.py`
- **Classe:** `HephaestusAgent`
  - *Classe principal que encapsula a lógica do agente autônomo.*

### Arquivo: `agent/git_utils.py`
- **Função:** `initialize_git_repository(logger: logging.Logger)`
  - *Ensure a git repository exists and is configured.*

### Arquivo: `agent/code_validator.py`
- **Função:** `perform_deep_validation(file_path: Path, logger: logging.Logger)`
  - *Realiza uma análise profunda da qualidade do código Python.*
- **Função:** `validate_python_code(file_path: str | Path, logger: logging.Logger, perform_deep_analysis: bool=True)`
  - *Valida se o código Python em um arquivo é sintaticamente correto e, opcionalmente, realiza uma análise profunda.*
- **Função:** `validate_json_syntax(file_path: str | Path, logger: logging.Logger)`
  - *Valida se um arquivo contém JSON válido.*

### Arquivo: `agent/patch_applicator.py`
- **Função:** `_handle_insert(full_path: Path, lines: list[str], instruction: dict, logger: logging.Logger)`
  - *Apply an INSERT patch and return ``(success, updated_lines)``.*
- **Função:** `_handle_replace(full_path: Path, lines: list[str], instruction: dict, logger: logging.Logger)`
  - *Apply a REPLACE patch.*
- **Função:** `_handle_delete_block(full_path: Path, lines: list[str], instruction: dict, logger: logging.Logger)`
  - *Apply a DELETE_BLOCK patch.*
- **Função:** `apply_patches(instructions: list[dict], logger: logging.Logger, base_path: str='.')`
  - *Aplica uma lista de instruções de patch aos arquivos.*

### Arquivo: `agent/cycle_runner.py`
- **Função:** `run_cycles(agent: 'HephaestusAgent', queue_manager: QueueManager)`
  - *Execute the main evolution loop for the given agent.*

### Arquivo: `agent/memory.py`
- **Classe:** `Memory`
  - *Manages persistent memory for the Hephaestus agent, storing historical data*

### Arquivo: `agent/prompt_builder.py`
- **Função:** `build_memory_context_section(memory_summary: Optional[str])`
  - *Constrói a seção de contexto da memória para os prompts.*
- **Função:** `build_initial_objective_prompt(memory_context_section: str)`
  - *Constrói o prompt para gerar o objetivo inicial quando não há manifesto ou análise de código.*
- **Função:** `build_meta_analysis_objective_prompt(current_objective: str, original_failed_objective: str, error_reason_for_meta: str, performance_summary_str: str, memory_context_section: str, capabilities_content: str, roadmap_content: str)`
  - *Constrói o prompt para gerar um objetivo estratégico após uma meta-análise de falha.*
- **Função:** `build_standard_objective_prompt(memory_context_section: str, performance_summary_str: str, code_analysis_summary_str: str, current_manifest: str, capabilities_content: str, roadmap_content: str)`
  - *Constrói o prompt padrão para gerar o próximo objetivo estratégico.*

### Arquivo: `agent/tool_executor.py`
- **Função:** `run_pytest(test_dir: str='tests/', cwd: str | Path | None=None)`
  - *Executa testes pytest no diretório especificado e retorna resultados.*
- **Função:** `check_file_existence(file_paths: list[str])`
  - *Verifica se todos os arquivos especificados existem.*
- **Função:** `run_in_sandbox(temp_dir_path: str, objective: str)`
  - *Executa o main.py de um diretório isolado monitorando tempo e memória.*
- **Função:** `run_git_command(command: list[str])`
  - *Executa um comando Git e retorna o status e a saída.*
- **Função:** `web_search(query: str)`
  - *Realiza uma pesquisa na web usando a API DuckDuckGo e retorna os resultados.*

### Arquivo: `agent/project_scanner.py`
- **Função:** `_extract_elements(code_string: str)`
- **Função:** `_extract_skeleton(code_string: str)`
- **Função:** `update_project_manifest(root_dir: str, target_files: List[str], output_path: str='AGENTS.md', excluded_dir_patterns: Optional[List[str]]=None)`
- **Função:** `analyze_code_metrics(root_dir: str, excluded_dir_patterns: Optional[List[str]]=None, file_loc_threshold: int=300, func_loc_threshold: int=50, func_cc_threshold: int=10)`
  - *Analisa arquivos Python em um diretório para métricas de código como LOC e Complexidade Ciclomática.*

### Arquivo: `agent/queue_manager.py`
- **Classe:** `QueueManager`

### Arquivo: `agent/state.py`
- **Classe:** `AgentState`
  - *Representa o estado interno do agente Hephaestus durante um ciclo de processamento.*

### Arquivo: `agent/config_loader.py`
- **Função:** `load_config()`
  - *Load configuration using Hydra.*

### Arquivo: `agent/validation_steps/pytest_validator.py`
- **Classe:** `PytestValidator(ValidationStep)`
  - *Runs pytest as a validation step.*

### Arquivo: `agent/validation_steps/__init__.py`
- **Classe:** `BenchmarkValidator(ValidationStep)`
- **Classe:** `CheckFileExistenceValidator(ValidationStep)`
- **Classe:** `ValidateJsonSyntax(ValidationStep)`
- **Função:** `get_validation_step(name: str)`

### Arquivo: `agent/validation_steps/base.py`
- **Classe:** `ValidationStep(ABC)`
  - *Abstract base class for a validation step.*

### Arquivo: `agent/validation_steps/patch_applicator.py`
- **Classe:** `PatchApplicatorStep(ValidationStep)`
  - *Applies patches to the specified base path.*

### Arquivo: `agent/validation_steps/syntax_validator.py`
- **Classe:** `SyntaxValidator(ValidationStep)`
  - *Validates the syntax of Python and JSON files.*

### Arquivo: `agent/validation_steps/pytest_new_file_validator.py`
- **Classe:** `PytestNewFileValidator(ValidationStep)`
  - *A validation step that runs pytest specifically on newly created test files.*

### Arquivo: `agent/agents/__init__.py`

### Arquivo: `agent/agents/architect_agent.py`
- **Classe:** `ArchitectAgent`

### Arquivo: `agent/agents/performance_analyzer.py`
- **Classe:** `PerformanceAnalysisAgent`
  - *An agent dedicated to analyzing the performance of Hephaestus.*

### Arquivo: `agent/agents/error_correction.py`
- **Classe:** `ErrorCorrectionAgent`
  - *Agent for analyzing errors and generating corrective actions.*

### Arquivo: `agent/agents/maestro_agent.py`
- **Classe:** `MaestroAgent`

### Arquivo: `agent/agents/error_analyzer.py`
- **Classe:** `ErrorAnalysisAgent`

### Arquivo: `agent/utils/__init__.py`

### Arquivo: `agent/utils/json_parser.py`
- **Função:** `parse_json_response(raw_str: str, logger: logging.Logger)`
  - *Analisa uma string bruta que se espera conter JSON, limpando-a e decodificando-a.*

### Arquivo: `agent/utils/llm_client.py`
- **Função:** `call_gemini_api(model: str, prompt: str, temperature: float, max_tokens: Optional[int], logger: logging.Logger)`
  - *Calls the Google Gemini API.*
- **Função:** `call_openrouter_api(model: str, prompt: str, temperature: float, max_tokens: Optional[int], logger: logging.Logger)`
  - *Calls a generic OpenAI-compatible API (like OpenRouter).*
- **Função:** `call_llm_with_fallback(model_config: Dict[str, Any], prompt: str, temperature: float, logger: logging.Logger)`
  - *Orchestrates LLM calls with a primary and fallback model.*

## 3. CONTEÚDO COMPLETO DOS ARQUIVOS ALVO


[Examples of Smart and Self-Aware Objectives]
*   **Performance-Based Objectives:**
    *   "The agent's success rate is low. Analyze the `evolution_log.csv` to identify the most common causes of failure and propose a solution."
    *   "Given the high number of failed cycles, implement a more robust error analysis mechanism in `error_analyzer.py`."
*   **Prompt/Strategy Optimization Objectives (RSI Focus):**
    *   "The 'SYNTAX_ONLY' strategy has a high failure rate. Analyze the prompts used by the ArchitectAgent when this strategy is chosen and propose modifications to improve syntax correctness."
    *   "Propose a new validation strategy in `hephaestus_config.json` called 'ADVANCED_LINTING' that includes `ruff` checks before applying patches, to reduce syntax errors."
    *   "Analyze the `MaestroAgent`'s decision-making process for objectives related to documentation updates, as the 'DOC_UPDATE_STRATEGY' has a low success rate. Refine its prompt to improve accuracy."
*   **Metrics-Based Refactoring:**
    *   "Refactor the module `agent/brain.py` (LOC: 350) which is extensive, considering splitting responsibilities into smaller modules (e.g., `agent/prompt_builder.py` or `agent/analysis_processor.py`)."
    *   "The function `generate_next_objective` in `agent/brain.py` (LOC: 85, CC: 12) is long and complex. Propose a plan to refactor it into smaller, more focused functions."
    *   "Analyze the most complex functions (CC > 10) listed in the metrics and select one for refactoring."
*   **Test Creation (Generate New Test Files):**
    *   "The module `agent/project_scanner.py` is missing a test file. Create a new test file `tests/agent/test_project_scanner.py` with basic unit tests for the `analyze_code_metrics` function."
    *   "Module `agent/memory.py` lacks tests. Generate `tests/agent/test_memory.py` and include placeholder tests for its public functions."
    *   "Create unit tests for the module `agent/tool_executor.py` in a new file `tests/agent/test_tool_executor.py`, focusing on the `web_search` function."
    *   "The function `call_llm_api` in `agent/utils/llm_client.py` is critical. Ensure robust unit tests exist for it in `tests/agent/utils/test_llm_client.py`, covering success and failure cases. If the test file doesn't exist, create it."
*   **Test-Driven Development (TDD) Flow:**
    *   "The previous cycle successfully created a new test file `tests/agent/test_new_feature.py` which is now failing as expected. The next objective is to implement the minimal code in `agent/new_feature.py` required to make the tests in `tests/agent/test_new_feature.py` pass."
*   **Strategic Documentation Improvement:**
    *   "The manifest (`AGENTS.md`) does not describe the new metrics analysis functionality in `project_scanner.py`. Update it."
    *   "Improve docstrings for public functions in the `agent/memory.py` module to detail parameters and expected behavior."
*   **Development of New Capabilities (Agents/Tools):**
    *   "Create a new agent (e.g., `CodeQualityAgent` in `agent/agents.py`) dedicated to continuously monitoring code quality metrics and reporting regressions."
    *   "Develop a new tool in `agent/tool_executor.py` to automatically validate the syntax of JSON files before processing."
    *   "Propose a system for Hephaestus to evaluate the performance of its own operations and identify bottlenecks."
*   **Generic Objectives (when metrics/manifest are insufficient):**
    *   "Analyze the `agent/state.py` module to identify potential improvements in clarity or efficiency."
    *   "Review recent logs for frequent errors and propose an objective to fix them."

[Your Task]
Based on ALL the information provided (metrics, manifest, history), generate ONLY a single text string containing the NEXT STRATEGIC OBJECTIVE. The objective should be the most impactful and logical for the project's evolution at this moment.
Be concise, but specific enough to be actionable.

2025-07-03 19:57:07,683 - HephaestusAgent - INFO - Calling primary model: gemini/gemini-2.5-pro
2025-07-03 19:57:07,683 - HephaestusAgent - INFO - Attempting to call Gemini API with model: gemini/gemini-2.5-pro
2025-07-03 19:57:32,907 - HephaestusAgent - DEBUG - Gemini API Response: Dado que as tentativas de testar a função `run_cycles` (CC: 89) falharam repetidamente, a estratégia deve ser pivotar para um alvo crítico e complexo diferente para construir capacidade de teste. Crie o arquivo de teste `tests/agent/test_patch_applicator.py` e adicione um teste unitário inicial para a função auxiliar `_handle_insert`. Este teste deve usar `unittest.mock.patch` para simular as interações com o sistema de arquivos, validando a lógica de inserção de forma isolada e aumentando a cobertura de testes em um módulo vital (`apply_patches` CC: 65) que atualmente não possui testes.
2025-07-03 19:57:32,907 - HephaestusAgent - INFO - Próximo objetivo: Dado que as tentativas de testar a função `run_cycles` (CC: 89) falharam repetidamente, a estratégia deve ser pivotar para um alvo crítico e complexo diferente para construir capacidade de teste. Crie o arquivo de teste `tests/agent/test_patch_applicator.py` e adicione um teste unitário inicial para a função auxiliar `_handle_insert`. Este teste deve usar `unittest.mock.patch` para simular as interações com o sistema de arquivos, validando a lógica de inserção de forma isolada e aumentando a cobertura de testes em um módulo vital (`apply_patches` CC: 65) que atualmente não possui testes.
2025-07-03 19:57:32,908 - HephaestusAgent - INFO - Memória salva em HEPHAESTUS_MEMORY.json (3 completed, 4 failed)
2025-07-03 19:57:32,908 - HephaestusAgent - INFO - ==================== FIM DO CICLO DE EVOLUÇÃO ====================
2025-07-03 19:57:33,908 - HephaestusAgent - INFO - 

==================== INÍCIO DO CICLO DE EVOLUÇÃO (Ciclo #2) ====================
2025-07-03 19:57:33,909 - HephaestusAgent - INFO - OBJETIVO ATUAL: Dado que as tentativas de testar a função `run_cycles` (CC: 89) falharam repetidamente, a estratégia deve ser pivotar para um alvo crítico e complexo diferente para construir capacidade de teste. Crie o arquivo de teste `tests/agent/test_patch_applicator.py` e adicione um teste unitário inicial para a função auxiliar `_handle_insert`. Este teste deve usar `unittest.mock.patch` para simular as interações com o sistema de arquivos, validando a lógica de inserção de forma isolada e aumentando a cobertura de testes em um módulo vital (`apply_patches` CC: 65) que atualmente não possui testes.

2025-07-03 19:57:33,909 - HephaestusAgent - INFO - Gerando manifesto do projeto (AGENTS.md)...
2025-07-03 19:57:33,945 - HephaestusAgent - INFO - --- MANIFESTO GERADO (Tamanho: 11020 caracteres) ---
2025-07-03 19:57:33,945 - HephaestusAgent - INFO - 
Solicitando plano de ação do ArchitectAgent...
2025-07-03 19:57:33,945 - HephaestusAgent.ArchitectAgent - INFO - ArchitectAgent: Gerando plano de patches com os modelos: {'_target_': 'builtins.dict', 'temperature': 0.3, 'max_tokens': -1, 'primary': 'gemini/gemini-2.5-pro', 'fallback': 'deepseek/deepseek-r1-0528:free'}...
2025-07-03 19:57:33,946 - HephaestusAgent.ArchitectAgent - INFO - Calling primary model: gemini/gemini-2.5-pro
2025-07-03 19:57:33,946 - HephaestusAgent.ArchitectAgent - INFO - Attempting to call Gemini API with model: gemini/gemini-2.5-pro
2025-07-03 19:58:16,857 - HephaestusAgent.ArchitectAgent - DEBUG - Gemini API Response: ```json
{
  "analysis": "O objetivo é criar um novo arquivo de teste para o módulo `agent/patch_applicator.py`, que atualmente não possui testes e tem uma complexidade ciclométrica de 65. Esta ação é um pivô estratégico para construir capacidade de teste em um módulo crítico, após falhas na tentativa de testar `run_cycles`. O plano cria o arquivo `tests/agent/test_patch_applicator.py` e adiciona um teste unitário inicial e funcional para a função auxiliar `_handle_insert`. O teste utiliza `unittest.mock.MagicMock` para simular o logger e valida a lógica de inserção de forma isolada, cobrindo tanto um caso de sucesso quanto um de falha. Placeholders para as outras funções do módulo também são adicionados para guiar o desenvolvimento futuro de testes.",
  "patches_to_apply": [
    {
      "file_path": "tests/agent/test_patch_applicator.py",
      "operation": "REPLACE",
      "block_to_replace": null,
      "content": "import unittest\nimport logging\nfrom unittest.mock import MagicMock\nfrom pathlib import Path\n\nfrom agent.patch_applicator import _handle_insert, _handle_replace, _handle_delete_block, apply_patches\n\nclass TestHandleInsert(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up a mock logger and a mock path for all tests.\"\"\"\n        self.mock_logger = MagicMock(spec=logging.Logger)\n        self.mock_path = Path(\"dummy/file.py\")\n\n    def test_handle_insert_success(self):\n        \"\"\"\n        Tests the successful insertion of content into a list of lines.\n        \"\"\"\n        # Arrange\n        initial_lines = [\n            \"line 1\\n\",\n            \"line 2\\n\",\n            \"line 4\\n\",\n        ]\n        instruction = {\n            \"operation\": \"INSERT\",\n            \"line_number\": 3,  # Insert between line 2 and 4\n            \"content\": \"line 3\\n\"\n        }\n        \n        # Act\n        success, updated_lines = _handle_insert(\n            full_path=self.mock_path,\n            lines=initial_lines.copy(),\n            instruction=instruction,\n            logger=self.mock_logger\n        )\n\n        # Assert\n        self.assertTrue(success)\n        expected_lines = [\n            \"line 1\\n\",\n            \"line 2\\n\",\n            \"line 3\\n\",\n            \"line 4\\n\",\n        ]\n        self.assertEqual(updated_lines, expected_lines)\n        self.mock_logger.info.assert_called_once_with(\n            f\"INSERT successful for {self.mock_path} at line {instruction['line_number']}.\"\n        )\n        self.mock_logger.error.assert_not_called()\n\n    def test_handle_insert_invalid_line_number(self):\n        \"\"\"\n        Tests that an insert fails if the line number is out of bounds.\n        \"\"\"\n        # Arrange\n        initial_lines = [\"line 1\\n\"]\n        instruction = {\n            \"operation\": \"INSERT\",\n            \"line_number\": 3,  # Invalid: can only insert at 1 or 2\n            \"content\": \"line X\\n\"\n        }\n\n        # Act\n        success, updated_lines = _handle_insert(\n            full_path=self.mock_path,\n            lines=initial_lines.copy(),\n            instruction=instruction,\n            logger=self.mock_logger\n        )\n\n        # Assert\n        self.assertFalse(success)\n        self.assertEqual(updated_lines, initial_lines)  # Content should be unchanged\n        self.mock_logger.error.assert_called_once_with(\n            f\"Failed to apply INSERT to {self.mock_path}: Line number 3 is out of bounds. File has 1 lines.\"\n        )\n        self.mock_logger.info.assert_not_called()\n\nclass TestOtherPatchFunctions(unittest.TestCase):\n\n    def test_handle_replace_placeholder(self):\n        \"\"\"Placeholder test for _handle_replace.\"\"\"\n        # TODO: Implement test cases for _handle_replace\n        pass\n\n    def test_handle_delete_block_placeholder(self):\n        \"\"\"Placeholder test for _handle_delete_block.\"\"\"\n        # TODO: Implement test cases for _handle_delete_block\n        pass\n\n    def test_apply_patches_placeholder(self):\n        \"\"\"Placeholder test for apply_patches.\"\"\"\n        # TODO: Implement test cases for apply_patches\n        pass\n\nif __name__ == '__main__':\n    unittest.main()\n"
    }
  ]
}
```
2025-07-03 19:58:16,857 - HephaestusAgent.ArchitectAgent - DEBUG - parse_json_response: Raw response before cleaning: ```json
{
  "analysis": "O objetivo é criar um novo arquivo de teste para o módulo `agent/patch_applicator.py`, que atualmente não possui testes e tem uma complexidade ciclométrica de 65. Esta ação é um pivô estratégico para construir capacidade de teste em um módulo crítico, após falhas na tentativ...
2025-07-03 19:58:16,857 - HephaestusAgent.ArchitectAgent - DEBUG - parse_json_response: Extracted JSON content based on braces: {
  "analysis": "O objetivo é criar um novo arquivo de teste para o módulo `agent/patch_applicator.py`, que atualmente não possui testes e tem uma complexidade ciclométrica de 65. Esta ação é um pivô estratégico para construir capacidade de teste em um módulo crítico, após falhas na tentativa de tes...
2025-07-03 19:58:16,858 - HephaestusAgent.ArchitectAgent - DEBUG - parse_json_response: Final cleaned content before parsing: {
  "analysis": "O objetivo é criar um novo arquivo de teste para o módulo `agent/patch_applicator.py`, que atualmente não possui testes e tem uma complexidade ciclométrica de 65. Esta ação é um pivô estratégico para construir capacidade de teste em um módulo crítico, após falhas na tentativa de tes...
2025-07-03 19:58:16,858 - HephaestusAgent - INFO - --- PLANO DE AÇÃO (PATCHES) GERADO PELO ARCHITECTAGENT ({'_target_': 'builtins.dict', 'temperature': 0.3, 'max_tokens': -1, 'primary': 'gemini/gemini-2.5-pro', 'fallback': 'deepseek/deepseek-r1-0528:free'}) ---
2025-07-03 19:58:16,858 - HephaestusAgent - DEBUG - Análise do Arquiteto: O objetivo é criar um novo arquivo de teste para o módulo `agent/patch_applicator.py`, que atualmente não possui testes e tem uma complexidade ciclométrica de 65. Esta ação é um pivô estratégico para construir capacidade de teste em um módulo crítico, após falhas na tentativa de testar `run_cycles`. O plano cria o arquivo `tests/agent/test_patch_applicator.py` e adiciona um teste unitário inicial e funcional para a função auxiliar `_handle_insert`. O teste utiliza `unittest.mock.MagicMock` para simular o logger e valida a lógica de inserção de forma isolada, cobrindo tanto um caso de sucesso quanto um de falha. Placeholders para as outras funções do módulo também são adicionados para guiar o desenvolvimento futuro de testes.
2025-07-03 19:58:16,858 - HephaestusAgent - DEBUG - Patches: [
  {
    "file_path": "tests/agent/test_patch_applicator.py",
    "operation": "REPLACE",
    "block_to_replace": null,
    "content": "import unittest\nimport logging\nfrom unittest.mock import MagicMock\nfrom pathlib import Path\n\nfrom agent.patch_applicator import _handle_insert, _handle_replace, _handle_delete_block, apply_patches\n\nclass TestHandleInsert(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up a mock logger and a mock path for all tests.\"\"\"\n        self.mock_logger = MagicMock(spec=logging.Logger)\n        self.mock_path = Path(\"dummy/file.py\")\n\n    def test_handle_insert_success(self):\n        \"\"\"\n        Tests the successful insertion of content into a list of lines.\n        \"\"\"\n        # Arrange\n        initial_lines = [\n            \"line 1\\n\",\n            \"line 2\\n\",\n            \"line 4\\n\",\n        ]\n        instruction = {\n            \"operation\": \"INSERT\",\n            \"line_number\": 3,  # Insert between line 2 and 4\n            \"content\": \"line 3\\n\"\n        }\n        \n        # Act\n        success, updated_lines = _handle_insert(\n            full_path=self.mock_path,\n            lines=initial_lines.copy(),\n            instruction=instruction,\n            logger=self.mock_logger\n        )\n\n        # Assert\n        self.assertTrue(success)\n        expected_lines = [\n            \"line 1\\n\",\n            \"line 2\\n\",\n            \"line 3\\n\",\n            \"line 4\\n\",\n        ]\n        self.assertEqual(updated_lines, expected_lines)\n        self.mock_logger.info.assert_called_once_with(\n            f\"INSERT successful for {self.mock_path} at line {instruction['line_number']}.\"\n        )\n        self.mock_logger.error.assert_not_called()\n\n    def test_handle_insert_invalid_line_number(self):\n        \"\"\"\n        Tests that an insert fails if the line number is out of bounds.\n        \"\"\"\n        # Arrange\n        initial_lines = [\"line 1\\n\"]\n        instruction = {\n            \"operation\": \"INSERT\",\n            \"line_number\": 3,  # Invalid: can only insert at 1 or 2\n            \"content\": \"line X\\n\"\n        }\n\n        # Act\n        success, updated_lines = _handle_insert(\n            full_path=self.mock_path,\n            lines=initial_lines.copy(),\n            instruction=instruction,\n            logger=self.mock_logger\n        )\n\n        # Assert\n        self.assertFalse(success)\n        self.assertEqual(updated_lines, initial_lines)  # Content should be unchanged\n        self.mock_logger.error.assert_called_once_with(\n            f\"Failed to apply INSERT to {self.mock_path}: Line number 3 is out of bounds. File has 1 lines.\"\n        )\n        self.mock_logger.info.assert_not_called()\n\nclass TestOtherPatchFunctions(unittest.TestCase):\n\n    def test_handle_replace_placeholder(self):\n        \"\"\"Placeholder test for _handle_replace.\"\"\"\n        # TODO: Implement test cases for _handle_replace\n        pass\n\n    def test_handle_delete_block_placeholder(self):\n        \"\"\"Placeholder test for _handle_delete_block.\"\"\"\n        # TODO: Implement test cases for _handle_delete_block\n        pass\n\n    def test_apply_patches_placeholder(self):\n        \"\"\"Placeholder test for apply_patches.\"\"\"\n        # TODO: Implement test cases for apply_patches\n        pass\n\nif __name__ == '__main__':\n    unittest.main()\n"
  }
]
2025-07-03 19:58:16,858 - HephaestusAgent - INFO - 
Solicitando decisão do MaestroAgent...
2025-07-03 19:58:16,859 - HephaestusAgent.MaestroAgent - INFO - MaestroAgent: Tentando decisão com os modelos: {'_target_': 'builtins.dict', 'temperature': 0.3, 'max_tokens': -1, 'primary': 'gemini/gemini-2.5-pro', 'fallback': 'deepseek/deepseek-r1-0528:free'}...
2025-07-03 19:58:16,859 - HephaestusAgent.MaestroAgent - DEBUG - MaestroAgent: Prompt for decision:

[IDENTITY]
You are the Maestro of the Hephaestus agent. Your task is to analyze the Engineer's proposal (patch plan) and recent history to decide the best course of action.

[CONTEXT AND HISTORY]

[HISTÓRICO RECENTE (OBJETIVOS E ESTRATÉGIAS USADAS)]
Completed Objectives (most recent first):
- Objective: Dado que as tentativas de testar a função `run_cycles` (CC: 89) com mocks falharam, indicando uma lacuna na capacidade de teste do agente, o próximo passo deve ser um objetivo de capacitação focado. Crie o arquivo de teste `tests/agent/test_memory.py` e adicione um teste unitário para uma função simples de escrita, como `save_to_log`. Este teste deve usar `unittest.mock.patch` para simular a interação com o sistema de arquivos (ex: `builtins.open`), validando a lógica da função de forma isolada e ensinando o agente a aplicar mocks com sucesso antes de tentar novamente em alvos mais complexos.
  Strategy: CREATE_NEW_TEST_FILE_STRATEGY
  Outcome: Strategy 'CREATE_NEW_TEST_FILE_STRATEGY' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T22:57:07.396027+00:00
- Objective: Com base no sucesso da criação do arquivo `tests/agent/test_cycle_runner.py`, o próximo passo incremental é adicionar um teste simples que apenas importa a função `run_cycles` de `agent.cycle_runner`. Este teste (`def test_run_cycles_importable(): from agent.cycle_runner import run_cycles`) validará que a função, com sua altíssima complexidade (CC: 89), pode ser importada sem causar erros de importação ou efeitos colaterais, estabelecendo uma base mais sólida para futuros testes de lógica e refatoração.
  Strategy: CREATE_NEW_TEST_FILE_STRATEGY
  Outcome: Strategy 'CREATE_NEW_TEST_FILE_STRATEGY' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T22:29:08.784181+00:00

Failed Objectives (most recent first):
- Objective: Dado o sucesso em criar o arquivo de teste para `cycle_runner`, o próximo passo é adicionar um teste de caracterização para a função `run_cycles` (CC: 89). Este teste deve usar `unittest.mock` para simular as dependências essenciais (como `AgentState` e `QueueManager`) e invocar a função, validando que ela pode ser executada em um cenário controlado sem erros, estabelecendo assim a base para testes de lógica mais detalhados e refatoração segura.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_qyaqjai0)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:41:06.299306+00:00
- Objective: Para iniciar a refatoração da função `run_cycles` (CC: 89), que é a mais complexa do projeto, extraia a lógica de inicialização do ciclo (criação do `AgentState` e logs iniciais) para uma nova função auxiliar privada dentro de `agent/cycle_runner.py`. Em seguida, adicione um teste unitário no arquivo `tests/agent/test_cycle_runner.py` que valide especificamente o comportamento desta nova função extraída, garantindo um progresso incremental e seguro.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_v22kn3j2)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:31:44.352659+00:00
Considere esse histórico em sua decisão. Evite repetir estratégias que falharam recentemente para objetivos semelhantes.


[ENGINEER'S PROPOSAL (PATCH PLAN)]
{
  "analysis": "O objetivo é criar um novo arquivo de teste para o módulo `agent/patch_applicator.py`, que atualmente não possui testes e tem uma complexidade ciclométrica de 65. Esta ação é um pivô estratégico para construir capacidade de teste em um módulo crítico, após falhas na tentativa de testar `run_cycles`. O plano cria o arquivo `tests/agent/test_patch_applicator.py` e adiciona um teste unitário inicial e funcional para a função auxiliar `_handle_insert`. O teste utiliza `unittest.mock.MagicMock` para simular o logger e valida a lógica de inserção de forma isolada, cobrindo tanto um caso de sucesso quanto um de falha. Placeholders para as outras funções do módulo também são adicionados para guiar o desenvolvimento futuro de testes.",
  "patches_to_apply": [
    {
      "file_path": "tests/agent/test_patch_applicator.py",
      "operation": "REPLACE",
      "block_to_replace": null,
      "content": "import unittest\nimport logging\nfrom unittest.mock import MagicMock\nfrom pathlib import Path\n\nfrom agent.patch_applicator import _handle_insert, _handle_replace, _handle_delete_block, apply_patches\n\nclass TestHandleInsert(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up a mock logger and a mock path for all tests.\"\"\"\n        self.mock_logger = MagicMock(spec=logging.Logger)\n        self.mock_path = Path(\"dummy/file.py\")\n\n    def test_handle_insert_success(self):\n        \"\"\"\n        Tests the successful insertion of content into a list of lines.\n        \"\"\"\n        # Arrange\n        initial_lines = [\n            \"line 1\\n\",\n            \"line 2\\n\",\n            \"line 4\\n\",\n        ]\n        instruction = {\n            \"operation\": \"INSERT\",\n            \"line_number\": 3,  # Insert between line 2 and 4\n            \"content\": \"line 3\\n\"\n        }\n        \n        # Act\n        success, updated_lines = _handle_insert(\n            full_path=self.mock_path,\n            lines=initial_lines.copy(),\n            instruction=instruction,\n            logger=self.mock_logger\n        )\n\n        # Assert\n        self.assertTrue(success)\n        expected_lines = [\n            \"line 1\\n\",\n            \"line 2\\n\",\n            \"line 3\\n\",\n            \"line 4\\n\",\n        ]\n        self.assertEqual(updated_lines, expected_lines)\n        self.mock_logger.info.assert_called_once_with(\n            f\"INSERT successful for {self.mock_path} at line {instruction['line_number']}.\"\n        )\n        self.mock_logger.error.assert_not_called()\n\n    def test_handle_insert_invalid_line_number(self):\n        \"\"\"\n        Tests that an insert fails if the line number is out of bounds.\n        \"\"\"\n        # Arrange\n        initial_lines = [\"line 1\\n\"]\n        instruction = {\n            \"operation\": \"INSERT\",\n            \"line_number\": 3,  # Invalid: can only insert at 1 or 2\n            \"content\": \"line X\\n\"\n        }\n\n        # Act\n        success, updated_lines = _handle_insert(\n            full_path=self.mock_path,\n            lines=initial_lines.copy(),\n            instruction=instruction,\n            logger=self.mock_logger\n        )\n\n        # Assert\n        self.assertFalse(success)\n        self.assertEqual(updated_lines, initial_lines)  # Content should be unchanged\n        self.mock_logger.error.assert_called_once_with(\n            f\"Failed to apply INSERT to {self.mock_path}: Line number 3 is out of bounds. File has 1 lines.\"\n        )\n        self.mock_logger.info.assert_not_called()\n\nclass TestOtherPatchFunctions(unittest.TestCase):\n\n    def test_handle_replace_placeholder(self):\n        \"\"\"Placeholder test for _handle_replace.\"\"\"\n        # TODO: Implement test cases for _handle_replace\n        pass\n\n    def test_handle_delete_block_placeholder(self):\n        \"\"\"Placeholder test for _handle_delete_block.\"\"\"\n        # TODO: Implement test cases for _handle_delete_block\n        pass\n\n    def test_apply_patches_placeholder(self):\n        \"\"\"Placeholder test for apply_patches.\"\"\"\n        # TODO: Implement test cases for apply_patches\n        pass\n\nif __name__ == '__main__':\n    unittest.main()\n"
    }
  ]
}

[YOUR DECISION]
Based on the proposal and history:
1. If the solution seems reasonable and does not require new capabilities, choose the most appropriate validation strategy.
2. If the solution requires new capabilities that Hephaestus needs to develop, respond with `CAPACITATION_REQUIRED`.

Available Validation Strategies: SYNTAX_ONLY, BENCHMARK_ONLY, SYNTAX_AND_PYTEST, FULL_VALIDATION, DOC_UPDATE_STRATEGY, CONFIG_UPDATE_STRATEGY, DISCARD, TEST_FIX_STRATEGY, CREATE_NEW_TEST_FILE_STRATEGY, AUTO_CORRECTION_STRATEGY
Additional Option: CAPACITATION_REQUIRED

[REQUIRED OUTPUT FORMAT]
Respond ONLY with a JSON object containing the "strategy_key" and the value being ONE of the available strategies OR "CAPACITATION_REQUIRED".
Example: {"strategy_key": "sandbox_pytest_validation"}
Example: {"strategy_key": "CAPACITATION_REQUIRED"}

2025-07-03 19:58:16,859 - HephaestusAgent.MaestroAgent - INFO - Calling primary model: gemini/gemini-2.5-pro
2025-07-03 19:58:16,859 - HephaestusAgent.MaestroAgent - INFO - Attempting to call Gemini API with model: gemini/gemini-2.5-pro
2025-07-03 19:58:31,882 - HephaestusAgent.MaestroAgent - DEBUG - Gemini API Response: ```json
{
  "strategy_key": "CREATE_NEW_TEST_FILE_STRATEGY"
}
```
2025-07-03 19:58:31,883 - HephaestusAgent.MaestroAgent - DEBUG - parse_json_response: Raw response before cleaning: ```json
{
  "strategy_key": "CREATE_NEW_TEST_FILE_STRATEGY"
}
```...
2025-07-03 19:58:31,883 - HephaestusAgent.MaestroAgent - DEBUG - parse_json_response: Extracted JSON content based on braces: {
  "strategy_key": "CREATE_NEW_TEST_FILE_STRATEGY"
}...
2025-07-03 19:58:31,883 - HephaestusAgent.MaestroAgent - DEBUG - parse_json_response: Final cleaned content before parsing: {
  "strategy_key": "CREATE_NEW_TEST_FILE_STRATEGY"
}...
2025-07-03 19:58:31,883 - HephaestusAgent - INFO - Estratégia escolhida pelo MaestroAgent (primary: gemini/gemini-2.5-pro, fallback: deepseek/deepseek-r1-0528:free): CREATE_NEW_TEST_FILE_STRATEGY
2025-07-03 19:58:31,883 - HephaestusAgent - INFO - 
Executing strategy 'CREATE_NEW_TEST_FILE_STRATEGY' with steps: ['validate_syntax', 'run_pytest_new_file', 'PatchApplicatorStep']
2025-07-03 19:58:31,883 - HephaestusAgent - INFO - Created temporary sandbox at: /tmp/hephaestus_sandbox_a967jogp
2025-07-03 19:58:31,883 - HephaestusAgent - INFO - Copying project to sandbox: /tmp/hephaestus_sandbox_a967jogp...
2025-07-03 19:58:31,897 - HephaestusAgent - INFO - Copy to sandbox complete.
2025-07-03 19:58:31,898 - HephaestusAgent - INFO - --- Validation/Execution Step: validate_syntax ---
2025-07-03 19:58:31,898 - HephaestusAgent - INFO - Starting syntax validation in: /tmp/hephaestus_sandbox_a967jogp
2025-07-03 19:58:31,898 - HephaestusAgent - DEBUG - Validating syntax of: /tmp/hephaestus_sandbox_a967jogp/tests/agent/test_patch_applicator.py
2025-07-03 19:58:31,898 - HephaestusAgent - DEBUG - Validando sintaxe Python de: /tmp/hephaestus_sandbox_a967jogp/tests/agent/test_patch_applicator.py
2025-07-03 19:58:31,898 - HephaestusAgent - DEBUG - Sintaxe Python de '/tmp/hephaestus_sandbox_a967jogp/tests/agent/test_patch_applicator.py' é válida.
2025-07-03 19:58:31,898 - HephaestusAgent - DEBUG - Realizando análise profunda para '/tmp/hephaestus_sandbox_a967jogp/tests/agent/test_patch_applicator.py'...
2025-07-03 19:58:31,898 - HephaestusAgent - INFO - Iniciando validação profunda para: /tmp/hephaestus_sandbox_a967jogp/tests/agent/test_patch_applicator.py
2025-07-03 19:58:31,901 - HephaestusAgent - INFO - Relatório de Qualidade para /tmp/hephaestus_sandbox_a967jogp/tests/agent/test_patch_applicator.py: Score = 100.00
2025-07-03 19:58:31,901 - HephaestusAgent - INFO -   Complexidade Ciclomática Geral: 11
2025-07-03 19:58:31,901 - HephaestusAgent - INFO -   LLOC: 39, Comentários: 15
2025-07-03 19:58:31,901 - HephaestusAgent - INFO - Análise profunda para '/tmp/hephaestus_sandbox_a967jogp/tests/agent/test_patch_applicator.py' concluída. Score: 100.0
2025-07-03 19:58:31,901 - HephaestusAgent - INFO - Syntax validation in '/tmp/hephaestus_sandbox_a967jogp': SUCCESS.
2025-07-03 19:58:31,901 - HephaestusAgent - INFO - --- Validation/Execution Step: run_pytest_new_file ---
2025-07-03 19:58:31,901 - HephaestusAgent - INFO - Executing PytestNewFileValidator...
2025-07-03 19:58:31,901 - HephaestusAgent - INFO - Running pytest on new file: /tmp/hephaestus_sandbox_a967jogp/tests/agent/test_patch_applicator.py
2025-07-03 19:58:33,144 - HephaestusAgent - INFO - Pytest passed for new file tests/agent/test_patch_applicator.py.
STDOUT:
============================= test session starts ==============================
platform linux -- Python 3.11.9, pytest-8.4.1, pluggy-1.6.0
rootdir: /tmp/hephaestus_sandbox_a967jogp
configfile: pyproject.toml
plugins: mock-3.14.1, anyio-4.9.0, hydra-core-1.3.2
collected 11 items

tests/agent/test_patch_applicator.py ...........                         [100%]

============================== 11 passed in 0.59s ==============================
2025-07-03 19:58:33,144 - HephaestusAgent - INFO - --- Validation/Execution Step: PatchApplicatorStep ---
2025-07-03 19:58:33,144 - HephaestusAgent - INFO - Applying 1 patches in '/tmp/hephaestus_sandbox_a967jogp'...
2025-07-03 19:58:33,144 - HephaestusAgent - INFO - Aplicando patches com base_path: '/tmp/hephaestus_sandbox_a967jogp'
2025-07-03 19:58:33,144 - HephaestusAgent - INFO - Processando patch 1/1: REPLACE em '/tmp/hephaestus_sandbox_a967jogp/tests/agent/test_patch_applicator.py'
2025-07-03 19:58:33,144 - HephaestusAgent - INFO - REPLACE sem 'block_to_replace' para '/tmp/hephaestus_sandbox_a967jogp/tests/agent/test_patch_applicator.py'. Arquivo será sobrescrito.
2025-07-03 19:58:33,566 - HephaestusAgent - INFO - Arquivo '/tmp/hephaestus_sandbox_a967jogp/tests/agent/test_patch_applicator.py' salvo após operação 'REPLACE'.
2025-07-03 19:58:33,566 - HephaestusAgent - INFO - Todas as 1 instruções de patch processadas. Arquivos afetados (tentativas): {'/tmp/hephaestus_sandbox_a967jogp/tests/agent/test_patch_applicator.py'}
2025-07-03 19:58:33,566 - HephaestusAgent - INFO - Patches applied successfully in '/tmp/hephaestus_sandbox_a967jogp'.
2025-07-03 19:58:33,566 - HephaestusAgent - INFO - Cleaning up temporary sandbox: /tmp/hephaestus_sandbox_a967jogp
2025-07-03 19:58:33,581 - HephaestusAgent - INFO - Sandbox cleaned.
2025-07-03 19:58:33,581 - HephaestusAgent - INFO - 
SUCESSO NA VALIDAÇÃO/APLICAÇÃO! Razão: VALIDATION_SUCCESS_NO_CHANGES
2025-07-03 19:58:33,581 - HephaestusAgent - INFO - Ciclo concluído com status: VALIDATION_SUCCESS_NO_CHANGES. Nenhuma alteração no código foi promovida. Gerando próximo objetivo evolutivo...
2025-07-03 19:58:33,581 - HephaestusAgent - INFO - Generating next objective...
2025-07-03 19:58:33,581 - HephaestusAgent - INFO - CAPABILITIES.md lido com sucesso.
2025-07-03 19:58:33,581 - HephaestusAgent - INFO - ROADMAP.md lido com sucesso.
2025-07-03 19:58:33,582 - HephaestusAgent - INFO - Analyzing code metrics in: .
2025-07-03 19:58:33,877 - HephaestusAgent - DEBUG - Code analysis summary:
Large Files (potential candidates for modularization):
  - agent/brain.py (LOC: 357)
  - agent/code_metrics.py (LOC: 362)
  - agent/hephaestus_agent.py (LOC: 369)
  - agent/patch_applicator.py (LOC: 697)
  - agent/cycle_runner.py (LOC: 485)
  - agent/project_scanner.py (LOC: 462)

Large Functions (potential candidates for refactoring/splitting):
  - agent/brain.py -> generate_next_objective() (LOC: 162)
  - agent/brain.py -> generate_capacitation_objective() (LOC: 59)
  - agent/brain.py -> generate_commit_message() (LOC: 98)
  - agent/code_metrics.py -> analyze_complexity() (LOC: 84)
  - agent/code_metrics.py -> calculate_quality_score() (LOC: 89)
  - agent/code_metrics.py -> detect_code_duplication() (LOC: 126)
  - agent/git_utils.py -> initialize_git_repository() (LOC: 208)
  - agent/patch_applicator.py -> _handle_replace() (LOC: 71)
  - agent/patch_applicator.py -> _handle_delete_block() (LOC: 78)
  - agent/patch_applicator.py -> apply_patches() (LOC: 285)
  - agent/cycle_runner.py -> run_cycles() (LOC: 460)
  - agent/prompt_builder.py -> build_meta_analysis_objective_prompt() (LOC: 62)
  - agent/prompt_builder.py -> build_standard_objective_prompt() (LOC: 100)
  - agent/project_scanner.py -> update_project_manifest() (LOC: 188)
  - agent/project_scanner.py -> analyze_code_metrics() (LOC: 208)
  - agent/config_loader.py -> load_config() (LOC: 53)
  - agent/utils/json_parser.py -> parse_json_response() (LOC: 75)

Complex Functions (high CC, potential candidates for refactoring/simplification):
  - agent/brain.py -> generate_next_objective() (CC: 43)
  - agent/brain.py -> generate_commit_message() (CC: 15)
  - agent/code_metrics.py -> analyze_complexity() (CC: 15)
  - agent/code_metrics.py -> calculate_quality_score() (CC: 23)
  - agent/code_metrics.py -> detect_code_duplication() (CC: 20)
  - agent/git_utils.py -> initialize_git_repository() (CC: 14)
  - agent/patch_applicator.py -> _handle_replace() (CC: 15)
  - agent/patch_applicator.py -> _handle_delete_block() (CC: 21)
  - agent/patch_applicator.py -> apply_patches() (CC: 65)
  - agent/cycle_runner.py -> run_cycles() (CC: 89)
  - agent/project_scanner.py -> update_project_manifest() (CC: 45)
  - agent/project_scanner.py -> analyze_code_metrics() (CC: 47)
  - agent/utils/json_parser.py -> parse_json_response() (CC: 25)

Modules without Corresponding Test Files (consider creating tests):
  - cli.py
  - app.py
  - run_agent.py
  - agent/brain.py
  - agent/code_metrics.py
  - agent/hephaestus_agent.py
  - agent/git_utils.py
  - agent/code_validator.py
  - agent/patch_applicator.py
  - agent/cycle_runner.py
  - agent/memory.py
  - agent/prompt_builder.py
  - agent/tool_executor.py
  - agent/project_scanner.py
  - agent/state.py
  - agent/config_loader.py
  - agent/validation_steps/pytest_validator.py
  - agent/validation_steps/__init__.py
  - agent/validation_steps/base.py
  - agent/validation_steps/patch_applicator.py
  - agent/validation_steps/syntax_validator.py
  - agent/validation_steps/pytest_new_file_validator.py
  - agent/agents/architect_agent.py
  - agent/agents/performance_analyzer.py
  - agent/agents/error_correction.py
  - agent/agents/maestro_agent.py
  - agent/agents/error_analyzer.py
  - agent/utils/json_parser.py
  - agent/utils/llm_client.py
2025-07-03 19:58:33,877 - HephaestusAgent - INFO - Analyzing performance log...
2025-07-03 19:58:33,883 - HephaestusAgent - DEBUG - Performance analysis summary:
Performance Summary:
- Total Cycles: 6
- Successful Cycles: 3
- Failed Cycles: 3
- Success Rate: 50.00%
- Average Cycle Duration: N/A

Performance by Strategy (sorted by failures):
- Strategy 'SYNTAX_AND_PYTEST': Success Rate: 0.00% (Failures: 3/3)
- Strategy 'CREATE_NEW_TEST_FILE_STRATEGY': Success Rate: 100.00% (Failures: 0/3)

2025-07-03 19:58:33,883 - HephaestusAgent - DEBUG - Prompt for generate_next_objective:

[Main Context]
You are the 'Planejador Estratégico Avançado' do agente autônomo Hephaestus. Sua principal responsabilidade é identificar e propor o próximo objetivo de desenvolvimento mais impactante para a evolução do agente ou do projeto em análise.

[Decision Process for the Next Objective]
1.  **Analyze Performance:** Review the `[PERFORMANCE ANALYSIS]` section.
2.  **Analyze Code Metrics:** Review the `[CODE METRICS AND ANALYSIS]` section.
3.  **Consider Strategic Documents:** Review `[CAPABILITIES DOCUMENT]` and `[ROADMAP DOCUMENT]` to understand current capabilities, desired future states, and strategic direction. Identify gaps or next steps.
4.  **Consider the Project Manifest:** If the `[CURRENT PROJECT MANIFEST]` is provided, use it for context.
5.  **Review Recent History:** The `[HISTÓRICO RECENTE DO PROJETO E DO AGENTE]` section provides context.
6.  **Prioritize RSI:** Focus on objectives that enhance the agent's ability to self-improve, improve its core logic, prompts, or strategies.
7.  **Prioritize Capabilities & Roadmap:** Generate objectives that fill gaps in `[CAPABILITIES DOCUMENT]` or advance items in `[ROADMAP DOCUMENT]`.
8.  **Prioritize Structural and Quality Improvements:** Based on metrics and strategic documents.
9.  **Be Specific and Actionable:** The objective should be clear, concise, and indicate a concrete action.

1.  **Analyze Performance:** Review the `[PERFORMANCE ANALYSIS]` section to understand the agent's overall success rate and identify trends, especially focusing on strategies with high failure rates.
2.  **Analyze Code Metrics:** Review the `[CODE METRICS AND ANALYSIS]` section below. It contains data on file size (LOC), function size (LOC), cyclomatic complexity (CC) of functions, and modules that may be missing tests.
3.  **Consider the Project Manifest:** If the `[CURRENT PROJECT MANIFEST]` is provided, use it to understand the overall goals, architecture, and areas already documented or needing attention.
4.  **Review Recent History:** The `[HISTÓRICO RECENTE DO PROJETO E DO AGENTE]` section provides context on recent tasks, successes, and failures. Avoid repeating objectives that recently failed in the same way, unless the cause of failure has been resolved. Use history to build on successes.
5.  **Prioritize Structural and Quality Improvements:** Based on metrics, identify opportunities to:
    *   Refactor very large modules or very long/complex functions.
    *   Create tests for critical/complex modules or functions that lack them.
    *   Improve documentation (docstrings, manifest) where crucial.
    *   Propose the creation of new capabilities (new agents, tools) if the analysis indicates a strategic need.
6.  **Prioritize Prompt and Strategy Optimization (RSI Focus):** If the performance analysis reveals strategies with consistently low success rates, consider objectives to:
    *   Refine the prompts used by agents (e.g., Architect, Maestro, ErrorAnalysis) for those failing strategies.
    *   Propose new or modified validation strategies in `hephaestus_config.json` to address specific failure patterns.
7.  **Be Specific and Actionable:** The objective should be clear, concise, and indicate a concrete action.


[HISTÓRICO RECENTE DO PROJETO E DO AGENTE]
Completed Objectives (most recent first):
- Objective: Dado que as tentativas de testar a função `run_cycles` (CC: 89) falharam repetidamente, a estratégia deve ser pivotar para um alvo crítico e complexo diferente para construir capacidade de teste. Crie o arquivo de teste `tests/agent/test_patch_applicator.py` e adicione um teste unitário inicial para a função auxiliar `_handle_insert`. Este teste deve usar `unittest.mock.patch` para simular as interações com o sistema de arquivos, validando a lógica de inserção de forma isolada e aumentando a cobertura de testes em um módulo vital (`apply_patches` CC: 65) que atualmente não possui testes.
  Strategy: CREATE_NEW_TEST_FILE_STRATEGY
  Outcome: Strategy 'CREATE_NEW_TEST_FILE_STRATEGY' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T22:58:33.581755+00:00
- Objective: Dado que as tentativas de testar a função `run_cycles` (CC: 89) com mocks falharam, indicando uma lacuna na capacidade de teste do agente, o próximo passo deve ser um objetivo de capacitação focado. Crie o arquivo de teste `tests/agent/test_memory.py` e adicione um teste unitário para uma função simples de escrita, como `save_to_log`. Este teste deve usar `unittest.mock.patch` para simular a interação com o sistema de arquivos (ex: `builtins.open`), validando a lógica da função de forma isolada e ensinando o agente a aplicar mocks com sucesso antes de tentar novamente em alvos mais complexos.
  Strategy: CREATE_NEW_TEST_FILE_STRATEGY
  Outcome: Strategy 'CREATE_NEW_TEST_FILE_STRATEGY' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T22:57:07.396027+00:00

Failed Objectives (most recent first):
- Objective: Dado o sucesso em criar o arquivo de teste para `cycle_runner`, o próximo passo é adicionar um teste de caracterização para a função `run_cycles` (CC: 89). Este teste deve usar `unittest.mock` para simular as dependências essenciais (como `AgentState` e `QueueManager`) e invocar a função, validando que ela pode ser executada em um cenário controlado sem erros, estabelecendo assim a base para testes de lógica mais detalhados e refatoração segura.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_qyaqjai0)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:41:06.299306+00:00
- Objective: Para iniciar a refatoração da função `run_cycles` (CC: 89), que é a mais complexa do projeto, extraia a lógica de inicialização do ciclo (criação do `AgentState` e logs iniciais) para uma nova função auxiliar privada dentro de `agent/cycle_runner.py`. Em seguida, adicione um teste unitário no arquivo `tests/agent/test_cycle_runner.py` que valide especificamente o comportamento desta nova função extraída, garantindo um progresso incremental e seguro.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_v22kn3j2)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:31:44.352659+00:00
Consider this history to avoid repeating failures, build on successes, and identify gaps.


[PERFORMANCE ANALYSIS]
Performance Summary:
- Total Cycles: 6
- Successful Cycles: 3
- Failed Cycles: 3
- Success Rate: 50.00%
- Average Cycle Duration: N/A

Performance by Strategy (sorted by failures):
- Strategy 'SYNTAX_AND_PYTEST': Success Rate: 0.00% (Failures: 3/3)
- Strategy 'CREATE_NEW_TEST_FILE_STRATEGY': Success Rate: 100.00% (Failures: 0/3)


[CODE METRICS AND ANALYSIS]
Large Files (potential candidates for modularization):
  - agent/brain.py (LOC: 357)
  - agent/code_metrics.py (LOC: 362)
  - agent/hephaestus_agent.py (LOC: 369)
  - agent/patch_applicator.py (LOC: 697)
  - agent/cycle_runner.py (LOC: 485)
  - agent/project_scanner.py (LOC: 462)

Large Functions (potential candidates for refactoring/splitting):
  - agent/brain.py -> generate_next_objective() (LOC: 162)
  - agent/brain.py -> generate_capacitation_objective() (LOC: 59)
  - agent/brain.py -> generate_commit_message() (LOC: 98)
  - agent/code_metrics.py -> analyze_complexity() (LOC: 84)
  - agent/code_metrics.py -> calculate_quality_score() (LOC: 89)
  - agent/code_metrics.py -> detect_code_duplication() (LOC: 126)
  - agent/git_utils.py -> initialize_git_repository() (LOC: 208)
  - agent/patch_applicator.py -> _handle_replace() (LOC: 71)
  - agent/patch_applicator.py -> _handle_delete_block() (LOC: 78)
  - agent/patch_applicator.py -> apply_patches() (LOC: 285)
  - agent/cycle_runner.py -> run_cycles() (LOC: 460)
  - agent/prompt_builder.py -> build_meta_analysis_objective_prompt() (LOC: 62)
  - agent/prompt_builder.py -> build_standard_objective_prompt() (LOC: 100)
  - agent/project_scanner.py -> update_project_manifest() (LOC: 188)
  - agent/project_scanner.py -> analyze_code_metrics() (LOC: 208)
  - agent/config_loader.py -> load_config() (LOC: 53)
  - agent/utils/json_parser.py -> parse_json_response() (LOC: 75)

Complex Functions (high CC, potential candidates for refactoring/simplification):
  - agent/brain.py -> generate_next_objective() (CC: 43)
  - agent/brain.py -> generate_commit_message() (CC: 15)
  - agent/code_metrics.py -> analyze_complexity() (CC: 15)
  - agent/code_metrics.py -> calculate_quality_score() (CC: 23)
  - agent/code_metrics.py -> detect_code_duplication() (CC: 20)
  - agent/git_utils.py -> initialize_git_repository() (CC: 14)
  - agent/patch_applicator.py -> _handle_replace() (CC: 15)
  - agent/patch_applicator.py -> _handle_delete_block() (CC: 21)
  - agent/patch_applicator.py -> apply_patches() (CC: 65)
  - agent/cycle_runner.py -> run_cycles() (CC: 89)
  - agent/project_scanner.py -> update_project_manifest() (CC: 45)
  - agent/project_scanner.py -> analyze_code_metrics() (CC: 47)
  - agent/utils/json_parser.py -> parse_json_response() (CC: 25)

Modules without Corresponding Test Files (consider creating tests):
  - cli.py
  - app.py
  - run_agent.py
  - agent/brain.py
  - agent/code_metrics.py
  - agent/hephaestus_agent.py
  - agent/git_utils.py
  - agent/code_validator.py
  - agent/patch_applicator.py
  - agent/cycle_runner.py
  - agent/memory.py
  - agent/prompt_builder.py
  - agent/tool_executor.py
  - agent/project_scanner.py
  - agent/state.py
  - agent/config_loader.py
  - agent/validation_steps/pytest_validator.py
  - agent/validation_steps/__init__.py
  - agent/validation_steps/base.py
  - agent/validation_steps/patch_applicator.py
  - agent/validation_steps/syntax_validator.py
  - agent/validation_steps/pytest_new_file_validator.py
  - agent/agents/architect_agent.py
  - agent/agents/performance_analyzer.py
  - agent/agents/error_correction.py
  - agent/agents/maestro_agent.py
  - agent/agents/error_analyzer.py
  - agent/utils/json_parser.py
  - agent/utils/llm_client.py

[CAPABILITIES DOCUMENT (CAPABILITIES.md)]
# Manifesto de Capacidades do Hephaestus

Este documento descreve as capacidades atuais e desejadas do agente Hephaestus, servindo como um guia para o seu desenvolvimento e para a geração de objetivos estratégicos. O foco principal é o **Aprimoramento Auto Recursivo (RSI)**, onde o agente busca ativamente melhorar suas próprias funções e arquitetura.

---

## 1. Capacidades Atuais

### 1.1. Análise e Planejamento
- **Geração de Objetivos (`agent/brain.py`):**
  - Analisa métricas de código estático (complexidade, tamanho do arquivo/função, cobertura de testes).
  - Analisa o manifesto do projeto (`AGENTS.md`).
  - Gera um objetivo de desenvolvimento com base na análise.
  - **Agora considera a análise de performance (`evolution_log.csv`) para otimizar prompts e estratégias.**
- **Análise de Erros (`agent/agents/error_analyzer.py`):**
  - Classifica falhas (ex: erro de sintaxe, falha de teste).
  - Propõe um prompt de correção para o `ArchitectAgent`.
  - **Pode sugerir objetivos de meta-análise para questionar o objetivo ou a estratégia original.**
- **Planejamento de Patches (`agent/agents/architect_agent.py`):**
  - Recebe um objetivo e o manifesto do projeto.
  - Gera um plano de patches em formato JSON para modificar a base de código.
- **Seleção de Estratégia (`agent/agents/maestro_agent.py`):**
  - Analisa o plano de patches.
  - Escolhe uma estratégia de validação apropriada (ex: apenas sintaxe, sintaxe e testes).

### 1.2. Execução e Validação
- **Aplicação de Patches (`agent/patch_applicator.py`):**
  - Aplica as modificações de código propostas em um ambiente de sandbox.
- **Validação de Sintaxe (`agent/validation_steps/syntax_validator.py`):**
  - Verifica a sintaxe de arquivos Python e JSON.
- **Execução de Testes (`agent/validation_steps/pytest_validator.py`):**
  - Executa a suíte de testes `pytest` para validar as alterações.
- **Gerenciamento de Estado e Ciclo (`agent/state.py`, `agent/cycle_runner.py`):**
  - Orquestra o fluxo completo de um ciclo de evolução.
  - Mantém o estado do ciclo atual (objetivo, patches, resultado da validação).
  - **O `cycle_runner.py` agora interage com um `QueueManager` para processar objetivos de forma assíncrona.**

### 1.3. Memória e Versionamento
- **Memória Persistente (`agent/memory.py`):**
  - Registra o histórico de objetivos bem-sucedidos e falhos.
  - Fornece contexto histórico para as decisões dos agentes.
- **Versionamento com Git (`agent/git_utils.py`):**
  - Inicializa o repositório Git.
  - Realiza commits automáticos após a validação bem-sucedida das alterações.

### 1.4. Infraestrutura (Nova)
- **Servidor FastAPI (`app.py`):**
  - Executa o Hephaestus como um serviço em segundo plano.
  - Expõe endpoints para submissão de objetivos e verificação de status.
  - Gerencia um thread worker para processar objetivos da fila.
- **Gerenciamento de Fila (`agent/queue_manager.py`):**
  - Permite a comunicação assíncrona de objetivos entre o servidor e o worker do agente.
- **Carregamento de Configuração (`agent/config_loader.py`):**
  - Módulo dedicado para carregar a configuração do agente de forma centralizada.

---

## 2. Capacidades Desejadas (Roadmap RSI)

O desenvolvimento futuro deve focar em aprimorar a capacidade do agente de entender e melhorar a si mesmo.

### 2.1. Meta-Cognição e Análise de Performance
- **Análise de Performance do Agente:**
  - **Objetivo:** Desenvolver a capacidade de analisar o próprio log de evolução (`evolution_log.csv`) para identificar gargalos, estratégias ineficazes e padrões de falha.
  - **Status:** Implementado. O `PerformanceAnalysisAgent` agora fornece uma análise detalhada do `evolution_log.csv`, incluindo taxa de sucesso geral, taxa de sucesso por estratégia e tempo médio de ciclo. O `generate_next_objective` utiliza essa análise para informar a geração de objetivos.
- **Análise de Causa Raiz (Meta-Análise):**
  - **Objetivo:** Aprimorar o `ErrorAnalysisAgent` para que, diante de falhas repetidas, ele possa questionar a validade do objetivo ou da estratégia, em vez de apenas tentar corrigir o código.
  - **Status:** Iniciado. O `ErrorAnalysisAgent` agora pode sugerir objetivos de meta-análise, e o `generate_next_objective` em `agent/brain.py` foi aprimorado para detectar e processar esses objetivos, gerando um novo objetivo estratégico para abordar a causa raiz da falha.

### 2.2. Aprimoramento da Arquitetura e Estratégia
- **Estratégias de Validação Dinâmicas:**
  - **Objetivo:** Permitir que o `MaestroAgent` não apenas escolha, mas também proponha a criação de novas estratégias de validação com base no contexto da tarefa.
  - **Status:** Iniciado. O `generate_next_objective` agora inclui a otimização de prompts e estratégias como uma prioridade, permitindo que o agente proponha modificações em `hephaestus_config.json` ou refinamento de prompts existentes com base na análise de performance.
- **Refatoração Orientada a Capacidades:**
  - **Objetivo:** Garantir que os objetivos de refatoração estejam sempre ligados a um aprimoramento de capacidade, e não apenas à melhoria de métricas de código.
  - **Status:** Não iniciado. (A base para isso foi estabelecida com a meta-análise e otimização de prompts, mas a refatoração explícita orientada a capacidades ainda não foi implementada).

### 2.3. Expansão de Ferramentas
- **Auto-Aprimoramento de Ferramentas:**
  - **Objetivo:** Dar ao agente a capacidade de modificar e aprimorar suas próprias ferramentas (ex: `tool_executor.py`) quando uma tarefa falha devido a uma limitação da ferramenta.
  - **Status:** Não iniciado. (A meta-análise de falhas pode identificar a necessidade de aprimoramento de ferramentas, mas a implementação autônoma ainda não está presente).

- **Acesso e Raciocínio com Conhecimento Externo:**
  - **Objetivo:** Implementar uma ferramenta de busca na web (`web_search`) robusta, permitindo que o agente pesquise documentação de APIs, soluções para erros e novas bibliotecas para resolver problemas que estão além de seu conhecimento atual.
  - **Status:** Não iniciado.

- **Gerenciamento de Estratégias Dinâmicas:**
  - **Objetivo:** O `MaestroAgent` deve evoluir de um simples selecionador de estratégias para um arquiteto de estratégias. Ele deve ser capaz de propor, e até mesmo codificar, novas estratégias de validação em `hephaestus_config.json` com base nos requisitos de um objetivo.
  - **Status:** Iniciado. O `generate_next_objective` agora inclui a otimização de prompts e estratégias como uma prioridade, permitindo que o agente proponha modificações em `hephaestus_config.json` ou refinamento de prompts existentes com base na análise de performance.


[ROADMAP DOCUMENT (ROADMAP.md)]
# Roadmap de Evolução do Hephaestus

Este documento delineia a visão de alto nível para a evolução do Hephaestus como um agente de **Aprimoramento Auto Recursivo (RSI)**. Ele serve como um guia estratégico, enquanto o `CAPABILITIES.md` detalha os passos táticos.

---

## Fase 1: Consciência e Correção (Curto Prazo)

O foco desta fase é fazer com que o agente pare de executar tarefas cegamente e comece a entender seu próprio desempenho e a corrigir suas falhas de forma mais inteligente.

-   [x] **1. Análise de Performance:**
    -   **Visão:** O agente deve ser capaz de ler seu próprio log de performance (`evolution_log.csv`) e responder a perguntas como: "Qual é a minha taxa de sucesso?", "Quais estratégias falham mais?" e "Onde estou gastando mais tempo?".
    -   **Status:** Implementado. O `PerformanceAnalysisAgent` agora fornece uma análise detalhada do `evolution_log.csv`, incluindo taxa de sucesso geral, taxa de sucesso por estratégia e tempo médio de ciclo. O `generate_next_objective` utiliza essa análise para informar a geração de objetivos.

-   [x] **2. Meta-Análise de Falhas:**
    -   **Visão:** Quando uma tarefa falha repetidamente, o agente deve parar de tentar corrigir o código e, em vez disso, questionar o objetivo em si. Ele deve ser capaz de concluir: "Esta abordagem não está funcionando, preciso de uma nova estratégia ou de uma nova ferramenta".
    -   **Status:** Iniciado. O `ErrorAnalysisAgent` agora pode sugerir objetivos de meta-análise, e o `generate_next_objective` em `agent/brain.py` foi aprimorado para detectar e processar esses objetivos, gerando um novo objetivo estratégico para abordar a causa raiz da falha.

-   [ ] **3. Refatoração Orientada a Capacidades:**
    -   **Visão:** O agente só deve propor refatorações de código se elas estiverem diretamente ligadas a um objetivo de capacitação, como "preciso refatorar este módulo para conseguir implementar uma nova ferramenta de análise".
    -   **Status:** Não iniciado. (A base para isso foi estabelecida com a meta-análise e otimização de prompts, mas a refatoração explícita orientada a capacidades ainda não foi implementada).

---

## Fase 2: Expansão de Habilidades (Médio Prazo)

Com a consciência básica estabelecida, o foco se volta para a expansão proativa de suas próprias habilidades e ferramentas.

-   [ ] **1. Auto-Aprimoramento de Ferramentas:**
    -   **Visão:** O agente deve ser capaz de modificar suas próprias ferramentas (`tool_executor.py`, `validation_steps/`, etc.) quando encontrar uma limitação. Se uma validação é muito fraca ou uma ferramenta não tem um parâmetro necessário, ele deve ser capaz de adicioná-lo.
    -   **Status:** Não iniciado. (A meta-análise de falhas pode identificar a necessidade de aprimoramento de ferramentas, mas a implementação autônoma ainda não está presente).

-   [ ] **2. Acesso e Raciocínio com Conhecimento Externo:**
    -   **Visão:** Implementar uma ferramenta de busca na web (`web_search`) robusta, permitindo que o agente pesquise documentação de APIs, soluções para erros e novas bibliotecas para resolver problemas que estão além de seu conhecimento atual.
    -   **Status:** Não iniciado.

-   [x] **3. Gerenciamento de Estratégias Dinâmicas:**
    -   **Visão:** O `MaestroAgent` deve evoluir de um simples selecionador de estratégias para um arquiteto de estratégias. Ele deve ser capaz de propor, e até mesmo codificar, novas estratégias de validação em `hephaestus_config.json` com base nos requisitos de um objetivo.
    -   **Status:** Iniciado. O `generate_next_objective` agora inclui a otimização de prompts e estratégias como uma prioridade, permitindo que o agente proponha modificações em `hephaestus_config.json` ou refinamento de prompts existentes com base na análise de performance.

---

## Fase 3: Autonomia Estratégica (Longo Prazo)

Nesta fase, o agente transcende a execução de ciclos e começa a gerenciar seu próprio desenvolvimento de forma estratégica.

-   [ ] **1. Planejamento de Longo Prazo:**
    -   **Visão:** O agente deve ser capaz de analisar este próprio `ROADMAP.md` e o `CAPABILITIES.md` para gerar um plano de desenvolvimento de múltiplos passos para si mesmo, em vez de operar em um ciclo de objetivo único.
    -   **Status:** Não iniciado.

-   [ ] **2. Auto-Otimização de Modelos:**
    -   **Visão:** Capturar os prompts e as respostas de maior sucesso para criar conjuntos de dados de fine-tuning. O objetivo final é treinar versões especializadas dos modelos de LLM que sejam mais eficientes e precisas para as tarefas do Hephaestus.
    -   **Status:** Não iniciado.

-   [ ] **3. Arquitetura de Agentes Dinâmica:**
    -   **Visão:** O agente deve ser capaz de propor e implementar mudanças em sua própria arquitetura de agentes, como criar um novo agente especializado (ex: `DocumentationAgent`) ou dividir as responsabilidades de um agente existente, para melhorar a eficiência do sistema.
    -   **Status:** Não iniciado.

---

## Arquitetura de Servidor (Novo)

-   [x] **1. Transformação em Servidor FastAPI:**
    -   **Visão:** O Hephaestus opera como um servidor em segundo plano, permitindo a submissão assíncrona de objetivos e monitoramento de status via API.
    -   **Status:** Implementado. O `main.py` agora inicia um servidor FastAPI, e o agente é executado em um thread worker separado, utilizando um `QueueManager` para gerenciar os objetivos.



[CURRENT PROJECT MANIFEST (if existing)]
# MANIFESTO DO PROJETO HEPHAESTUS

## 1. ESTRUTURA DE ARQUIVOS (OTIMIZADA)
agente_autonomo/
    README.md
    hephaestus.log
    cli.py
    AGENTS.md
    poetry.lock
    CONTRIBUTING.md
    app.py
    HEPHAESTUS_MEMORY.json
    main.py
    ROADMAP.md
    hephaestus_config.json
    requirements.txt
    run_agent.py
    MANIFESTO.md
    evolution_log.csv
    CODE_OF_CONDUCT.md
    ANALISE_PERFORMANCE_HEPHAESTUS.md
    ISSUES.md
    ANALISE_TECNICA_HEPHAESTUS.md
    Sugestões de Melhoria para o Projeto Agente Autônomo.md
    CAPABILITIES.md
    pyproject.toml
    agent/
        brain.py
        __init__.py
        code_metrics.py
        hephaestus_agent.py
        git_utils.py
        code_validator.py
        patch_applicator.py
        cycle_runner.py
        memory.py
        prompt_builder.py
        tool_executor.py
        project_scanner.py
        queue_manager.py
        state.py
        config_loader.py
        validation_steps/
            pytest_validator.py
            __init__.py
            base.py
            patch_applicator.py
            syntax_validator.py
            pytest_new_file_validator.py
        agents/
            __init__.py
            architect_agent.py
            performance_analyzer.py
            error_correction.py
            maestro_agent.py
            error_analyzer.py
        utils/
            __init__.py
            json_parser.py
            llm_client.py
    config/
        example_config.yaml
        base_config.yaml
        default.yaml
        models/
            main.yaml
        validation_strategies/
            main.yaml

## 2. RESUMO DAS INTERFACES (APIs Internas)

### Arquivo: `cli.py`
- **Função:** `run(continuous: bool=typer.Option(False, '--continuous', '-c', help='Run in continuous mode'), max_cycles: int=typer.Option(None, '--max-cycles', '-m', help='Maximum number of evolution cycles'))`
  - *Run the Hephaestus agent*
- **Função:** `submit(objective: str)`
  - *Submit a new objective to the agent*
- **Função:** `status()`
  - *Check agent status*

### Arquivo: `app.py`
- **Classe:** `Objective(BaseModel)`
- **Função:** `startup_event()`
- **Função:** `submit_objective(obj: Objective)`
- **Função:** `get_status()`

### Arquivo: `main.py`

### Arquivo: `run_agent.py`

### Arquivo: `agent/brain.py`
- **Função:** `generate_next_objective(model_config: Dict[str, str], current_manifest: str, logger: logging.Logger, project_root_dir: str, config: Optional[Dict[str, Any]]=None, memory_summary: Optional[str]=None, current_objective: Optional[str]=None)`
  - *Generates the next evolutionary objective using a lightweight model and code analysis.*
- **Função:** `generate_capacitation_objective(model_config: Dict[str, str], engineer_analysis: str, memory_summary: Optional[str]=None, logger: Optional[logging.Logger]=None)`
  - *Generates an objective to create necessary new capabilities.*
- **Função:** `generate_commit_message(model_config: Dict[str, str], analysis_summary: str, objective: str, logger: logging.Logger)`
  - *Generates a concise and informative commit message using an LLM.*

### Arquivo: `agent/__init__.py`

### Arquivo: `agent/code_metrics.py`
- **Função:** `analyze_complexity(code_string: str)`
  - *Analyzes the cyclomatic complexity and other metrics of the given Python code string using Radon.*
- **Função:** `calculate_quality_score(complexity_report: dict, duplication_report: list)`
  - *Calculates a quality score based on complexity, duplication, and other code metrics.*
- **Função:** `_get_code_lines(code_string: str, strip_comments_blanks: bool=True)`
  - *Returns a list of (original_line_number, line_content) tuples.*
- **Função:** `_find_duplicates_for_block(block_to_check: list[str], all_lines: list[tuple[int, str]], start_index: int, min_lines: int)`
  - *Finds occurrences of block_to_check in all_lines, starting after start_index.*
- **Função:** `detect_code_duplication(code_string: str, min_lines: int=4, strip_comments_and_blanks: bool=True)`
  - *Detects duplicated code blocks in the given Python code string.*

### Arquivo: `agent/hephaestus_agent.py`
- **Classe:** `HephaestusAgent`
  - *Classe principal que encapsula a lógica do agente autônomo.*

### Arquivo: `agent/git_utils.py`
- **Função:** `initialize_git_repository(logger: logging.Logger)`
  - *Ensure a git repository exists and is configured.*

### Arquivo: `agent/code_validator.py`
- **Função:** `perform_deep_validation(file_path: Path, logger: logging.Logger)`
  - *Realiza uma análise profunda da qualidade do código Python.*
- **Função:** `validate_python_code(file_path: str | Path, logger: logging.Logger, perform_deep_analysis: bool=True)`
  - *Valida se o código Python em um arquivo é sintaticamente correto e, opcionalmente, realiza uma análise profunda.*
- **Função:** `validate_json_syntax(file_path: str | Path, logger: logging.Logger)`
  - *Valida se um arquivo contém JSON válido.*

### Arquivo: `agent/patch_applicator.py`
- **Função:** `_handle_insert(full_path: Path, lines: list[str], instruction: dict, logger: logging.Logger)`
  - *Apply an INSERT patch and return ``(success, updated_lines)``.*
- **Função:** `_handle_replace(full_path: Path, lines: list[str], instruction: dict, logger: logging.Logger)`
  - *Apply a REPLACE patch.*
- **Função:** `_handle_delete_block(full_path: Path, lines: list[str], instruction: dict, logger: logging.Logger)`
  - *Apply a DELETE_BLOCK patch.*
- **Função:** `apply_patches(instructions: list[dict], logger: logging.Logger, base_path: str='.')`
  - *Aplica uma lista de instruções de patch aos arquivos.*

### Arquivo: `agent/cycle_runner.py`
- **Função:** `run_cycles(agent: 'HephaestusAgent', queue_manager: QueueManager)`
  - *Execute the main evolution loop for the given agent.*

### Arquivo: `agent/memory.py`
- **Classe:** `Memory`
  - *Manages persistent memory for the Hephaestus agent, storing historical data*

### Arquivo: `agent/prompt_builder.py`
- **Função:** `build_memory_context_section(memory_summary: Optional[str])`
  - *Constrói a seção de contexto da memória para os prompts.*
- **Função:** `build_initial_objective_prompt(memory_context_section: str)`
  - *Constrói o prompt para gerar o objetivo inicial quando não há manifesto ou análise de código.*
- **Função:** `build_meta_analysis_objective_prompt(current_objective: str, original_failed_objective: str, error_reason_for_meta: str, performance_summary_str: str, memory_context_section: str, capabilities_content: str, roadmap_content: str)`
  - *Constrói o prompt para gerar um objetivo estratégico após uma meta-análise de falha.*
- **Função:** `build_standard_objective_prompt(memory_context_section: str, performance_summary_str: str, code_analysis_summary_str: str, current_manifest: str, capabilities_content: str, roadmap_content: str)`
  - *Constrói o prompt padrão para gerar o próximo objetivo estratégico.*

### Arquivo: `agent/tool_executor.py`
- **Função:** `run_pytest(test_dir: str='tests/', cwd: str | Path | None=None)`
  - *Executa testes pytest no diretório especificado e retorna resultados.*
- **Função:** `check_file_existence(file_paths: list[str])`
  - *Verifica se todos os arquivos especificados existem.*
- **Função:** `run_in_sandbox(temp_dir_path: str, objective: str)`
  - *Executa o main.py de um diretório isolado monitorando tempo e memória.*
- **Função:** `run_git_command(command: list[str])`
  - *Executa um comando Git e retorna o status e a saída.*
- **Função:** `web_search(query: str)`
  - *Realiza uma pesquisa na web usando a API DuckDuckGo e retorna os resultados.*

### Arquivo: `agent/project_scanner.py`
- **Função:** `_extract_elements(code_string: str)`
- **Função:** `_extract_skeleton(code_string: str)`
- **Função:** `update_project_manifest(root_dir: str, target_files: List[str], output_path: str='AGENTS.md', excluded_dir_patterns: Optional[List[str]]=None)`
- **Função:** `analyze_code_metrics(root_dir: str, excluded_dir_patterns: Optional[List[str]]=None, file_loc_threshold: int=300, func_loc_threshold: int=50, func_cc_threshold: int=10)`
  - *Analisa arquivos Python em um diretório para métricas de código como LOC e Complexidade Ciclomática.*

### Arquivo: `agent/queue_manager.py`
- **Classe:** `QueueManager`

### Arquivo: `agent/state.py`
- **Classe:** `AgentState`
  - *Representa o estado interno do agente Hephaestus durante um ciclo de processamento.*

### Arquivo: `agent/config_loader.py`
- **Função:** `load_config()`
  - *Load configuration using Hydra.*

### Arquivo: `agent/validation_steps/pytest_validator.py`
- **Classe:** `PytestValidator(ValidationStep)`
  - *Runs pytest as a validation step.*

### Arquivo: `agent/validation_steps/__init__.py`
- **Classe:** `BenchmarkValidator(ValidationStep)`
- **Classe:** `CheckFileExistenceValidator(ValidationStep)`
- **Classe:** `ValidateJsonSyntax(ValidationStep)`
- **Função:** `get_validation_step(name: str)`

### Arquivo: `agent/validation_steps/base.py`
- **Classe:** `ValidationStep(ABC)`
  - *Abstract base class for a validation step.*

### Arquivo: `agent/validation_steps/patch_applicator.py`
- **Classe:** `PatchApplicatorStep(ValidationStep)`
  - *Applies patches to the specified base path.*

### Arquivo: `agent/validation_steps/syntax_validator.py`
- **Classe:** `SyntaxValidator(ValidationStep)`
  - *Validates the syntax of Python and JSON files.*

### Arquivo: `agent/validation_steps/pytest_new_file_validator.py`
- **Classe:** `PytestNewFileValidator(ValidationStep)`
  - *A validation step that runs pytest specifically on newly created test files.*

### Arquivo: `agent/agents/__init__.py`

### Arquivo: `agent/agents/architect_agent.py`
- **Classe:** `ArchitectAgent`

### Arquivo: `agent/agents/performance_analyzer.py`
- **Classe:** `PerformanceAnalysisAgent`
  - *An agent dedicated to analyzing the performance of Hephaestus.*

### Arquivo: `agent/agents/error_correction.py`
- **Classe:** `ErrorCorrectionAgent`
  - *Agent for analyzing errors and generating corrective actions.*

### Arquivo: `agent/agents/maestro_agent.py`
- **Classe:** `MaestroAgent`

### Arquivo: `agent/agents/error_analyzer.py`
- **Classe:** `ErrorAnalysisAgent`

### Arquivo: `agent/utils/__init__.py`

### Arquivo: `agent/utils/json_parser.py`
- **Função:** `parse_json_response(raw_str: str, logger: logging.Logger)`
  - *Analisa uma string bruta que se espera conter JSON, limpando-a e decodificando-a.*

### Arquivo: `agent/utils/llm_client.py`
- **Função:** `call_gemini_api(model: str, prompt: str, temperature: float, max_tokens: Optional[int], logger: logging.Logger)`
  - *Calls the Google Gemini API.*
- **Função:** `call_openrouter_api(model: str, prompt: str, temperature: float, max_tokens: Optional[int], logger: logging.Logger)`
  - *Calls a generic OpenAI-compatible API (like OpenRouter).*
- **Função:** `call_llm_with_fallback(model_config: Dict[str, Any], prompt: str, temperature: float, logger: logging.Logger)`
  - *Orchestrates LLM calls with a primary and fallback model.*

## 3. CONTEÚDO COMPLETO DOS ARQUIVOS ALVO


[Examples of Smart and Self-Aware Objectives]
*   **Performance-Based Objectives:**
    *   "The agent's success rate is low. Analyze the `evolution_log.csv` to identify the most common causes of failure and propose a solution."
    *   "Given the high number of failed cycles, implement a more robust error analysis mechanism in `error_analyzer.py`."
*   **Prompt/Strategy Optimization Objectives (RSI Focus):**
    *   "The 'SYNTAX_ONLY' strategy has a high failure rate. Analyze the prompts used by the ArchitectAgent when this strategy is chosen and propose modifications to improve syntax correctness."
    *   "Propose a new validation strategy in `hephaestus_config.json` called 'ADVANCED_LINTING' that includes `ruff` checks before applying patches, to reduce syntax errors."
    *   "Analyze the `MaestroAgent`'s decision-making process for objectives related to documentation updates, as the 'DOC_UPDATE_STRATEGY' has a low success rate. Refine its prompt to improve accuracy."
*   **Metrics-Based Refactoring:**
    *   "Refactor the module `agent/brain.py` (LOC: 350) which is extensive, considering splitting responsibilities into smaller modules (e.g., `agent/prompt_builder.py` or `agent/analysis_processor.py`)."
    *   "The function `generate_next_objective` in `agent/brain.py` (LOC: 85, CC: 12) is long and complex. Propose a plan to refactor it into smaller, more focused functions."
    *   "Analyze the most complex functions (CC > 10) listed in the metrics and select one for refactoring."
*   **Test Creation (Generate New Test Files):**
    *   "The module `agent/project_scanner.py` is missing a test file. Create a new test file `tests/agent/test_project_scanner.py` with basic unit tests for the `analyze_code_metrics` function."
    *   "Module `agent/memory.py` lacks tests. Generate `tests/agent/test_memory.py` and include placeholder tests for its public functions."
    *   "Create unit tests for the module `agent/tool_executor.py` in a new file `tests/agent/test_tool_executor.py`, focusing on the `web_search` function."
    *   "The function `call_llm_api` in `agent/utils/llm_client.py` is critical. Ensure robust unit tests exist for it in `tests/agent/utils/test_llm_client.py`, covering success and failure cases. If the test file doesn't exist, create it."
*   **Test-Driven Development (TDD) Flow:**
    *   "The previous cycle successfully created a new test file `tests/agent/test_new_feature.py` which is now failing as expected. The next objective is to implement the minimal code in `agent/new_feature.py` required to make the tests in `tests/agent/test_new_feature.py` pass."
*   **Strategic Documentation Improvement:**
    *   "The manifest (`AGENTS.md`) does not describe the new metrics analysis functionality in `project_scanner.py`. Update it."
    *   "Improve docstrings for public functions in the `agent/memory.py` module to detail parameters and expected behavior."
*   **Development of New Capabilities (Agents/Tools):**
    *   "Create a new agent (e.g., `CodeQualityAgent` in `agent/agents.py`) dedicated to continuously monitoring code quality metrics and reporting regressions."
    *   "Develop a new tool in `agent/tool_executor.py` to automatically validate the syntax of JSON files before processing."
    *   "Propose a system for Hephaestus to evaluate the performance of its own operations and identify bottlenecks."
*   **Generic Objectives (when metrics/manifest are insufficient):**
    *   "Analyze the `agent/state.py` module to identify potential improvements in clarity or efficiency."
    *   "Review recent logs for frequent errors and propose an objective to fix them."

[Your Task]
Based on ALL the information provided (metrics, manifest, history), generate ONLY a single text string containing the NEXT STRATEGIC OBJECTIVE. The objective should be the most impactful and logical for the project's evolution at this moment.
Be concise, but specific enough to be actionable.

2025-07-03 19:58:33,883 - HephaestusAgent - INFO - Calling primary model: gemini/gemini-2.5-pro
2025-07-03 19:58:33,883 - HephaestusAgent - INFO - Attempting to call Gemini API with model: gemini/gemini-2.5-pro
2025-07-03 19:58:53,516 - HephaestusAgent - DEBUG - Gemini API Response: Dado o sucesso em criar o teste para a função `_handle_insert`, o próximo passo é continuar a construção da capacidade de teste no módulo `agent/patch_applicator.py` (CC: 65), que é crítico e complexo. Adicione um novo teste unitário ao arquivo `tests/agent/test_patch_applicator.py` para a função auxiliar `_handle_replace` (CC: 15), utilizando `unittest.mock.patch` para simular as interações com o sistema de arquivos e validar a lógica de substituição de forma isolada.
2025-07-03 19:58:53,516 - HephaestusAgent - INFO - Próximo objetivo: Dado o sucesso em criar o teste para a função `_handle_insert`, o próximo passo é continuar a construção da capacidade de teste no módulo `agent/patch_applicator.py` (CC: 65), que é crítico e complexo. Adicione um novo teste unitário ao arquivo `tests/agent/test_patch_applicator.py` para a função auxiliar `_handle_replace` (CC: 15), utilizando `unittest.mock.patch` para simular as interações com o sistema de arquivos e validar a lógica de substituição de forma isolada.
2025-07-03 19:58:53,518 - HephaestusAgent - INFO - Memória salva em HEPHAESTUS_MEMORY.json (4 completed, 4 failed)
2025-07-03 19:58:53,518 - HephaestusAgent - INFO - ==================== FIM DO CICLO DE EVOLUÇÃO ====================
2025-07-03 19:58:54,518 - HephaestusAgent - INFO - 

==================== INÍCIO DO CICLO DE EVOLUÇÃO (Ciclo #3) ====================
2025-07-03 19:58:54,518 - HephaestusAgent - INFO - OBJETIVO ATUAL: Dado o sucesso em criar o teste para a função `_handle_insert`, o próximo passo é continuar a construção da capacidade de teste no módulo `agent/patch_applicator.py` (CC: 65), que é crítico e complexo. Adicione um novo teste unitário ao arquivo `tests/agent/test_patch_applicator.py` para a função auxiliar `_handle_replace` (CC: 15), utilizando `unittest.mock.patch` para simular as interações com o sistema de arquivos e validar a lógica de substituição de forma isolada.

2025-07-03 19:58:54,519 - HephaestusAgent - INFO - Gerando manifesto do projeto (AGENTS.md)...
2025-07-03 19:58:54,558 - HephaestusAgent - INFO - --- MANIFESTO GERADO (Tamanho: 11020 caracteres) ---
2025-07-03 19:58:54,558 - HephaestusAgent - INFO - 
Solicitando plano de ação do ArchitectAgent...
2025-07-03 19:58:54,558 - HephaestusAgent.ArchitectAgent - INFO - ArchitectAgent: Gerando plano de patches com os modelos: {'_target_': 'builtins.dict', 'temperature': 0.3, 'max_tokens': -1, 'primary': 'gemini/gemini-2.5-pro', 'fallback': 'deepseek/deepseek-r1-0528:free'}...
2025-07-03 19:58:54,558 - HephaestusAgent.ArchitectAgent - INFO - Calling primary model: gemini/gemini-2.5-pro
2025-07-03 19:58:54,558 - HephaestusAgent.ArchitectAgent - INFO - Attempting to call Gemini API with model: gemini/gemini-2.5-pro
2025-07-03 20:00:01,234 - HephaestusAgent.ArchitectAgent - DEBUG - Gemini API Response: ```json
{
  "analysis": "O plano de patch adiciona testes unitários para a função `_handle_replace` no arquivo `tests/agent/test_patch_applicator.py`. Como o conteúdo original do arquivo de teste não está disponível no manifesto (e o arquivo pode não existir), a estratégia adotada é criar ou substituir o arquivo inteiro utilizando a operação `REPLACE` com `block_to_replace: null`. O novo conteúdo inclui um teste plausível para `_handle_insert` (mencionado como já existente no objetivo) e dois novos testes para `_handle_replace`: um caso de sucesso e um caso de falha para índice fora dos limites. Isso garante que a lógica de substituição seja validada de forma isolada e robusta, utilizando mocks para o logger e o objeto Path, conforme as boas práticas de teste unitário e os requisitos do objetivo.",
  "patches_to_apply": [
    {
      "file_path": "tests/agent/test_patch_applicator.py",
      "operation": "REPLACE",
      "block_to_replace": null,
      "content": "import unittest\nfrom unittest.mock import MagicMock\nfrom pathlib import Path\nimport logging\n\nfrom agent.patch_applicator import _handle_insert, _handle_replace\n\nclass TestPatchApplicator(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up common test resources.\"\"\"\n        self.mock_logger = MagicMock(spec=logging.Logger)\n        self.mock_path = MagicMock(spec=Path)\n        self.mock_path.exists.return_value = True\n        self.mock_path.__str__.return_value = \"dummy/path.py\"\n\n    def test_handle_insert_success(self):\n        \"\"\"\n        Tests successful insertion of content.\n        \"\"\"\n        initial_lines = [\n            \"line 1\",\n            \"line 3\"\n        ]\n        instruction = {\n            \"file_path\": \"dummy/path.py\",\n            \"line_number\": 2,\n            \"content\": \"line 2\"\n        }\n        \n        success, updated_lines = _handle_insert(\n            self.mock_path, initial_lines, instruction, self.mock_logger\n        )\n\n        self.assertTrue(success)\n        expected_lines = [\n            \"line 1\",\n            \"line 2\",\n            \"line 3\"\n        ]\n        self.assertEqual(updated_lines, expected_lines)\n        self.mock_logger.info.assert_called_with(\"Applied INSERT patch to dummy/path.py at line 2\")\n\n    def test_handle_replace_success(self):\n        \"\"\"\n        Tests successful replacement of a block of lines.\n        \"\"\"\n        initial_lines = [\n            \"import os\",\n            \"def old_function():\",\n            \"    print('hello')\",\n            \"    return True\",\n            \"def another_function():\",\n            \"    pass\"\n        ]\n        instruction = {\n            \"file_path\": \"dummy/path.py\",\n            \"start_line\": 2,\n            \"end_line\": 4,\n            \"content\": \"def new_function(a, b):\\n    return a + b\"\n        }\n        \n        success, updated_lines = _handle_replace(\n            self.mock_path, initial_lines, instruction, self.mock_logger\n        )\n\n        self.assertTrue(success)\n        expected_lines = [\n            \"import os\",\n            \"def new_function(a, b):\",\n            \"    return a + b\",\n            \"def another_function():\",\n            \"    pass\"\n        ]\n        self.assertEqual(updated_lines, expected_lines)\n        self.mock_logger.info.assert_called_with(\"Applied REPLACE patch to dummy/path.py from line 2 to 4\")\n\n    def test_handle_replace_out_of_bounds(self):\n        \"\"\"\n        Tests that replacement fails if end_line is out of bounds.\n        \"\"\"\n        initial_lines = [\"line 1\", \"line 2\"]\n        instruction = {\n            \"file_path\": \"dummy/path.py\",\n            \"start_line\": 1,\n            \"end_line\": 5, # Out of bounds\n            \"content\": \"new content\"\n        }\n\n        success, updated_lines = _handle_replace(\n            self.mock_path, initial_lines, instruction, self.mock_logger\n        )\n\n        self.assertFalse(success)\n        self.assertEqual(updated_lines, initial_lines)\n        self.mock_logger.error.assert_called_with(\n            \"Error in REPLACE: end_line 5 is out of bounds for file dummy/path.py with 2 lines.\"\n        )\n\nif __name__ == '__main__':\n    unittest.main()\n"
    }
  ]
}
```
2025-07-03 20:00:01,234 - HephaestusAgent.ArchitectAgent - DEBUG - parse_json_response: Raw response before cleaning: ```json
{
  "analysis": "O plano de patch adiciona testes unitários para a função `_handle_replace` no arquivo `tests/agent/test_patch_applicator.py`. Como o conteúdo original do arquivo de teste não está disponível no manifesto (e o arquivo pode não existir), a estratégia adotada é criar ou substit...
2025-07-03 20:00:01,234 - HephaestusAgent.ArchitectAgent - DEBUG - parse_json_response: Extracted JSON content based on braces: {
  "analysis": "O plano de patch adiciona testes unitários para a função `_handle_replace` no arquivo `tests/agent/test_patch_applicator.py`. Como o conteúdo original do arquivo de teste não está disponível no manifesto (e o arquivo pode não existir), a estratégia adotada é criar ou substituir o ar...
2025-07-03 20:00:01,234 - HephaestusAgent.ArchitectAgent - DEBUG - parse_json_response: Final cleaned content before parsing: {
  "analysis": "O plano de patch adiciona testes unitários para a função `_handle_replace` no arquivo `tests/agent/test_patch_applicator.py`. Como o conteúdo original do arquivo de teste não está disponível no manifesto (e o arquivo pode não existir), a estratégia adotada é criar ou substituir o ar...
2025-07-03 20:00:01,234 - HephaestusAgent - INFO - --- PLANO DE AÇÃO (PATCHES) GERADO PELO ARCHITECTAGENT ({'_target_': 'builtins.dict', 'temperature': 0.3, 'max_tokens': -1, 'primary': 'gemini/gemini-2.5-pro', 'fallback': 'deepseek/deepseek-r1-0528:free'}) ---
2025-07-03 20:00:01,234 - HephaestusAgent - DEBUG - Análise do Arquiteto: O plano de patch adiciona testes unitários para a função `_handle_replace` no arquivo `tests/agent/test_patch_applicator.py`. Como o conteúdo original do arquivo de teste não está disponível no manifesto (e o arquivo pode não existir), a estratégia adotada é criar ou substituir o arquivo inteiro utilizando a operação `REPLACE` com `block_to_replace: null`. O novo conteúdo inclui um teste plausível para `_handle_insert` (mencionado como já existente no objetivo) e dois novos testes para `_handle_replace`: um caso de sucesso e um caso de falha para índice fora dos limites. Isso garante que a lógica de substituição seja validada de forma isolada e robusta, utilizando mocks para o logger e o objeto Path, conforme as boas práticas de teste unitário e os requisitos do objetivo.
2025-07-03 20:00:01,235 - HephaestusAgent - DEBUG - Patches: [
  {
    "file_path": "tests/agent/test_patch_applicator.py",
    "operation": "REPLACE",
    "block_to_replace": null,
    "content": "import unittest\nfrom unittest.mock import MagicMock\nfrom pathlib import Path\nimport logging\n\nfrom agent.patch_applicator import _handle_insert, _handle_replace\n\nclass TestPatchApplicator(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up common test resources.\"\"\"\n        self.mock_logger = MagicMock(spec=logging.Logger)\n        self.mock_path = MagicMock(spec=Path)\n        self.mock_path.exists.return_value = True\n        self.mock_path.__str__.return_value = \"dummy/path.py\"\n\n    def test_handle_insert_success(self):\n        \"\"\"\n        Tests successful insertion of content.\n        \"\"\"\n        initial_lines = [\n            \"line 1\",\n            \"line 3\"\n        ]\n        instruction = {\n            \"file_path\": \"dummy/path.py\",\n            \"line_number\": 2,\n            \"content\": \"line 2\"\n        }\n        \n        success, updated_lines = _handle_insert(\n            self.mock_path, initial_lines, instruction, self.mock_logger\n        )\n\n        self.assertTrue(success)\n        expected_lines = [\n            \"line 1\",\n            \"line 2\",\n            \"line 3\"\n        ]\n        self.assertEqual(updated_lines, expected_lines)\n        self.mock_logger.info.assert_called_with(\"Applied INSERT patch to dummy/path.py at line 2\")\n\n    def test_handle_replace_success(self):\n        \"\"\"\n        Tests successful replacement of a block of lines.\n        \"\"\"\n        initial_lines = [\n            \"import os\",\n            \"def old_function():\",\n            \"    print('hello')\",\n            \"    return True\",\n            \"def another_function():\",\n            \"    pass\"\n        ]\n        instruction = {\n            \"file_path\": \"dummy/path.py\",\n            \"start_line\": 2,\n            \"end_line\": 4,\n            \"content\": \"def new_function(a, b):\\n    return a + b\"\n        }\n        \n        success, updated_lines = _handle_replace(\n            self.mock_path, initial_lines, instruction, self.mock_logger\n        )\n\n        self.assertTrue(success)\n        expected_lines = [\n            \"import os\",\n            \"def new_function(a, b):\",\n            \"    return a + b\",\n            \"def another_function():\",\n            \"    pass\"\n        ]\n        self.assertEqual(updated_lines, expected_lines)\n        self.mock_logger.info.assert_called_with(\"Applied REPLACE patch to dummy/path.py from line 2 to 4\")\n\n    def test_handle_replace_out_of_bounds(self):\n        \"\"\"\n        Tests that replacement fails if end_line is out of bounds.\n        \"\"\"\n        initial_lines = [\"line 1\", \"line 2\"]\n        instruction = {\n            \"file_path\": \"dummy/path.py\",\n            \"start_line\": 1,\n            \"end_line\": 5, # Out of bounds\n            \"content\": \"new content\"\n        }\n\n        success, updated_lines = _handle_replace(\n            self.mock_path, initial_lines, instruction, self.mock_logger\n        )\n\n        self.assertFalse(success)\n        self.assertEqual(updated_lines, initial_lines)\n        self.mock_logger.error.assert_called_with(\n            \"Error in REPLACE: end_line 5 is out of bounds for file dummy/path.py with 2 lines.\"\n        )\n\nif __name__ == '__main__':\n    unittest.main()\n"
  }
]
2025-07-03 20:00:01,235 - HephaestusAgent - INFO - 
Solicitando decisão do MaestroAgent...
2025-07-03 20:00:01,235 - HephaestusAgent.MaestroAgent - INFO - MaestroAgent: Tentando decisão com os modelos: {'_target_': 'builtins.dict', 'temperature': 0.3, 'max_tokens': -1, 'primary': 'gemini/gemini-2.5-pro', 'fallback': 'deepseek/deepseek-r1-0528:free'}...
2025-07-03 20:00:01,235 - HephaestusAgent.MaestroAgent - DEBUG - MaestroAgent: Prompt for decision:

[IDENTITY]
You are the Maestro of the Hephaestus agent. Your task is to analyze the Engineer's proposal (patch plan) and recent history to decide the best course of action.

[CONTEXT AND HISTORY]

[HISTÓRICO RECENTE (OBJETIVOS E ESTRATÉGIAS USADAS)]
Completed Objectives (most recent first):
- Objective: Dado que as tentativas de testar a função `run_cycles` (CC: 89) falharam repetidamente, a estratégia deve ser pivotar para um alvo crítico e complexo diferente para construir capacidade de teste. Crie o arquivo de teste `tests/agent/test_patch_applicator.py` e adicione um teste unitário inicial para a função auxiliar `_handle_insert`. Este teste deve usar `unittest.mock.patch` para simular as interações com o sistema de arquivos, validando a lógica de inserção de forma isolada e aumentando a cobertura de testes em um módulo vital (`apply_patches` CC: 65) que atualmente não possui testes.
  Strategy: CREATE_NEW_TEST_FILE_STRATEGY
  Outcome: Strategy 'CREATE_NEW_TEST_FILE_STRATEGY' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T22:58:33.581755+00:00
- Objective: Dado que as tentativas de testar a função `run_cycles` (CC: 89) com mocks falharam, indicando uma lacuna na capacidade de teste do agente, o próximo passo deve ser um objetivo de capacitação focado. Crie o arquivo de teste `tests/agent/test_memory.py` e adicione um teste unitário para uma função simples de escrita, como `save_to_log`. Este teste deve usar `unittest.mock.patch` para simular a interação com o sistema de arquivos (ex: `builtins.open`), validando a lógica da função de forma isolada e ensinando o agente a aplicar mocks com sucesso antes de tentar novamente em alvos mais complexos.
  Strategy: CREATE_NEW_TEST_FILE_STRATEGY
  Outcome: Strategy 'CREATE_NEW_TEST_FILE_STRATEGY' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T22:57:07.396027+00:00

Failed Objectives (most recent first):
- Objective: Dado o sucesso em criar o arquivo de teste para `cycle_runner`, o próximo passo é adicionar um teste de caracterização para a função `run_cycles` (CC: 89). Este teste deve usar `unittest.mock` para simular as dependências essenciais (como `AgentState` e `QueueManager`) e invocar a função, validando que ela pode ser executada em um cenário controlado sem erros, estabelecendo assim a base para testes de lógica mais detalhados e refatoração segura.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_qyaqjai0)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:41:06.299306+00:00
- Objective: Para iniciar a refatoração da função `run_cycles` (CC: 89), que é a mais complexa do projeto, extraia a lógica de inicialização do ciclo (criação do `AgentState` e logs iniciais) para uma nova função auxiliar privada dentro de `agent/cycle_runner.py`. Em seguida, adicione um teste unitário no arquivo `tests/agent/test_cycle_runner.py` que valide especificamente o comportamento desta nova função extraída, garantindo um progresso incremental e seguro.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_v22kn3j2)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:31:44.352659+00:00
Considere esse histórico em sua decisão. Evite repetir estratégias que falharam recentemente para objetivos semelhantes.


[ENGINEER'S PROPOSAL (PATCH PLAN)]
{
  "analysis": "O plano de patch adiciona testes unitários para a função `_handle_replace` no arquivo `tests/agent/test_patch_applicator.py`. Como o conteúdo original do arquivo de teste não está disponível no manifesto (e o arquivo pode não existir), a estratégia adotada é criar ou substituir o arquivo inteiro utilizando a operação `REPLACE` com `block_to_replace: null`. O novo conteúdo inclui um teste plausível para `_handle_insert` (mencionado como já existente no objetivo) e dois novos testes para `_handle_replace`: um caso de sucesso e um caso de falha para índice fora dos limites. Isso garante que a lógica de substituição seja validada de forma isolada e robusta, utilizando mocks para o logger e o objeto Path, conforme as boas práticas de teste unitário e os requisitos do objetivo.",
  "patches_to_apply": [
    {
      "file_path": "tests/agent/test_patch_applicator.py",
      "operation": "REPLACE",
      "block_to_replace": null,
      "content": "import unittest\nfrom unittest.mock import MagicMock\nfrom pathlib import Path\nimport logging\n\nfrom agent.patch_applicator import _handle_insert, _handle_replace\n\nclass TestPatchApplicator(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up common test resources.\"\"\"\n        self.mock_logger = MagicMock(spec=logging.Logger)\n        self.mock_path = MagicMock(spec=Path)\n        self.mock_path.exists.return_value = True\n        self.mock_path.__str__.return_value = \"dummy/path.py\"\n\n    def test_handle_insert_success(self):\n        \"\"\"\n        Tests successful insertion of content.\n        \"\"\"\n        initial_lines = [\n            \"line 1\",\n            \"line 3\"\n        ]\n        instruction = {\n            \"file_path\": \"dummy/path.py\",\n            \"line_number\": 2,\n            \"content\": \"line 2\"\n        }\n        \n        success, updated_lines = _handle_insert(\n            self.mock_path, initial_lines, instruction, self.mock_logger\n        )\n\n        self.assertTrue(success)\n        expected_lines = [\n            \"line 1\",\n            \"line 2\",\n            \"line 3\"\n        ]\n        self.assertEqual(updated_lines, expected_lines)\n        self.mock_logger.info.assert_called_with(\"Applied INSERT patch to dummy/path.py at line 2\")\n\n    def test_handle_replace_success(self):\n        \"\"\"\n        Tests successful replacement of a block of lines.\n        \"\"\"\n        initial_lines = [\n            \"import os\",\n            \"def old_function():\",\n            \"    print('hello')\",\n            \"    return True\",\n            \"def another_function():\",\n            \"    pass\"\n        ]\n        instruction = {\n            \"file_path\": \"dummy/path.py\",\n            \"start_line\": 2,\n            \"end_line\": 4,\n            \"content\": \"def new_function(a, b):\\n    return a + b\"\n        }\n        \n        success, updated_lines = _handle_replace(\n            self.mock_path, initial_lines, instruction, self.mock_logger\n        )\n\n        self.assertTrue(success)\n        expected_lines = [\n            \"import os\",\n            \"def new_function(a, b):\",\n            \"    return a + b\",\n            \"def another_function():\",\n            \"    pass\"\n        ]\n        self.assertEqual(updated_lines, expected_lines)\n        self.mock_logger.info.assert_called_with(\"Applied REPLACE patch to dummy/path.py from line 2 to 4\")\n\n    def test_handle_replace_out_of_bounds(self):\n        \"\"\"\n        Tests that replacement fails if end_line is out of bounds.\n        \"\"\"\n        initial_lines = [\"line 1\", \"line 2\"]\n        instruction = {\n            \"file_path\": \"dummy/path.py\",\n            \"start_line\": 1,\n            \"end_line\": 5, # Out of bounds\n            \"content\": \"new content\"\n        }\n\n        success, updated_lines = _handle_replace(\n            self.mock_path, initial_lines, instruction, self.mock_logger\n        )\n\n        self.assertFalse(success)\n        self.assertEqual(updated_lines, initial_lines)\n        self.mock_logger.error.assert_called_with(\n            \"Error in REPLACE: end_line 5 is out of bounds for file dummy/path.py with 2 lines.\"\n        )\n\nif __name__ == '__main__':\n    unittest.main()\n"
    }
  ]
}

[YOUR DECISION]
Based on the proposal and history:
1. If the solution seems reasonable and does not require new capabilities, choose the most appropriate validation strategy.
2. If the solution requires new capabilities that Hephaestus needs to develop, respond with `CAPACITATION_REQUIRED`.

Available Validation Strategies: SYNTAX_ONLY, BENCHMARK_ONLY, SYNTAX_AND_PYTEST, FULL_VALIDATION, DOC_UPDATE_STRATEGY, CONFIG_UPDATE_STRATEGY, DISCARD, TEST_FIX_STRATEGY, CREATE_NEW_TEST_FILE_STRATEGY, AUTO_CORRECTION_STRATEGY
Additional Option: CAPACITATION_REQUIRED

[REQUIRED OUTPUT FORMAT]
Respond ONLY with a JSON object containing the "strategy_key" and the value being ONE of the available strategies OR "CAPACITATION_REQUIRED".
Example: {"strategy_key": "sandbox_pytest_validation"}
Example: {"strategy_key": "CAPACITATION_REQUIRED"}

2025-07-03 20:00:01,235 - HephaestusAgent.MaestroAgent - INFO - Calling primary model: gemini/gemini-2.5-pro
2025-07-03 20:00:01,235 - HephaestusAgent.MaestroAgent - INFO - Attempting to call Gemini API with model: gemini/gemini-2.5-pro
2025-07-03 20:00:17,828 - HephaestusAgent.MaestroAgent - DEBUG - Gemini API Response: ```json
{
  "strategy_key": "SYNTAX_AND_PYTEST"
}
```
2025-07-03 20:00:17,829 - HephaestusAgent.MaestroAgent - DEBUG - parse_json_response: Raw response before cleaning: ```json
{
  "strategy_key": "SYNTAX_AND_PYTEST"
}
```...
2025-07-03 20:00:17,829 - HephaestusAgent.MaestroAgent - DEBUG - parse_json_response: Extracted JSON content based on braces: {
  "strategy_key": "SYNTAX_AND_PYTEST"
}...
2025-07-03 20:00:17,829 - HephaestusAgent.MaestroAgent - DEBUG - parse_json_response: Final cleaned content before parsing: {
  "strategy_key": "SYNTAX_AND_PYTEST"
}...
2025-07-03 20:00:17,829 - HephaestusAgent - INFO - Estratégia escolhida pelo MaestroAgent (primary: gemini/gemini-2.5-pro, fallback: deepseek/deepseek-r1-0528:free): SYNTAX_AND_PYTEST
2025-07-03 20:00:17,829 - HephaestusAgent - INFO - 
Executing strategy 'SYNTAX_AND_PYTEST' with steps: ['validate_syntax', 'run_pytest', 'PatchApplicatorStep']
2025-07-03 20:00:17,829 - HephaestusAgent - INFO - Created temporary sandbox at: /tmp/hephaestus_sandbox_3t4lfmyb
2025-07-03 20:00:17,829 - HephaestusAgent - INFO - Copying project to sandbox: /tmp/hephaestus_sandbox_3t4lfmyb...
2025-07-03 20:00:17,839 - HephaestusAgent - INFO - Copy to sandbox complete.
2025-07-03 20:00:17,839 - HephaestusAgent - INFO - --- Validation/Execution Step: validate_syntax ---
2025-07-03 20:00:17,839 - HephaestusAgent - INFO - Starting syntax validation in: /tmp/hephaestus_sandbox_3t4lfmyb
2025-07-03 20:00:17,839 - HephaestusAgent - DEBUG - Validating syntax of: /tmp/hephaestus_sandbox_3t4lfmyb/tests/agent/test_patch_applicator.py
2025-07-03 20:00:17,839 - HephaestusAgent - DEBUG - Validando sintaxe Python de: /tmp/hephaestus_sandbox_3t4lfmyb/tests/agent/test_patch_applicator.py
2025-07-03 20:00:17,840 - HephaestusAgent - DEBUG - Sintaxe Python de '/tmp/hephaestus_sandbox_3t4lfmyb/tests/agent/test_patch_applicator.py' é válida.
2025-07-03 20:00:17,840 - HephaestusAgent - DEBUG - Realizando análise profunda para '/tmp/hephaestus_sandbox_3t4lfmyb/tests/agent/test_patch_applicator.py'...
2025-07-03 20:00:17,840 - HephaestusAgent - INFO - Iniciando validação profunda para: /tmp/hephaestus_sandbox_3t4lfmyb/tests/agent/test_patch_applicator.py
2025-07-03 20:00:17,842 - HephaestusAgent - INFO - Relatório de Qualidade para /tmp/hephaestus_sandbox_3t4lfmyb/tests/agent/test_patch_applicator.py: Score = 100.00
2025-07-03 20:00:17,842 - HephaestusAgent - INFO -   Complexidade Ciclomática Geral: 11
2025-07-03 20:00:17,842 - HephaestusAgent - INFO -   LLOC: 39, Comentários: 15
2025-07-03 20:00:17,842 - HephaestusAgent - INFO - Análise profunda para '/tmp/hephaestus_sandbox_3t4lfmyb/tests/agent/test_patch_applicator.py' concluída. Score: 100.0
2025-07-03 20:00:17,842 - HephaestusAgent - INFO - Syntax validation in '/tmp/hephaestus_sandbox_3t4lfmyb': SUCCESS.
2025-07-03 20:00:17,842 - HephaestusAgent - INFO - --- Validation/Execution Step: run_pytest ---
2025-07-03 20:00:17,842 - HephaestusAgent - INFO - Executing Pytest in: /tmp/hephaestus_sandbox_3t4lfmyb...
2025-07-03 20:00:20,087 - HephaestusAgent - INFO - Pytest validation in '/tmp/hephaestus_sandbox_3t4lfmyb': SUCCESS.
2025-07-03 20:00:20,087 - HephaestusAgent - INFO - --- Validation/Execution Step: PatchApplicatorStep ---
2025-07-03 20:00:20,087 - HephaestusAgent - INFO - Applying 1 patches in '/tmp/hephaestus_sandbox_3t4lfmyb'...
2025-07-03 20:00:20,087 - HephaestusAgent - INFO - Aplicando patches com base_path: '/tmp/hephaestus_sandbox_3t4lfmyb'
2025-07-03 20:00:20,088 - HephaestusAgent - INFO - Processando patch 1/1: REPLACE em '/tmp/hephaestus_sandbox_3t4lfmyb/tests/agent/test_patch_applicator.py'
2025-07-03 20:00:20,088 - HephaestusAgent - INFO - REPLACE sem 'block_to_replace' para '/tmp/hephaestus_sandbox_3t4lfmyb/tests/agent/test_patch_applicator.py'. Arquivo será sobrescrito.
2025-07-03 20:00:20,088 - HephaestusAgent - INFO - Arquivo '/tmp/hephaestus_sandbox_3t4lfmyb/tests/agent/test_patch_applicator.py' salvo após operação 'REPLACE'.
2025-07-03 20:00:20,088 - HephaestusAgent - INFO - Todas as 1 instruções de patch processadas. Arquivos afetados (tentativas): {'/tmp/hephaestus_sandbox_3t4lfmyb/tests/agent/test_patch_applicator.py'}
2025-07-03 20:00:20,088 - HephaestusAgent - INFO - Patches applied successfully in '/tmp/hephaestus_sandbox_3t4lfmyb'.
2025-07-03 20:00:20,088 - HephaestusAgent - INFO - Cleaning up temporary sandbox: /tmp/hephaestus_sandbox_3t4lfmyb
2025-07-03 20:00:20,108 - HephaestusAgent - INFO - Sandbox cleaned.
2025-07-03 20:00:20,108 - HephaestusAgent - INFO - 
SUCESSO NA VALIDAÇÃO/APLICAÇÃO! Razão: VALIDATION_SUCCESS_NO_CHANGES
2025-07-03 20:00:20,108 - HephaestusAgent - INFO - Ciclo concluído com status: VALIDATION_SUCCESS_NO_CHANGES. Nenhuma alteração no código foi promovida. Gerando próximo objetivo evolutivo...
2025-07-03 20:00:20,108 - HephaestusAgent - INFO - Generating next objective...
2025-07-03 20:00:20,109 - HephaestusAgent - INFO - CAPABILITIES.md lido com sucesso.
2025-07-03 20:00:20,109 - HephaestusAgent - INFO - ROADMAP.md lido com sucesso.
2025-07-03 20:00:20,109 - HephaestusAgent - INFO - Analyzing code metrics in: .
2025-07-03 20:00:20,362 - HephaestusAgent - DEBUG - Code analysis summary:
Large Files (potential candidates for modularization):
  - agent/brain.py (LOC: 357)
  - agent/code_metrics.py (LOC: 362)
  - agent/hephaestus_agent.py (LOC: 369)
  - agent/patch_applicator.py (LOC: 697)
  - agent/cycle_runner.py (LOC: 485)
  - agent/project_scanner.py (LOC: 462)

Large Functions (potential candidates for refactoring/splitting):
  - agent/brain.py -> generate_next_objective() (LOC: 162)
  - agent/brain.py -> generate_capacitation_objective() (LOC: 59)
  - agent/brain.py -> generate_commit_message() (LOC: 98)
  - agent/code_metrics.py -> analyze_complexity() (LOC: 84)
  - agent/code_metrics.py -> calculate_quality_score() (LOC: 89)
  - agent/code_metrics.py -> detect_code_duplication() (LOC: 126)
  - agent/git_utils.py -> initialize_git_repository() (LOC: 208)
  - agent/patch_applicator.py -> _handle_replace() (LOC: 71)
  - agent/patch_applicator.py -> _handle_delete_block() (LOC: 78)
  - agent/patch_applicator.py -> apply_patches() (LOC: 285)
  - agent/cycle_runner.py -> run_cycles() (LOC: 460)
  - agent/prompt_builder.py -> build_meta_analysis_objective_prompt() (LOC: 62)
  - agent/prompt_builder.py -> build_standard_objective_prompt() (LOC: 100)
  - agent/project_scanner.py -> update_project_manifest() (LOC: 188)
  - agent/project_scanner.py -> analyze_code_metrics() (LOC: 208)
  - agent/config_loader.py -> load_config() (LOC: 53)
  - agent/utils/json_parser.py -> parse_json_response() (LOC: 75)

Complex Functions (high CC, potential candidates for refactoring/simplification):
  - agent/brain.py -> generate_next_objective() (CC: 43)
  - agent/brain.py -> generate_commit_message() (CC: 15)
  - agent/code_metrics.py -> analyze_complexity() (CC: 15)
  - agent/code_metrics.py -> calculate_quality_score() (CC: 23)
  - agent/code_metrics.py -> detect_code_duplication() (CC: 20)
  - agent/git_utils.py -> initialize_git_repository() (CC: 14)
  - agent/patch_applicator.py -> _handle_replace() (CC: 15)
  - agent/patch_applicator.py -> _handle_delete_block() (CC: 21)
  - agent/patch_applicator.py -> apply_patches() (CC: 65)
  - agent/cycle_runner.py -> run_cycles() (CC: 89)
  - agent/project_scanner.py -> update_project_manifest() (CC: 45)
  - agent/project_scanner.py -> analyze_code_metrics() (CC: 47)
  - agent/utils/json_parser.py -> parse_json_response() (CC: 25)

Modules without Corresponding Test Files (consider creating tests):
  - cli.py
  - app.py
  - run_agent.py
  - agent/brain.py
  - agent/code_metrics.py
  - agent/hephaestus_agent.py
  - agent/git_utils.py
  - agent/code_validator.py
  - agent/patch_applicator.py
  - agent/cycle_runner.py
  - agent/memory.py
  - agent/prompt_builder.py
  - agent/tool_executor.py
  - agent/project_scanner.py
  - agent/state.py
  - agent/config_loader.py
  - agent/validation_steps/pytest_validator.py
  - agent/validation_steps/__init__.py
  - agent/validation_steps/base.py
  - agent/validation_steps/patch_applicator.py
  - agent/validation_steps/syntax_validator.py
  - agent/validation_steps/pytest_new_file_validator.py
  - agent/agents/architect_agent.py
  - agent/agents/performance_analyzer.py
  - agent/agents/error_correction.py
  - agent/agents/maestro_agent.py
  - agent/agents/error_analyzer.py
  - agent/utils/json_parser.py
  - agent/utils/llm_client.py
2025-07-03 20:00:20,362 - HephaestusAgent - INFO - Analyzing performance log...
2025-07-03 20:00:20,368 - HephaestusAgent - DEBUG - Performance analysis summary:
Performance Summary:
- Total Cycles: 7
- Successful Cycles: 4
- Failed Cycles: 3
- Success Rate: 57.14%
- Average Cycle Duration: N/A

Performance by Strategy (sorted by failures):
- Strategy 'SYNTAX_AND_PYTEST': Success Rate: 0.00% (Failures: 3/3)
- Strategy 'CREATE_NEW_TEST_FILE_STRATEGY': Success Rate: 100.00% (Failures: 0/4)

2025-07-03 20:00:20,368 - HephaestusAgent - DEBUG - Prompt for generate_next_objective:

[Main Context]
You are the 'Planejador Estratégico Avançado' do agente autônomo Hephaestus. Sua principal responsabilidade é identificar e propor o próximo objetivo de desenvolvimento mais impactante para a evolução do agente ou do projeto em análise.

[Decision Process for the Next Objective]
1.  **Analyze Performance:** Review the `[PERFORMANCE ANALYSIS]` section.
2.  **Analyze Code Metrics:** Review the `[CODE METRICS AND ANALYSIS]` section.
3.  **Consider Strategic Documents:** Review `[CAPABILITIES DOCUMENT]` and `[ROADMAP DOCUMENT]` to understand current capabilities, desired future states, and strategic direction. Identify gaps or next steps.
4.  **Consider the Project Manifest:** If the `[CURRENT PROJECT MANIFEST]` is provided, use it for context.
5.  **Review Recent History:** The `[HISTÓRICO RECENTE DO PROJETO E DO AGENTE]` section provides context.
6.  **Prioritize RSI:** Focus on objectives that enhance the agent's ability to self-improve, improve its core logic, prompts, or strategies.
7.  **Prioritize Capabilities & Roadmap:** Generate objectives that fill gaps in `[CAPABILITIES DOCUMENT]` or advance items in `[ROADMAP DOCUMENT]`.
8.  **Prioritize Structural and Quality Improvements:** Based on metrics and strategic documents.
9.  **Be Specific and Actionable:** The objective should be clear, concise, and indicate a concrete action.

1.  **Analyze Performance:** Review the `[PERFORMANCE ANALYSIS]` section to understand the agent's overall success rate and identify trends, especially focusing on strategies with high failure rates.
2.  **Analyze Code Metrics:** Review the `[CODE METRICS AND ANALYSIS]` section below. It contains data on file size (LOC), function size (LOC), cyclomatic complexity (CC) of functions, and modules that may be missing tests.
3.  **Consider the Project Manifest:** If the `[CURRENT PROJECT MANIFEST]` is provided, use it to understand the overall goals, architecture, and areas already documented or needing attention.
4.  **Review Recent History:** The `[HISTÓRICO RECENTE DO PROJETO E DO AGENTE]` section provides context on recent tasks, successes, and failures. Avoid repeating objectives that recently failed in the same way, unless the cause of failure has been resolved. Use history to build on successes.
5.  **Prioritize Structural and Quality Improvements:** Based on metrics, identify opportunities to:
    *   Refactor very large modules or very long/complex functions.
    *   Create tests for critical/complex modules or functions that lack them.
    *   Improve documentation (docstrings, manifest) where crucial.
    *   Propose the creation of new capabilities (new agents, tools) if the analysis indicates a strategic need.
6.  **Prioritize Prompt and Strategy Optimization (RSI Focus):** If the performance analysis reveals strategies with consistently low success rates, consider objectives to:
    *   Refine the prompts used by agents (e.g., Architect, Maestro, ErrorAnalysis) for those failing strategies.
    *   Propose new or modified validation strategies in `hephaestus_config.json` to address specific failure patterns.
7.  **Be Specific and Actionable:** The objective should be clear, concise, and indicate a concrete action.


[HISTÓRICO RECENTE DO PROJETO E DO AGENTE]
Completed Objectives (most recent first):
- Objective: Dado o sucesso em criar o teste para a função `_handle_insert`, o próximo passo é continuar a construção da capacidade de teste no módulo `agent/patch_applicator.py` (CC: 65), que é crítico e complexo. Adicione um novo teste unitário ao arquivo `tests/agent/test_patch_applicator.py` para a função auxiliar `_handle_replace` (CC: 15), utilizando `unittest.mock.patch` para simular as interações com o sistema de arquivos e validar a lógica de substituição de forma isolada.
  Strategy: SYNTAX_AND_PYTEST
  Outcome: Strategy 'SYNTAX_AND_PYTEST' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T23:00:20.108938+00:00
- Objective: Dado que as tentativas de testar a função `run_cycles` (CC: 89) falharam repetidamente, a estratégia deve ser pivotar para um alvo crítico e complexo diferente para construir capacidade de teste. Crie o arquivo de teste `tests/agent/test_patch_applicator.py` e adicione um teste unitário inicial para a função auxiliar `_handle_insert`. Este teste deve usar `unittest.mock.patch` para simular as interações com o sistema de arquivos, validando a lógica de inserção de forma isolada e aumentando a cobertura de testes em um módulo vital (`apply_patches` CC: 65) que atualmente não possui testes.
  Strategy: CREATE_NEW_TEST_FILE_STRATEGY
  Outcome: Strategy 'CREATE_NEW_TEST_FILE_STRATEGY' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T22:58:33.581755+00:00

Failed Objectives (most recent first):
- Objective: Dado o sucesso em criar o arquivo de teste para `cycle_runner`, o próximo passo é adicionar um teste de caracterização para a função `run_cycles` (CC: 89). Este teste deve usar `unittest.mock` para simular as dependências essenciais (como `AgentState` e `QueueManager`) e invocar a função, validando que ela pode ser executada em um cenário controlado sem erros, estabelecendo assim a base para testes de lógica mais detalhados e refatoração segura.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_qyaqjai0)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:41:06.299306+00:00
- Objective: Para iniciar a refatoração da função `run_cycles` (CC: 89), que é a mais complexa do projeto, extraia a lógica de inicialização do ciclo (criação do `AgentState` e logs iniciais) para uma nova função auxiliar privada dentro de `agent/cycle_runner.py`. Em seguida, adicione um teste unitário no arquivo `tests/agent/test_cycle_runner.py` que valide especificamente o comportamento desta nova função extraída, garantindo um progresso incremental e seguro.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_v22kn3j2)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:31:44.352659+00:00
Consider this history to avoid repeating failures, build on successes, and identify gaps.


[PERFORMANCE ANALYSIS]
Performance Summary:
- Total Cycles: 7
- Successful Cycles: 4
- Failed Cycles: 3
- Success Rate: 57.14%
- Average Cycle Duration: N/A

Performance by Strategy (sorted by failures):
- Strategy 'SYNTAX_AND_PYTEST': Success Rate: 0.00% (Failures: 3/3)
- Strategy 'CREATE_NEW_TEST_FILE_STRATEGY': Success Rate: 100.00% (Failures: 0/4)


[CODE METRICS AND ANALYSIS]
Large Files (potential candidates for modularization):
  - agent/brain.py (LOC: 357)
  - agent/code_metrics.py (LOC: 362)
  - agent/hephaestus_agent.py (LOC: 369)
  - agent/patch_applicator.py (LOC: 697)
  - agent/cycle_runner.py (LOC: 485)
  - agent/project_scanner.py (LOC: 462)

Large Functions (potential candidates for refactoring/splitting):
  - agent/brain.py -> generate_next_objective() (LOC: 162)
  - agent/brain.py -> generate_capacitation_objective() (LOC: 59)
  - agent/brain.py -> generate_commit_message() (LOC: 98)
  - agent/code_metrics.py -> analyze_complexity() (LOC: 84)
  - agent/code_metrics.py -> calculate_quality_score() (LOC: 89)
  - agent/code_metrics.py -> detect_code_duplication() (LOC: 126)
  - agent/git_utils.py -> initialize_git_repository() (LOC: 208)
  - agent/patch_applicator.py -> _handle_replace() (LOC: 71)
  - agent/patch_applicator.py -> _handle_delete_block() (LOC: 78)
  - agent/patch_applicator.py -> apply_patches() (LOC: 285)
  - agent/cycle_runner.py -> run_cycles() (LOC: 460)
  - agent/prompt_builder.py -> build_meta_analysis_objective_prompt() (LOC: 62)
  - agent/prompt_builder.py -> build_standard_objective_prompt() (LOC: 100)
  - agent/project_scanner.py -> update_project_manifest() (LOC: 188)
  - agent/project_scanner.py -> analyze_code_metrics() (LOC: 208)
  - agent/config_loader.py -> load_config() (LOC: 53)
  - agent/utils/json_parser.py -> parse_json_response() (LOC: 75)

Complex Functions (high CC, potential candidates for refactoring/simplification):
  - agent/brain.py -> generate_next_objective() (CC: 43)
  - agent/brain.py -> generate_commit_message() (CC: 15)
  - agent/code_metrics.py -> analyze_complexity() (CC: 15)
  - agent/code_metrics.py -> calculate_quality_score() (CC: 23)
  - agent/code_metrics.py -> detect_code_duplication() (CC: 20)
  - agent/git_utils.py -> initialize_git_repository() (CC: 14)
  - agent/patch_applicator.py -> _handle_replace() (CC: 15)
  - agent/patch_applicator.py -> _handle_delete_block() (CC: 21)
  - agent/patch_applicator.py -> apply_patches() (CC: 65)
  - agent/cycle_runner.py -> run_cycles() (CC: 89)
  - agent/project_scanner.py -> update_project_manifest() (CC: 45)
  - agent/project_scanner.py -> analyze_code_metrics() (CC: 47)
  - agent/utils/json_parser.py -> parse_json_response() (CC: 25)

Modules without Corresponding Test Files (consider creating tests):
  - cli.py
  - app.py
  - run_agent.py
  - agent/brain.py
  - agent/code_metrics.py
  - agent/hephaestus_agent.py
  - agent/git_utils.py
  - agent/code_validator.py
  - agent/patch_applicator.py
  - agent/cycle_runner.py
  - agent/memory.py
  - agent/prompt_builder.py
  - agent/tool_executor.py
  - agent/project_scanner.py
  - agent/state.py
  - agent/config_loader.py
  - agent/validation_steps/pytest_validator.py
  - agent/validation_steps/__init__.py
  - agent/validation_steps/base.py
  - agent/validation_steps/patch_applicator.py
  - agent/validation_steps/syntax_validator.py
  - agent/validation_steps/pytest_new_file_validator.py
  - agent/agents/architect_agent.py
  - agent/agents/performance_analyzer.py
  - agent/agents/error_correction.py
  - agent/agents/maestro_agent.py
  - agent/agents/error_analyzer.py
  - agent/utils/json_parser.py
  - agent/utils/llm_client.py

[CAPABILITIES DOCUMENT (CAPABILITIES.md)]
# Manifesto de Capacidades do Hephaestus

Este documento descreve as capacidades atuais e desejadas do agente Hephaestus, servindo como um guia para o seu desenvolvimento e para a geração de objetivos estratégicos. O foco principal é o **Aprimoramento Auto Recursivo (RSI)**, onde o agente busca ativamente melhorar suas próprias funções e arquitetura.

---

## 1. Capacidades Atuais

### 1.1. Análise e Planejamento
- **Geração de Objetivos (`agent/brain.py`):**
  - Analisa métricas de código estático (complexidade, tamanho do arquivo/função, cobertura de testes).
  - Analisa o manifesto do projeto (`AGENTS.md`).
  - Gera um objetivo de desenvolvimento com base na análise.
  - **Agora considera a análise de performance (`evolution_log.csv`) para otimizar prompts e estratégias.**
- **Análise de Erros (`agent/agents/error_analyzer.py`):**
  - Classifica falhas (ex: erro de sintaxe, falha de teste).
  - Propõe um prompt de correção para o `ArchitectAgent`.
  - **Pode sugerir objetivos de meta-análise para questionar o objetivo ou a estratégia original.**
- **Planejamento de Patches (`agent/agents/architect_agent.py`):**
  - Recebe um objetivo e o manifesto do projeto.
  - Gera um plano de patches em formato JSON para modificar a base de código.
- **Seleção de Estratégia (`agent/agents/maestro_agent.py`):**
  - Analisa o plano de patches.
  - Escolhe uma estratégia de validação apropriada (ex: apenas sintaxe, sintaxe e testes).

### 1.2. Execução e Validação
- **Aplicação de Patches (`agent/patch_applicator.py`):**
  - Aplica as modificações de código propostas em um ambiente de sandbox.
- **Validação de Sintaxe (`agent/validation_steps/syntax_validator.py`):**
  - Verifica a sintaxe de arquivos Python e JSON.
- **Execução de Testes (`agent/validation_steps/pytest_validator.py`):**
  - Executa a suíte de testes `pytest` para validar as alterações.
- **Gerenciamento de Estado e Ciclo (`agent/state.py`, `agent/cycle_runner.py`):**
  - Orquestra o fluxo completo de um ciclo de evolução.
  - Mantém o estado do ciclo atual (objetivo, patches, resultado da validação).
  - **O `cycle_runner.py` agora interage com um `QueueManager` para processar objetivos de forma assíncrona.**

### 1.3. Memória e Versionamento
- **Memória Persistente (`agent/memory.py`):**
  - Registra o histórico de objetivos bem-sucedidos e falhos.
  - Fornece contexto histórico para as decisões dos agentes.
- **Versionamento com Git (`agent/git_utils.py`):**
  - Inicializa o repositório Git.
  - Realiza commits automáticos após a validação bem-sucedida das alterações.

### 1.4. Infraestrutura (Nova)
- **Servidor FastAPI (`app.py`):**
  - Executa o Hephaestus como um serviço em segundo plano.
  - Expõe endpoints para submissão de objetivos e verificação de status.
  - Gerencia um thread worker para processar objetivos da fila.
- **Gerenciamento de Fila (`agent/queue_manager.py`):**
  - Permite a comunicação assíncrona de objetivos entre o servidor e o worker do agente.
- **Carregamento de Configuração (`agent/config_loader.py`):**
  - Módulo dedicado para carregar a configuração do agente de forma centralizada.

---

## 2. Capacidades Desejadas (Roadmap RSI)

O desenvolvimento futuro deve focar em aprimorar a capacidade do agente de entender e melhorar a si mesmo.

### 2.1. Meta-Cognição e Análise de Performance
- **Análise de Performance do Agente:**
  - **Objetivo:** Desenvolver a capacidade de analisar o próprio log de evolução (`evolution_log.csv`) para identificar gargalos, estratégias ineficazes e padrões de falha.
  - **Status:** Implementado. O `PerformanceAnalysisAgent` agora fornece uma análise detalhada do `evolution_log.csv`, incluindo taxa de sucesso geral, taxa de sucesso por estratégia e tempo médio de ciclo. O `generate_next_objective` utiliza essa análise para informar a geração de objetivos.
- **Análise de Causa Raiz (Meta-Análise):**
  - **Objetivo:** Aprimorar o `ErrorAnalysisAgent` para que, diante de falhas repetidas, ele possa questionar a validade do objetivo ou da estratégia, em vez de apenas tentar corrigir o código.
  - **Status:** Iniciado. O `ErrorAnalysisAgent` agora pode sugerir objetivos de meta-análise, e o `generate_next_objective` em `agent/brain.py` foi aprimorado para detectar e processar esses objetivos, gerando um novo objetivo estratégico para abordar a causa raiz da falha.

### 2.2. Aprimoramento da Arquitetura e Estratégia
- **Estratégias de Validação Dinâmicas:**
  - **Objetivo:** Permitir que o `MaestroAgent` não apenas escolha, mas também proponha a criação de novas estratégias de validação com base no contexto da tarefa.
  - **Status:** Iniciado. O `generate_next_objective` agora inclui a otimização de prompts e estratégias como uma prioridade, permitindo que o agente proponha modificações em `hephaestus_config.json` ou refinamento de prompts existentes com base na análise de performance.
- **Refatoração Orientada a Capacidades:**
  - **Objetivo:** Garantir que os objetivos de refatoração estejam sempre ligados a um aprimoramento de capacidade, e não apenas à melhoria de métricas de código.
  - **Status:** Não iniciado. (A base para isso foi estabelecida com a meta-análise e otimização de prompts, mas a refatoração explícita orientada a capacidades ainda não foi implementada).

### 2.3. Expansão de Ferramentas
- **Auto-Aprimoramento de Ferramentas:**
  - **Objetivo:** Dar ao agente a capacidade de modificar e aprimorar suas próprias ferramentas (ex: `tool_executor.py`) quando uma tarefa falha devido a uma limitação da ferramenta.
  - **Status:** Não iniciado. (A meta-análise de falhas pode identificar a necessidade de aprimoramento de ferramentas, mas a implementação autônoma ainda não está presente).

- **Acesso e Raciocínio com Conhecimento Externo:**
  - **Objetivo:** Implementar uma ferramenta de busca na web (`web_search`) robusta, permitindo que o agente pesquise documentação de APIs, soluções para erros e novas bibliotecas para resolver problemas que estão além de seu conhecimento atual.
  - **Status:** Não iniciado.

- **Gerenciamento de Estratégias Dinâmicas:**
  - **Objetivo:** O `MaestroAgent` deve evoluir de um simples selecionador de estratégias para um arquiteto de estratégias. Ele deve ser capaz de propor, e até mesmo codificar, novas estratégias de validação em `hephaestus_config.json` com base nos requisitos de um objetivo.
  - **Status:** Iniciado. O `generate_next_objective` agora inclui a otimização de prompts e estratégias como uma prioridade, permitindo que o agente proponha modificações em `hephaestus_config.json` ou refinamento de prompts existentes com base na análise de performance.


[ROADMAP DOCUMENT (ROADMAP.md)]
# Roadmap de Evolução do Hephaestus

Este documento delineia a visão de alto nível para a evolução do Hephaestus como um agente de **Aprimoramento Auto Recursivo (RSI)**. Ele serve como um guia estratégico, enquanto o `CAPABILITIES.md` detalha os passos táticos.

---

## Fase 1: Consciência e Correção (Curto Prazo)

O foco desta fase é fazer com que o agente pare de executar tarefas cegamente e comece a entender seu próprio desempenho e a corrigir suas falhas de forma mais inteligente.

-   [x] **1. Análise de Performance:**
    -   **Visão:** O agente deve ser capaz de ler seu próprio log de performance (`evolution_log.csv`) e responder a perguntas como: "Qual é a minha taxa de sucesso?", "Quais estratégias falham mais?" e "Onde estou gastando mais tempo?".
    -   **Status:** Implementado. O `PerformanceAnalysisAgent` agora fornece uma análise detalhada do `evolution_log.csv`, incluindo taxa de sucesso geral, taxa de sucesso por estratégia e tempo médio de ciclo. O `generate_next_objective` utiliza essa análise para informar a geração de objetivos.

-   [x] **2. Meta-Análise de Falhas:**
    -   **Visão:** Quando uma tarefa falha repetidamente, o agente deve parar de tentar corrigir o código e, em vez disso, questionar o objetivo em si. Ele deve ser capaz de concluir: "Esta abordagem não está funcionando, preciso de uma nova estratégia ou de uma nova ferramenta".
    -   **Status:** Iniciado. O `ErrorAnalysisAgent` agora pode sugerir objetivos de meta-análise, e o `generate_next_objective` em `agent/brain.py` foi aprimorado para detectar e processar esses objetivos, gerando um novo objetivo estratégico para abordar a causa raiz da falha.

-   [ ] **3. Refatoração Orientada a Capacidades:**
    -   **Visão:** O agente só deve propor refatorações de código se elas estiverem diretamente ligadas a um objetivo de capacitação, como "preciso refatorar este módulo para conseguir implementar uma nova ferramenta de análise".
    -   **Status:** Não iniciado. (A base para isso foi estabelecida com a meta-análise e otimização de prompts, mas a refatoração explícita orientada a capacidades ainda não foi implementada).

---

## Fase 2: Expansão de Habilidades (Médio Prazo)

Com a consciência básica estabelecida, o foco se volta para a expansão proativa de suas próprias habilidades e ferramentas.

-   [ ] **1. Auto-Aprimoramento de Ferramentas:**
    -   **Visão:** O agente deve ser capaz de modificar suas próprias ferramentas (`tool_executor.py`, `validation_steps/`, etc.) quando encontrar uma limitação. Se uma validação é muito fraca ou uma ferramenta não tem um parâmetro necessário, ele deve ser capaz de adicioná-lo.
    -   **Status:** Não iniciado. (A meta-análise de falhas pode identificar a necessidade de aprimoramento de ferramentas, mas a implementação autônoma ainda não está presente).

-   [ ] **2. Acesso e Raciocínio com Conhecimento Externo:**
    -   **Visão:** Implementar uma ferramenta de busca na web (`web_search`) robusta, permitindo que o agente pesquise documentação de APIs, soluções para erros e novas bibliotecas para resolver problemas que estão além de seu conhecimento atual.
    -   **Status:** Não iniciado.

-   [x] **3. Gerenciamento de Estratégias Dinâmicas:**
    -   **Visão:** O `MaestroAgent` deve evoluir de um simples selecionador de estratégias para um arquiteto de estratégias. Ele deve ser capaz de propor, e até mesmo codificar, novas estratégias de validação em `hephaestus_config.json` com base nos requisitos de um objetivo.
    -   **Status:** Iniciado. O `generate_next_objective` agora inclui a otimização de prompts e estratégias como uma prioridade, permitindo que o agente proponha modificações em `hephaestus_config.json` ou refinamento de prompts existentes com base na análise de performance.

---

## Fase 3: Autonomia Estratégica (Longo Prazo)

Nesta fase, o agente transcende a execução de ciclos e começa a gerenciar seu próprio desenvolvimento de forma estratégica.

-   [ ] **1. Planejamento de Longo Prazo:**
    -   **Visão:** O agente deve ser capaz de analisar este próprio `ROADMAP.md` e o `CAPABILITIES.md` para gerar um plano de desenvolvimento de múltiplos passos para si mesmo, em vez de operar em um ciclo de objetivo único.
    -   **Status:** Não iniciado.

-   [ ] **2. Auto-Otimização de Modelos:**
    -   **Visão:** Capturar os prompts e as respostas de maior sucesso para criar conjuntos de dados de fine-tuning. O objetivo final é treinar versões especializadas dos modelos de LLM que sejam mais eficientes e precisas para as tarefas do Hephaestus.
    -   **Status:** Não iniciado.

-   [ ] **3. Arquitetura de Agentes Dinâmica:**
    -   **Visão:** O agente deve ser capaz de propor e implementar mudanças em sua própria arquitetura de agentes, como criar um novo agente especializado (ex: `DocumentationAgent`) ou dividir as responsabilidades de um agente existente, para melhorar a eficiência do sistema.
    -   **Status:** Não iniciado.

---

## Arquitetura de Servidor (Novo)

-   [x] **1. Transformação em Servidor FastAPI:**
    -   **Visão:** O Hephaestus opera como um servidor em segundo plano, permitindo a submissão assíncrona de objetivos e monitoramento de status via API.
    -   **Status:** Implementado. O `main.py` agora inicia um servidor FastAPI, e o agente é executado em um thread worker separado, utilizando um `QueueManager` para gerenciar os objetivos.



[CURRENT PROJECT MANIFEST (if existing)]
# MANIFESTO DO PROJETO HEPHAESTUS

## 1. ESTRUTURA DE ARQUIVOS (OTIMIZADA)
agente_autonomo/
    README.md
    hephaestus.log
    cli.py
    AGENTS.md
    poetry.lock
    CONTRIBUTING.md
    app.py
    HEPHAESTUS_MEMORY.json
    main.py
    ROADMAP.md
    hephaestus_config.json
    requirements.txt
    run_agent.py
    MANIFESTO.md
    evolution_log.csv
    CODE_OF_CONDUCT.md
    ANALISE_PERFORMANCE_HEPHAESTUS.md
    ISSUES.md
    ANALISE_TECNICA_HEPHAESTUS.md
    Sugestões de Melhoria para o Projeto Agente Autônomo.md
    CAPABILITIES.md
    pyproject.toml
    agent/
        brain.py
        __init__.py
        code_metrics.py
        hephaestus_agent.py
        git_utils.py
        code_validator.py
        patch_applicator.py
        cycle_runner.py
        memory.py
        prompt_builder.py
        tool_executor.py
        project_scanner.py
        queue_manager.py
        state.py
        config_loader.py
        validation_steps/
            pytest_validator.py
            __init__.py
            base.py
            patch_applicator.py
            syntax_validator.py
            pytest_new_file_validator.py
        agents/
            __init__.py
            architect_agent.py
            performance_analyzer.py
            error_correction.py
            maestro_agent.py
            error_analyzer.py
        utils/
            __init__.py
            json_parser.py
            llm_client.py
    config/
        example_config.yaml
        base_config.yaml
        default.yaml
        models/
            main.yaml
        validation_strategies/
            main.yaml

## 2. RESUMO DAS INTERFACES (APIs Internas)

### Arquivo: `cli.py`
- **Função:** `run(continuous: bool=typer.Option(False, '--continuous', '-c', help='Run in continuous mode'), max_cycles: int=typer.Option(None, '--max-cycles', '-m', help='Maximum number of evolution cycles'))`
  - *Run the Hephaestus agent*
- **Função:** `submit(objective: str)`
  - *Submit a new objective to the agent*
- **Função:** `status()`
  - *Check agent status*

### Arquivo: `app.py`
- **Classe:** `Objective(BaseModel)`
- **Função:** `startup_event()`
- **Função:** `submit_objective(obj: Objective)`
- **Função:** `get_status()`

### Arquivo: `main.py`

### Arquivo: `run_agent.py`

### Arquivo: `agent/brain.py`
- **Função:** `generate_next_objective(model_config: Dict[str, str], current_manifest: str, logger: logging.Logger, project_root_dir: str, config: Optional[Dict[str, Any]]=None, memory_summary: Optional[str]=None, current_objective: Optional[str]=None)`
  - *Generates the next evolutionary objective using a lightweight model and code analysis.*
- **Função:** `generate_capacitation_objective(model_config: Dict[str, str], engineer_analysis: str, memory_summary: Optional[str]=None, logger: Optional[logging.Logger]=None)`
  - *Generates an objective to create necessary new capabilities.*
- **Função:** `generate_commit_message(model_config: Dict[str, str], analysis_summary: str, objective: str, logger: logging.Logger)`
  - *Generates a concise and informative commit message using an LLM.*

### Arquivo: `agent/__init__.py`

### Arquivo: `agent/code_metrics.py`
- **Função:** `analyze_complexity(code_string: str)`
  - *Analyzes the cyclomatic complexity and other metrics of the given Python code string using Radon.*
- **Função:** `calculate_quality_score(complexity_report: dict, duplication_report: list)`
  - *Calculates a quality score based on complexity, duplication, and other code metrics.*
- **Função:** `_get_code_lines(code_string: str, strip_comments_blanks: bool=True)`
  - *Returns a list of (original_line_number, line_content) tuples.*
- **Função:** `_find_duplicates_for_block(block_to_check: list[str], all_lines: list[tuple[int, str]], start_index: int, min_lines: int)`
  - *Finds occurrences of block_to_check in all_lines, starting after start_index.*
- **Função:** `detect_code_duplication(code_string: str, min_lines: int=4, strip_comments_and_blanks: bool=True)`
  - *Detects duplicated code blocks in the given Python code string.*

### Arquivo: `agent/hephaestus_agent.py`
- **Classe:** `HephaestusAgent`
  - *Classe principal que encapsula a lógica do agente autônomo.*

### Arquivo: `agent/git_utils.py`
- **Função:** `initialize_git_repository(logger: logging.Logger)`
  - *Ensure a git repository exists and is configured.*

### Arquivo: `agent/code_validator.py`
- **Função:** `perform_deep_validation(file_path: Path, logger: logging.Logger)`
  - *Realiza uma análise profunda da qualidade do código Python.*
- **Função:** `validate_python_code(file_path: str | Path, logger: logging.Logger, perform_deep_analysis: bool=True)`
  - *Valida se o código Python em um arquivo é sintaticamente correto e, opcionalmente, realiza uma análise profunda.*
- **Função:** `validate_json_syntax(file_path: str | Path, logger: logging.Logger)`
  - *Valida se um arquivo contém JSON válido.*

### Arquivo: `agent/patch_applicator.py`
- **Função:** `_handle_insert(full_path: Path, lines: list[str], instruction: dict, logger: logging.Logger)`
  - *Apply an INSERT patch and return ``(success, updated_lines)``.*
- **Função:** `_handle_replace(full_path: Path, lines: list[str], instruction: dict, logger: logging.Logger)`
  - *Apply a REPLACE patch.*
- **Função:** `_handle_delete_block(full_path: Path, lines: list[str], instruction: dict, logger: logging.Logger)`
  - *Apply a DELETE_BLOCK patch.*
- **Função:** `apply_patches(instructions: list[dict], logger: logging.Logger, base_path: str='.')`
  - *Aplica uma lista de instruções de patch aos arquivos.*

### Arquivo: `agent/cycle_runner.py`
- **Função:** `run_cycles(agent: 'HephaestusAgent', queue_manager: QueueManager)`
  - *Execute the main evolution loop for the given agent.*

### Arquivo: `agent/memory.py`
- **Classe:** `Memory`
  - *Manages persistent memory for the Hephaestus agent, storing historical data*

### Arquivo: `agent/prompt_builder.py`
- **Função:** `build_memory_context_section(memory_summary: Optional[str])`
  - *Constrói a seção de contexto da memória para os prompts.*
- **Função:** `build_initial_objective_prompt(memory_context_section: str)`
  - *Constrói o prompt para gerar o objetivo inicial quando não há manifesto ou análise de código.*
- **Função:** `build_meta_analysis_objective_prompt(current_objective: str, original_failed_objective: str, error_reason_for_meta: str, performance_summary_str: str, memory_context_section: str, capabilities_content: str, roadmap_content: str)`
  - *Constrói o prompt para gerar um objetivo estratégico após uma meta-análise de falha.*
- **Função:** `build_standard_objective_prompt(memory_context_section: str, performance_summary_str: str, code_analysis_summary_str: str, current_manifest: str, capabilities_content: str, roadmap_content: str)`
  - *Constrói o prompt padrão para gerar o próximo objetivo estratégico.*

### Arquivo: `agent/tool_executor.py`
- **Função:** `run_pytest(test_dir: str='tests/', cwd: str | Path | None=None)`
  - *Executa testes pytest no diretório especificado e retorna resultados.*
- **Função:** `check_file_existence(file_paths: list[str])`
  - *Verifica se todos os arquivos especificados existem.*
- **Função:** `run_in_sandbox(temp_dir_path: str, objective: str)`
  - *Executa o main.py de um diretório isolado monitorando tempo e memória.*
- **Função:** `run_git_command(command: list[str])`
  - *Executa um comando Git e retorna o status e a saída.*
- **Função:** `web_search(query: str)`
  - *Realiza uma pesquisa na web usando a API DuckDuckGo e retorna os resultados.*

### Arquivo: `agent/project_scanner.py`
- **Função:** `_extract_elements(code_string: str)`
- **Função:** `_extract_skeleton(code_string: str)`
- **Função:** `update_project_manifest(root_dir: str, target_files: List[str], output_path: str='AGENTS.md', excluded_dir_patterns: Optional[List[str]]=None)`
- **Função:** `analyze_code_metrics(root_dir: str, excluded_dir_patterns: Optional[List[str]]=None, file_loc_threshold: int=300, func_loc_threshold: int=50, func_cc_threshold: int=10)`
  - *Analisa arquivos Python em um diretório para métricas de código como LOC e Complexidade Ciclomática.*

### Arquivo: `agent/queue_manager.py`
- **Classe:** `QueueManager`

### Arquivo: `agent/state.py`
- **Classe:** `AgentState`
  - *Representa o estado interno do agente Hephaestus durante um ciclo de processamento.*

### Arquivo: `agent/config_loader.py`
- **Função:** `load_config()`
  - *Load configuration using Hydra.*

### Arquivo: `agent/validation_steps/pytest_validator.py`
- **Classe:** `PytestValidator(ValidationStep)`
  - *Runs pytest as a validation step.*

### Arquivo: `agent/validation_steps/__init__.py`
- **Classe:** `BenchmarkValidator(ValidationStep)`
- **Classe:** `CheckFileExistenceValidator(ValidationStep)`
- **Classe:** `ValidateJsonSyntax(ValidationStep)`
- **Função:** `get_validation_step(name: str)`

### Arquivo: `agent/validation_steps/base.py`
- **Classe:** `ValidationStep(ABC)`
  - *Abstract base class for a validation step.*

### Arquivo: `agent/validation_steps/patch_applicator.py`
- **Classe:** `PatchApplicatorStep(ValidationStep)`
  - *Applies patches to the specified base path.*

### Arquivo: `agent/validation_steps/syntax_validator.py`
- **Classe:** `SyntaxValidator(ValidationStep)`
  - *Validates the syntax of Python and JSON files.*

### Arquivo: `agent/validation_steps/pytest_new_file_validator.py`
- **Classe:** `PytestNewFileValidator(ValidationStep)`
  - *A validation step that runs pytest specifically on newly created test files.*

### Arquivo: `agent/agents/__init__.py`

### Arquivo: `agent/agents/architect_agent.py`
- **Classe:** `ArchitectAgent`

### Arquivo: `agent/agents/performance_analyzer.py`
- **Classe:** `PerformanceAnalysisAgent`
  - *An agent dedicated to analyzing the performance of Hephaestus.*

### Arquivo: `agent/agents/error_correction.py`
- **Classe:** `ErrorCorrectionAgent`
  - *Agent for analyzing errors and generating corrective actions.*

### Arquivo: `agent/agents/maestro_agent.py`
- **Classe:** `MaestroAgent`

### Arquivo: `agent/agents/error_analyzer.py`
- **Classe:** `ErrorAnalysisAgent`

### Arquivo: `agent/utils/__init__.py`

### Arquivo: `agent/utils/json_parser.py`
- **Função:** `parse_json_response(raw_str: str, logger: logging.Logger)`
  - *Analisa uma string bruta que se espera conter JSON, limpando-a e decodificando-a.*

### Arquivo: `agent/utils/llm_client.py`
- **Função:** `call_gemini_api(model: str, prompt: str, temperature: float, max_tokens: Optional[int], logger: logging.Logger)`
  - *Calls the Google Gemini API.*
- **Função:** `call_openrouter_api(model: str, prompt: str, temperature: float, max_tokens: Optional[int], logger: logging.Logger)`
  - *Calls a generic OpenAI-compatible API (like OpenRouter).*
- **Função:** `call_llm_with_fallback(model_config: Dict[str, Any], prompt: str, temperature: float, logger: logging.Logger)`
  - *Orchestrates LLM calls with a primary and fallback model.*

## 3. CONTEÚDO COMPLETO DOS ARQUIVOS ALVO


[Examples of Smart and Self-Aware Objectives]
*   **Performance-Based Objectives:**
    *   "The agent's success rate is low. Analyze the `evolution_log.csv` to identify the most common causes of failure and propose a solution."
    *   "Given the high number of failed cycles, implement a more robust error analysis mechanism in `error_analyzer.py`."
*   **Prompt/Strategy Optimization Objectives (RSI Focus):**
    *   "The 'SYNTAX_ONLY' strategy has a high failure rate. Analyze the prompts used by the ArchitectAgent when this strategy is chosen and propose modifications to improve syntax correctness."
    *   "Propose a new validation strategy in `hephaestus_config.json` called 'ADVANCED_LINTING' that includes `ruff` checks before applying patches, to reduce syntax errors."
    *   "Analyze the `MaestroAgent`'s decision-making process for objectives related to documentation updates, as the 'DOC_UPDATE_STRATEGY' has a low success rate. Refine its prompt to improve accuracy."
*   **Metrics-Based Refactoring:**
    *   "Refactor the module `agent/brain.py` (LOC: 350) which is extensive, considering splitting responsibilities into smaller modules (e.g., `agent/prompt_builder.py` or `agent/analysis_processor.py`)."
    *   "The function `generate_next_objective` in `agent/brain.py` (LOC: 85, CC: 12) is long and complex. Propose a plan to refactor it into smaller, more focused functions."
    *   "Analyze the most complex functions (CC > 10) listed in the metrics and select one for refactoring."
*   **Test Creation (Generate New Test Files):**
    *   "The module `agent/project_scanner.py` is missing a test file. Create a new test file `tests/agent/test_project_scanner.py` with basic unit tests for the `analyze_code_metrics` function."
    *   "Module `agent/memory.py` lacks tests. Generate `tests/agent/test_memory.py` and include placeholder tests for its public functions."
    *   "Create unit tests for the module `agent/tool_executor.py` in a new file `tests/agent/test_tool_executor.py`, focusing on the `web_search` function."
    *   "The function `call_llm_api` in `agent/utils/llm_client.py` is critical. Ensure robust unit tests exist for it in `tests/agent/utils/test_llm_client.py`, covering success and failure cases. If the test file doesn't exist, create it."
*   **Test-Driven Development (TDD) Flow:**
    *   "The previous cycle successfully created a new test file `tests/agent/test_new_feature.py` which is now failing as expected. The next objective is to implement the minimal code in `agent/new_feature.py` required to make the tests in `tests/agent/test_new_feature.py` pass."
*   **Strategic Documentation Improvement:**
    *   "The manifest (`AGENTS.md`) does not describe the new metrics analysis functionality in `project_scanner.py`. Update it."
    *   "Improve docstrings for public functions in the `agent/memory.py` module to detail parameters and expected behavior."
*   **Development of New Capabilities (Agents/Tools):**
    *   "Create a new agent (e.g., `CodeQualityAgent` in `agent/agents.py`) dedicated to continuously monitoring code quality metrics and reporting regressions."
    *   "Develop a new tool in `agent/tool_executor.py` to automatically validate the syntax of JSON files before processing."
    *   "Propose a system for Hephaestus to evaluate the performance of its own operations and identify bottlenecks."
*   **Generic Objectives (when metrics/manifest are insufficient):**
    *   "Analyze the `agent/state.py` module to identify potential improvements in clarity or efficiency."
    *   "Review recent logs for frequent errors and propose an objective to fix them."

[Your Task]
Based on ALL the information provided (metrics, manifest, history), generate ONLY a single text string containing the NEXT STRATEGIC OBJECTIVE. The objective should be the most impactful and logical for the project's evolution at this moment.
Be concise, but specific enough to be actionable.

2025-07-03 20:00:20,368 - HephaestusAgent - INFO - Calling primary model: gemini/gemini-2.5-pro
2025-07-03 20:00:20,368 - HephaestusAgent - INFO - Attempting to call Gemini API with model: gemini/gemini-2.5-pro
2025-07-03 20:00:51,160 - HephaestusAgent - DEBUG - Gemini API Response: Com base no sucesso contínuo em adicionar testes ao módulo `patch_applicator.py` e para continuar a aumentar a cobertura de teste em um dos módulos mais críticos e complexos (`apply_patches` CC: 65), o próximo passo é testar a última função auxiliar principal. Adicione um novo teste unitário ao arquivo `tests/agent/test_patch_applicator.py` para a função `_handle_delete_block` (CC: 21), que atualmente não possui testes. O teste deve validar a lógica de exclusão de bloco de forma isolada.
2025-07-03 20:00:51,162 - HephaestusAgent - INFO - Próximo objetivo: Com base no sucesso contínuo em adicionar testes ao módulo `patch_applicator.py` e para continuar a aumentar a cobertura de teste em um dos módulos mais críticos e complexos (`apply_patches` CC: 65), o próximo passo é testar a última função auxiliar principal. Adicione um novo teste unitário ao arquivo `tests/agent/test_patch_applicator.py` para a função `_handle_delete_block` (CC: 21), que atualmente não possui testes. O teste deve validar a lógica de exclusão de bloco de forma isolada.
2025-07-03 20:00:51,164 - HephaestusAgent - INFO - Memória salva em HEPHAESTUS_MEMORY.json (5 completed, 4 failed)
2025-07-03 20:00:51,165 - HephaestusAgent - INFO - ==================== FIM DO CICLO DE EVOLUÇÃO ====================
2025-07-03 20:00:52,165 - HephaestusAgent - INFO - 

==================== INÍCIO DO CICLO DE EVOLUÇÃO (Ciclo #4) ====================
2025-07-03 20:00:52,165 - HephaestusAgent - INFO - OBJETIVO ATUAL: Com base no sucesso contínuo em adicionar testes ao módulo `patch_applicator.py` e para continuar a aumentar a cobertura de teste em um dos módulos mais críticos e complexos (`apply_patches` CC: 65), o próximo passo é testar a última função auxiliar principal. Adicione um novo teste unitário ao arquivo `tests/agent/test_patch_applicator.py` para a função `_handle_delete_block` (CC: 21), que atualmente não possui testes. O teste deve validar a lógica de exclusão de bloco de forma isolada.

2025-07-03 20:00:52,166 - HephaestusAgent - INFO - Gerando manifesto do projeto (AGENTS.md)...
2025-07-03 20:00:52,219 - HephaestusAgent - INFO - --- MANIFESTO GERADO (Tamanho: 11020 caracteres) ---
2025-07-03 20:00:52,220 - HephaestusAgent - INFO - 
Solicitando plano de ação do ArchitectAgent...
2025-07-03 20:00:52,220 - HephaestusAgent.ArchitectAgent - INFO - ArchitectAgent: Gerando plano de patches com os modelos: {'_target_': 'builtins.dict', 'temperature': 0.3, 'max_tokens': -1, 'primary': 'gemini/gemini-2.5-pro', 'fallback': 'deepseek/deepseek-r1-0528:free'}...
2025-07-03 20:00:52,220 - HephaestusAgent.ArchitectAgent - INFO - Calling primary model: gemini/gemini-2.5-pro
2025-07-03 20:00:52,220 - HephaestusAgent.ArchitectAgent - INFO - Attempting to call Gemini API with model: gemini/gemini-2.5-pro
2025-07-03 20:02:17,157 - HephaestusAgent.ArchitectAgent - DEBUG - Gemini API Response: ```json
{
  "analysis": "O plano é adicionar testes unitários para a função `_handle_delete_block` no arquivo `tests/agent/test_patch_applicator.py`, conforme solicitado pelo objetivo. Isso aumentará a cobertura de teste de uma função crítica que atualmente não é testada. O plano consiste em uma única operação `INSERT` para adicionar três novas funções de teste ao final do arquivo existente. Os testes cobrirão o caso de sucesso (bloco encontrado e excluído), o caso de falha (bloco não encontrado) e um caso de borda (conteúdo do arquivo vazio). Esta abordagem assume que as importações necessárias (`logging`, `pathlib.Path`, e `_handle_delete_block` da `agent.patch_applicator`) já existem no arquivo de teste, o que é uma suposição razoável, dado que outros testes para o mesmo módulo já foram adicionados. A inserção será feita em um número de linha alto para garantir que o conteúdo seja anexado ao final do arquivo.",
  "patches_to_apply": [
    {
      "file_path": "tests/agent/test_patch_applicator.py",
      "operation": "INSERT",
      "line_number": 9999,
      "content": "\n\nimport logging\nfrom pathlib import Path\nfrom agent.patch_applicator import _handle_delete_block\n\ndef test_handle_delete_block_success():\n    \"\"\"\n    Tests that _handle_delete_block successfully removes a block of code.\n    \"\"\"\n    logger = logging.getLogger(\"test_logger\")\n    dummy_path = Path(\"dummy_file.py\")\n    lines_before = [\n        \"def function_a():\",\n        \"    print('hello')\",\n        \"\",\n        \"def function_to_delete():\",\n        \"    pass\",\n        \"\",\n        \"def function_b():\",\n        \"    print('world')\",\n    ]\n    instruction = {\n        \"block_to_delete\": \"def function_to_delete():\\n    pass\\n\"\n    }\n    expected_lines = [\n        \"def function_a():\",\n        \"    print('hello')\",\n        \"\",\n        \"def function_b():\",\n        \"    print('world')\",\n    ]\n\n    success, result_lines = _handle_delete_block(\n        full_path=dummy_path, lines=lines_before, instruction=instruction, logger=logger\n    )\n\n    assert success is True\n    assert result_lines == expected_lines\n\n\ndef test_handle_delete_block_not_found():\n    \"\"\"\n    Tests that _handle_delete_block returns False when the block is not found.\n    \"\"\"\n    logger = logging.getLogger(\"test_logger\")\n    dummy_path = Path(\"dummy_file.py\")\n    lines_before = [\n        \"def function_a():\",\n        \"    pass\",\n    ]\n    instruction = {\n        \"block_to_delete\": \"def non_existent_function():\\n    pass\\n\"\n    }\n\n    success, result_lines = _handle_delete_block(\n        full_path=dummy_path, lines=lines_before, instruction=instruction, logger=logger\n    )\n\n    assert success is False\n    assert result_lines == lines_before\n\n\ndef test_handle_delete_block_empty_content():\n    \"\"\"\n    Tests that _handle_delete_block handles an empty list of lines correctly.\n    \"\"\"\n    logger = logging.getLogger(\"test_logger\")\n    dummy_path = Path(\"dummy_file.py\")\n    lines_before = []\n    instruction = {\n        \"block_to_delete\": \"def any_function():\\n    pass\\n\"\n    }\n\n    success, result_lines = _handle_delete_block(\n        full_path=dummy_path, lines=lines_before, instruction=instruction, logger=logger\n    )\n\n    assert success is False\n    assert result_lines == []\n"
    }
  ]
}
```
2025-07-03 20:02:17,157 - HephaestusAgent.ArchitectAgent - DEBUG - parse_json_response: Raw response before cleaning: ```json
{
  "analysis": "O plano é adicionar testes unitários para a função `_handle_delete_block` no arquivo `tests/agent/test_patch_applicator.py`, conforme solicitado pelo objetivo. Isso aumentará a cobertura de teste de uma função crítica que atualmente não é testada. O plano consiste em uma úni...
2025-07-03 20:02:17,157 - HephaestusAgent.ArchitectAgent - DEBUG - parse_json_response: Extracted JSON content based on braces: {
  "analysis": "O plano é adicionar testes unitários para a função `_handle_delete_block` no arquivo `tests/agent/test_patch_applicator.py`, conforme solicitado pelo objetivo. Isso aumentará a cobertura de teste de uma função crítica que atualmente não é testada. O plano consiste em uma única opera...
2025-07-03 20:02:17,158 - HephaestusAgent.ArchitectAgent - DEBUG - parse_json_response: Final cleaned content before parsing: {
  "analysis": "O plano é adicionar testes unitários para a função `_handle_delete_block` no arquivo `tests/agent/test_patch_applicator.py`, conforme solicitado pelo objetivo. Isso aumentará a cobertura de teste de uma função crítica que atualmente não é testada. O plano consiste em uma única opera...
2025-07-03 20:02:17,158 - HephaestusAgent - INFO - --- PLANO DE AÇÃO (PATCHES) GERADO PELO ARCHITECTAGENT ({'_target_': 'builtins.dict', 'temperature': 0.3, 'max_tokens': -1, 'primary': 'gemini/gemini-2.5-pro', 'fallback': 'deepseek/deepseek-r1-0528:free'}) ---
2025-07-03 20:02:17,158 - HephaestusAgent - DEBUG - Análise do Arquiteto: O plano é adicionar testes unitários para a função `_handle_delete_block` no arquivo `tests/agent/test_patch_applicator.py`, conforme solicitado pelo objetivo. Isso aumentará a cobertura de teste de uma função crítica que atualmente não é testada. O plano consiste em uma única operação `INSERT` para adicionar três novas funções de teste ao final do arquivo existente. Os testes cobrirão o caso de sucesso (bloco encontrado e excluído), o caso de falha (bloco não encontrado) e um caso de borda (conteúdo do arquivo vazio). Esta abordagem assume que as importações necessárias (`logging`, `pathlib.Path`, e `_handle_delete_block` da `agent.patch_applicator`) já existem no arquivo de teste, o que é uma suposição razoável, dado que outros testes para o mesmo módulo já foram adicionados. A inserção será feita em um número de linha alto para garantir que o conteúdo seja anexado ao final do arquivo.
2025-07-03 20:02:17,158 - HephaestusAgent - DEBUG - Patches: [
  {
    "file_path": "tests/agent/test_patch_applicator.py",
    "operation": "INSERT",
    "line_number": 9999,
    "content": "\n\nimport logging\nfrom pathlib import Path\nfrom agent.patch_applicator import _handle_delete_block\n\ndef test_handle_delete_block_success():\n    \"\"\"\n    Tests that _handle_delete_block successfully removes a block of code.\n    \"\"\"\n    logger = logging.getLogger(\"test_logger\")\n    dummy_path = Path(\"dummy_file.py\")\n    lines_before = [\n        \"def function_a():\",\n        \"    print('hello')\",\n        \"\",\n        \"def function_to_delete():\",\n        \"    pass\",\n        \"\",\n        \"def function_b():\",\n        \"    print('world')\",\n    ]\n    instruction = {\n        \"block_to_delete\": \"def function_to_delete():\\n    pass\\n\"\n    }\n    expected_lines = [\n        \"def function_a():\",\n        \"    print('hello')\",\n        \"\",\n        \"def function_b():\",\n        \"    print('world')\",\n    ]\n\n    success, result_lines = _handle_delete_block(\n        full_path=dummy_path, lines=lines_before, instruction=instruction, logger=logger\n    )\n\n    assert success is True\n    assert result_lines == expected_lines\n\n\ndef test_handle_delete_block_not_found():\n    \"\"\"\n    Tests that _handle_delete_block returns False when the block is not found.\n    \"\"\"\n    logger = logging.getLogger(\"test_logger\")\n    dummy_path = Path(\"dummy_file.py\")\n    lines_before = [\n        \"def function_a():\",\n        \"    pass\",\n    ]\n    instruction = {\n        \"block_to_delete\": \"def non_existent_function():\\n    pass\\n\"\n    }\n\n    success, result_lines = _handle_delete_block(\n        full_path=dummy_path, lines=lines_before, instruction=instruction, logger=logger\n    )\n\n    assert success is False\n    assert result_lines == lines_before\n\n\ndef test_handle_delete_block_empty_content():\n    \"\"\"\n    Tests that _handle_delete_block handles an empty list of lines correctly.\n    \"\"\"\n    logger = logging.getLogger(\"test_logger\")\n    dummy_path = Path(\"dummy_file.py\")\n    lines_before = []\n    instruction = {\n        \"block_to_delete\": \"def any_function():\\n    pass\\n\"\n    }\n\n    success, result_lines = _handle_delete_block(\n        full_path=dummy_path, lines=lines_before, instruction=instruction, logger=logger\n    )\n\n    assert success is False\n    assert result_lines == []\n"
  }
]
2025-07-03 20:02:17,158 - HephaestusAgent - INFO - 
Solicitando decisão do MaestroAgent...
2025-07-03 20:02:17,158 - HephaestusAgent.MaestroAgent - INFO - MaestroAgent: Tentando decisão com os modelos: {'_target_': 'builtins.dict', 'temperature': 0.3, 'max_tokens': -1, 'primary': 'gemini/gemini-2.5-pro', 'fallback': 'deepseek/deepseek-r1-0528:free'}...
2025-07-03 20:02:17,159 - HephaestusAgent.MaestroAgent - DEBUG - MaestroAgent: Prompt for decision:

[IDENTITY]
You are the Maestro of the Hephaestus agent. Your task is to analyze the Engineer's proposal (patch plan) and recent history to decide the best course of action.

[CONTEXT AND HISTORY]

[HISTÓRICO RECENTE (OBJETIVOS E ESTRATÉGIAS USADAS)]
Completed Objectives (most recent first):
- Objective: Dado o sucesso em criar o teste para a função `_handle_insert`, o próximo passo é continuar a construção da capacidade de teste no módulo `agent/patch_applicator.py` (CC: 65), que é crítico e complexo. Adicione um novo teste unitário ao arquivo `tests/agent/test_patch_applicator.py` para a função auxiliar `_handle_replace` (CC: 15), utilizando `unittest.mock.patch` para simular as interações com o sistema de arquivos e validar a lógica de substituição de forma isolada.
  Strategy: SYNTAX_AND_PYTEST
  Outcome: Strategy 'SYNTAX_AND_PYTEST' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T23:00:20.108938+00:00
- Objective: Dado que as tentativas de testar a função `run_cycles` (CC: 89) falharam repetidamente, a estratégia deve ser pivotar para um alvo crítico e complexo diferente para construir capacidade de teste. Crie o arquivo de teste `tests/agent/test_patch_applicator.py` e adicione um teste unitário inicial para a função auxiliar `_handle_insert`. Este teste deve usar `unittest.mock.patch` para simular as interações com o sistema de arquivos, validando a lógica de inserção de forma isolada e aumentando a cobertura de testes em um módulo vital (`apply_patches` CC: 65) que atualmente não possui testes.
  Strategy: CREATE_NEW_TEST_FILE_STRATEGY
  Outcome: Strategy 'CREATE_NEW_TEST_FILE_STRATEGY' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T22:58:33.581755+00:00

Failed Objectives (most recent first):
- Objective: Dado o sucesso em criar o arquivo de teste para `cycle_runner`, o próximo passo é adicionar um teste de caracterização para a função `run_cycles` (CC: 89). Este teste deve usar `unittest.mock` para simular as dependências essenciais (como `AgentState` e `QueueManager`) e invocar a função, validando que ela pode ser executada em um cenário controlado sem erros, estabelecendo assim a base para testes de lógica mais detalhados e refatoração segura.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_qyaqjai0)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:41:06.299306+00:00
- Objective: Para iniciar a refatoração da função `run_cycles` (CC: 89), que é a mais complexa do projeto, extraia a lógica de inicialização do ciclo (criação do `AgentState` e logs iniciais) para uma nova função auxiliar privada dentro de `agent/cycle_runner.py`. Em seguida, adicione um teste unitário no arquivo `tests/agent/test_cycle_runner.py` que valide especificamente o comportamento desta nova função extraída, garantindo um progresso incremental e seguro.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_v22kn3j2)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:31:44.352659+00:00
Considere esse histórico em sua decisão. Evite repetir estratégias que falharam recentemente para objetivos semelhantes.


[ENGINEER'S PROPOSAL (PATCH PLAN)]
{
  "analysis": "O plano é adicionar testes unitários para a função `_handle_delete_block` no arquivo `tests/agent/test_patch_applicator.py`, conforme solicitado pelo objetivo. Isso aumentará a cobertura de teste de uma função crítica que atualmente não é testada. O plano consiste em uma única operação `INSERT` para adicionar três novas funções de teste ao final do arquivo existente. Os testes cobrirão o caso de sucesso (bloco encontrado e excluído), o caso de falha (bloco não encontrado) e um caso de borda (conteúdo do arquivo vazio). Esta abordagem assume que as importações necessárias (`logging`, `pathlib.Path`, e `_handle_delete_block` da `agent.patch_applicator`) já existem no arquivo de teste, o que é uma suposição razoável, dado que outros testes para o mesmo módulo já foram adicionados. A inserção será feita em um número de linha alto para garantir que o conteúdo seja anexado ao final do arquivo.",
  "patches_to_apply": [
    {
      "file_path": "tests/agent/test_patch_applicator.py",
      "operation": "INSERT",
      "line_number": 9999,
      "content": "\n\nimport logging\nfrom pathlib import Path\nfrom agent.patch_applicator import _handle_delete_block\n\ndef test_handle_delete_block_success():\n    \"\"\"\n    Tests that _handle_delete_block successfully removes a block of code.\n    \"\"\"\n    logger = logging.getLogger(\"test_logger\")\n    dummy_path = Path(\"dummy_file.py\")\n    lines_before = [\n        \"def function_a():\",\n        \"    print('hello')\",\n        \"\",\n        \"def function_to_delete():\",\n        \"    pass\",\n        \"\",\n        \"def function_b():\",\n        \"    print('world')\",\n    ]\n    instruction = {\n        \"block_to_delete\": \"def function_to_delete():\\n    pass\\n\"\n    }\n    expected_lines = [\n        \"def function_a():\",\n        \"    print('hello')\",\n        \"\",\n        \"def function_b():\",\n        \"    print('world')\",\n    ]\n\n    success, result_lines = _handle_delete_block(\n        full_path=dummy_path, lines=lines_before, instruction=instruction, logger=logger\n    )\n\n    assert success is True\n    assert result_lines == expected_lines\n\n\ndef test_handle_delete_block_not_found():\n    \"\"\"\n    Tests that _handle_delete_block returns False when the block is not found.\n    \"\"\"\n    logger = logging.getLogger(\"test_logger\")\n    dummy_path = Path(\"dummy_file.py\")\n    lines_before = [\n        \"def function_a():\",\n        \"    pass\",\n    ]\n    instruction = {\n        \"block_to_delete\": \"def non_existent_function():\\n    pass\\n\"\n    }\n\n    success, result_lines = _handle_delete_block(\n        full_path=dummy_path, lines=lines_before, instruction=instruction, logger=logger\n    )\n\n    assert success is False\n    assert result_lines == lines_before\n\n\ndef test_handle_delete_block_empty_content():\n    \"\"\"\n    Tests that _handle_delete_block handles an empty list of lines correctly.\n    \"\"\"\n    logger = logging.getLogger(\"test_logger\")\n    dummy_path = Path(\"dummy_file.py\")\n    lines_before = []\n    instruction = {\n        \"block_to_delete\": \"def any_function():\\n    pass\\n\"\n    }\n\n    success, result_lines = _handle_delete_block(\n        full_path=dummy_path, lines=lines_before, instruction=instruction, logger=logger\n    )\n\n    assert success is False\n    assert result_lines == []\n"
    }
  ]
}

[YOUR DECISION]
Based on the proposal and history:
1. If the solution seems reasonable and does not require new capabilities, choose the most appropriate validation strategy.
2. If the solution requires new capabilities that Hephaestus needs to develop, respond with `CAPACITATION_REQUIRED`.

Available Validation Strategies: SYNTAX_ONLY, BENCHMARK_ONLY, SYNTAX_AND_PYTEST, FULL_VALIDATION, DOC_UPDATE_STRATEGY, CONFIG_UPDATE_STRATEGY, DISCARD, TEST_FIX_STRATEGY, CREATE_NEW_TEST_FILE_STRATEGY, AUTO_CORRECTION_STRATEGY
Additional Option: CAPACITATION_REQUIRED

[REQUIRED OUTPUT FORMAT]
Respond ONLY with a JSON object containing the "strategy_key" and the value being ONE of the available strategies OR "CAPACITATION_REQUIRED".
Example: {"strategy_key": "sandbox_pytest_validation"}
Example: {"strategy_key": "CAPACITATION_REQUIRED"}

2025-07-03 20:02:17,159 - HephaestusAgent.MaestroAgent - INFO - Calling primary model: gemini/gemini-2.5-pro
2025-07-03 20:02:17,159 - HephaestusAgent.MaestroAgent - INFO - Attempting to call Gemini API with model: gemini/gemini-2.5-pro
2025-07-03 20:02:29,634 - HephaestusAgent.MaestroAgent - DEBUG - Gemini API Response: ```json
{
  "strategy_key": "SYNTAX_AND_PYTEST"
}
```
2025-07-03 20:02:29,634 - HephaestusAgent.MaestroAgent - DEBUG - parse_json_response: Raw response before cleaning: ```json
{
  "strategy_key": "SYNTAX_AND_PYTEST"
}
```...
2025-07-03 20:02:29,634 - HephaestusAgent.MaestroAgent - DEBUG - parse_json_response: Extracted JSON content based on braces: {
  "strategy_key": "SYNTAX_AND_PYTEST"
}...
2025-07-03 20:02:29,634 - HephaestusAgent.MaestroAgent - DEBUG - parse_json_response: Final cleaned content before parsing: {
  "strategy_key": "SYNTAX_AND_PYTEST"
}...
2025-07-03 20:02:29,635 - HephaestusAgent - INFO - Estratégia escolhida pelo MaestroAgent (primary: gemini/gemini-2.5-pro, fallback: deepseek/deepseek-r1-0528:free): SYNTAX_AND_PYTEST
2025-07-03 20:02:29,635 - HephaestusAgent - INFO - 
Executing strategy 'SYNTAX_AND_PYTEST' with steps: ['validate_syntax', 'run_pytest', 'PatchApplicatorStep']
2025-07-03 20:02:29,636 - HephaestusAgent - INFO - Created temporary sandbox at: /tmp/hephaestus_sandbox_7tvvqqt5
2025-07-03 20:02:29,636 - HephaestusAgent - INFO - Copying project to sandbox: /tmp/hephaestus_sandbox_7tvvqqt5...
2025-07-03 20:02:29,651 - HephaestusAgent - INFO - Copy to sandbox complete.
2025-07-03 20:02:29,652 - HephaestusAgent - INFO - --- Validation/Execution Step: validate_syntax ---
2025-07-03 20:02:29,652 - HephaestusAgent - INFO - Starting syntax validation in: /tmp/hephaestus_sandbox_7tvvqqt5
2025-07-03 20:02:29,652 - HephaestusAgent - DEBUG - Validating syntax of: /tmp/hephaestus_sandbox_7tvvqqt5/tests/agent/test_patch_applicator.py
2025-07-03 20:02:29,652 - HephaestusAgent - DEBUG - Validando sintaxe Python de: /tmp/hephaestus_sandbox_7tvvqqt5/tests/agent/test_patch_applicator.py
2025-07-03 20:02:29,652 - HephaestusAgent - DEBUG - Sintaxe Python de '/tmp/hephaestus_sandbox_7tvvqqt5/tests/agent/test_patch_applicator.py' é válida.
2025-07-03 20:02:29,652 - HephaestusAgent - DEBUG - Realizando análise profunda para '/tmp/hephaestus_sandbox_7tvvqqt5/tests/agent/test_patch_applicator.py'...
2025-07-03 20:02:29,652 - HephaestusAgent - INFO - Iniciando validação profunda para: /tmp/hephaestus_sandbox_7tvvqqt5/tests/agent/test_patch_applicator.py
2025-07-03 20:02:29,655 - HephaestusAgent - INFO - Relatório de Qualidade para /tmp/hephaestus_sandbox_7tvvqqt5/tests/agent/test_patch_applicator.py: Score = 100.00
2025-07-03 20:02:29,655 - HephaestusAgent - INFO -   Complexidade Ciclomática Geral: 11
2025-07-03 20:02:29,655 - HephaestusAgent - INFO -   LLOC: 39, Comentários: 15
2025-07-03 20:02:29,655 - HephaestusAgent - INFO - Análise profunda para '/tmp/hephaestus_sandbox_7tvvqqt5/tests/agent/test_patch_applicator.py' concluída. Score: 100.0
2025-07-03 20:02:29,655 - HephaestusAgent - INFO - Syntax validation in '/tmp/hephaestus_sandbox_7tvvqqt5': SUCCESS.
2025-07-03 20:02:29,655 - HephaestusAgent - INFO - --- Validation/Execution Step: run_pytest ---
2025-07-03 20:02:29,655 - HephaestusAgent - INFO - Executing Pytest in: /tmp/hephaestus_sandbox_7tvvqqt5...
2025-07-03 20:02:31,879 - HephaestusAgent - INFO - Pytest validation in '/tmp/hephaestus_sandbox_7tvvqqt5': SUCCESS.
2025-07-03 20:02:31,880 - HephaestusAgent - INFO - --- Validation/Execution Step: PatchApplicatorStep ---
2025-07-03 20:02:31,880 - HephaestusAgent - INFO - Applying 1 patches in '/tmp/hephaestus_sandbox_7tvvqqt5'...
2025-07-03 20:02:31,880 - HephaestusAgent - INFO - Aplicando patches com base_path: '/tmp/hephaestus_sandbox_7tvvqqt5'
2025-07-03 20:02:31,880 - HephaestusAgent - INFO - Processando patch 1/1: INSERT em '/tmp/hephaestus_sandbox_7tvvqqt5/tests/agent/test_patch_applicator.py'
2025-07-03 20:02:31,880 - HephaestusAgent - DEBUG - Conteúdo inserido em '/tmp/hephaestus_sandbox_7tvvqqt5/tests/agent/test_patch_applicator.py' na linha 9999.
2025-07-03 20:02:31,880 - HephaestusAgent - INFO - Arquivo '/tmp/hephaestus_sandbox_7tvvqqt5/tests/agent/test_patch_applicator.py' salvo após operação 'INSERT'.
2025-07-03 20:02:31,880 - HephaestusAgent - INFO - Todas as 1 instruções de patch processadas. Arquivos afetados (tentativas): {'/tmp/hephaestus_sandbox_7tvvqqt5/tests/agent/test_patch_applicator.py'}
2025-07-03 20:02:31,880 - HephaestusAgent - INFO - Patches applied successfully in '/tmp/hephaestus_sandbox_7tvvqqt5'.
2025-07-03 20:02:31,880 - HephaestusAgent - INFO - Cleaning up temporary sandbox: /tmp/hephaestus_sandbox_7tvvqqt5
2025-07-03 20:02:31,915 - HephaestusAgent - INFO - Sandbox cleaned.
2025-07-03 20:02:31,915 - HephaestusAgent - INFO - 
SUCESSO NA VALIDAÇÃO/APLICAÇÃO! Razão: VALIDATION_SUCCESS_NO_CHANGES
2025-07-03 20:02:31,915 - HephaestusAgent - INFO - Ciclo concluído com status: VALIDATION_SUCCESS_NO_CHANGES. Nenhuma alteração no código foi promovida. Gerando próximo objetivo evolutivo...
2025-07-03 20:02:31,915 - HephaestusAgent - INFO - Generating next objective...
2025-07-03 20:02:31,915 - HephaestusAgent - INFO - CAPABILITIES.md lido com sucesso.
2025-07-03 20:02:31,915 - HephaestusAgent - INFO - ROADMAP.md lido com sucesso.
2025-07-03 20:02:31,915 - HephaestusAgent - INFO - Analyzing code metrics in: .
2025-07-03 20:02:32,200 - HephaestusAgent - DEBUG - Code analysis summary:
Large Files (potential candidates for modularization):
  - agent/brain.py (LOC: 357)
  - agent/code_metrics.py (LOC: 362)
  - agent/hephaestus_agent.py (LOC: 369)
  - agent/patch_applicator.py (LOC: 697)
  - agent/cycle_runner.py (LOC: 485)
  - agent/project_scanner.py (LOC: 462)

Large Functions (potential candidates for refactoring/splitting):
  - agent/brain.py -> generate_next_objective() (LOC: 162)
  - agent/brain.py -> generate_capacitation_objective() (LOC: 59)
  - agent/brain.py -> generate_commit_message() (LOC: 98)
  - agent/code_metrics.py -> analyze_complexity() (LOC: 84)
  - agent/code_metrics.py -> calculate_quality_score() (LOC: 89)
  - agent/code_metrics.py -> detect_code_duplication() (LOC: 126)
  - agent/git_utils.py -> initialize_git_repository() (LOC: 208)
  - agent/patch_applicator.py -> _handle_replace() (LOC: 71)
  - agent/patch_applicator.py -> _handle_delete_block() (LOC: 78)
  - agent/patch_applicator.py -> apply_patches() (LOC: 285)
  - agent/cycle_runner.py -> run_cycles() (LOC: 460)
  - agent/prompt_builder.py -> build_meta_analysis_objective_prompt() (LOC: 62)
  - agent/prompt_builder.py -> build_standard_objective_prompt() (LOC: 100)
  - agent/project_scanner.py -> update_project_manifest() (LOC: 188)
  - agent/project_scanner.py -> analyze_code_metrics() (LOC: 208)
  - agent/config_loader.py -> load_config() (LOC: 53)
  - agent/utils/json_parser.py -> parse_json_response() (LOC: 75)

Complex Functions (high CC, potential candidates for refactoring/simplification):
  - agent/brain.py -> generate_next_objective() (CC: 43)
  - agent/brain.py -> generate_commit_message() (CC: 15)
  - agent/code_metrics.py -> analyze_complexity() (CC: 15)
  - agent/code_metrics.py -> calculate_quality_score() (CC: 23)
  - agent/code_metrics.py -> detect_code_duplication() (CC: 20)
  - agent/git_utils.py -> initialize_git_repository() (CC: 14)
  - agent/patch_applicator.py -> _handle_replace() (CC: 15)
  - agent/patch_applicator.py -> _handle_delete_block() (CC: 21)
  - agent/patch_applicator.py -> apply_patches() (CC: 65)
  - agent/cycle_runner.py -> run_cycles() (CC: 89)
  - agent/project_scanner.py -> update_project_manifest() (CC: 45)
  - agent/project_scanner.py -> analyze_code_metrics() (CC: 47)
  - agent/utils/json_parser.py -> parse_json_response() (CC: 25)

Modules without Corresponding Test Files (consider creating tests):
  - cli.py
  - app.py
  - run_agent.py
  - agent/brain.py
  - agent/code_metrics.py
  - agent/hephaestus_agent.py
  - agent/git_utils.py
  - agent/code_validator.py
  - agent/patch_applicator.py
  - agent/cycle_runner.py
  - agent/memory.py
  - agent/prompt_builder.py
  - agent/tool_executor.py
  - agent/project_scanner.py
  - agent/state.py
  - agent/config_loader.py
  - agent/validation_steps/pytest_validator.py
  - agent/validation_steps/__init__.py
  - agent/validation_steps/base.py
  - agent/validation_steps/patch_applicator.py
  - agent/validation_steps/syntax_validator.py
  - agent/validation_steps/pytest_new_file_validator.py
  - agent/agents/architect_agent.py
  - agent/agents/performance_analyzer.py
  - agent/agents/error_correction.py
  - agent/agents/maestro_agent.py
  - agent/agents/error_analyzer.py
  - agent/utils/json_parser.py
  - agent/utils/llm_client.py
2025-07-03 20:02:32,200 - HephaestusAgent - INFO - Analyzing performance log...
2025-07-03 20:02:32,204 - HephaestusAgent - DEBUG - Performance analysis summary:
Performance Summary:
- Total Cycles: 8
- Successful Cycles: 5
- Failed Cycles: 3
- Success Rate: 62.50%
- Average Cycle Duration: N/A

Performance by Strategy (sorted by failures):
- Strategy 'SYNTAX_AND_PYTEST': Success Rate: 25.00% (Failures: 3/4)
- Strategy 'CREATE_NEW_TEST_FILE_STRATEGY': Success Rate: 100.00% (Failures: 0/4)

2025-07-03 20:02:32,205 - HephaestusAgent - DEBUG - Prompt for generate_next_objective:

[Main Context]
You are the 'Planejador Estratégico Avançado' do agente autônomo Hephaestus. Sua principal responsabilidade é identificar e propor o próximo objetivo de desenvolvimento mais impactante para a evolução do agente ou do projeto em análise.

[Decision Process for the Next Objective]
1.  **Analyze Performance:** Review the `[PERFORMANCE ANALYSIS]` section.
2.  **Analyze Code Metrics:** Review the `[CODE METRICS AND ANALYSIS]` section.
3.  **Consider Strategic Documents:** Review `[CAPABILITIES DOCUMENT]` and `[ROADMAP DOCUMENT]` to understand current capabilities, desired future states, and strategic direction. Identify gaps or next steps.
4.  **Consider the Project Manifest:** If the `[CURRENT PROJECT MANIFEST]` is provided, use it for context.
5.  **Review Recent History:** The `[HISTÓRICO RECENTE DO PROJETO E DO AGENTE]` section provides context.
6.  **Prioritize RSI:** Focus on objectives that enhance the agent's ability to self-improve, improve its core logic, prompts, or strategies.
7.  **Prioritize Capabilities & Roadmap:** Generate objectives that fill gaps in `[CAPABILITIES DOCUMENT]` or advance items in `[ROADMAP DOCUMENT]`.
8.  **Prioritize Structural and Quality Improvements:** Based on metrics and strategic documents.
9.  **Be Specific and Actionable:** The objective should be clear, concise, and indicate a concrete action.

1.  **Analyze Performance:** Review the `[PERFORMANCE ANALYSIS]` section to understand the agent's overall success rate and identify trends, especially focusing on strategies with high failure rates.
2.  **Analyze Code Metrics:** Review the `[CODE METRICS AND ANALYSIS]` section below. It contains data on file size (LOC), function size (LOC), cyclomatic complexity (CC) of functions, and modules that may be missing tests.
3.  **Consider the Project Manifest:** If the `[CURRENT PROJECT MANIFEST]` is provided, use it to understand the overall goals, architecture, and areas already documented or needing attention.
4.  **Review Recent History:** The `[HISTÓRICO RECENTE DO PROJETO E DO AGENTE]` section provides context on recent tasks, successes, and failures. Avoid repeating objectives that recently failed in the same way, unless the cause of failure has been resolved. Use history to build on successes.
5.  **Prioritize Structural and Quality Improvements:** Based on metrics, identify opportunities to:
    *   Refactor very large modules or very long/complex functions.
    *   Create tests for critical/complex modules or functions that lack them.
    *   Improve documentation (docstrings, manifest) where crucial.
    *   Propose the creation of new capabilities (new agents, tools) if the analysis indicates a strategic need.
6.  **Prioritize Prompt and Strategy Optimization (RSI Focus):** If the performance analysis reveals strategies with consistently low success rates, consider objectives to:
    *   Refine the prompts used by agents (e.g., Architect, Maestro, ErrorAnalysis) for those failing strategies.
    *   Propose new or modified validation strategies in `hephaestus_config.json` to address specific failure patterns.
7.  **Be Specific and Actionable:** The objective should be clear, concise, and indicate a concrete action.


[HISTÓRICO RECENTE DO PROJETO E DO AGENTE]
Completed Objectives (most recent first):
- Objective: Com base no sucesso contínuo em adicionar testes ao módulo `patch_applicator.py` e para continuar a aumentar a cobertura de teste em um dos módulos mais críticos e complexos (`apply_patches` CC: 65), o próximo passo é testar a última função auxiliar principal. Adicione um novo teste unitário ao arquivo `tests/agent/test_patch_applicator.py` para a função `_handle_delete_block` (CC: 21), que atualmente não possui testes. O teste deve validar a lógica de exclusão de bloco de forma isolada.
  Strategy: SYNTAX_AND_PYTEST
  Outcome: Strategy 'SYNTAX_AND_PYTEST' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T23:02:31.915409+00:00
- Objective: Dado o sucesso em criar o teste para a função `_handle_insert`, o próximo passo é continuar a construção da capacidade de teste no módulo `agent/patch_applicator.py` (CC: 65), que é crítico e complexo. Adicione um novo teste unitário ao arquivo `tests/agent/test_patch_applicator.py` para a função auxiliar `_handle_replace` (CC: 15), utilizando `unittest.mock.patch` para simular as interações com o sistema de arquivos e validar a lógica de substituição de forma isolada.
  Strategy: SYNTAX_AND_PYTEST
  Outcome: Strategy 'SYNTAX_AND_PYTEST' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T23:00:20.108938+00:00

Failed Objectives (most recent first):
- Objective: Dado o sucesso em criar o arquivo de teste para `cycle_runner`, o próximo passo é adicionar um teste de caracterização para a função `run_cycles` (CC: 89). Este teste deve usar `unittest.mock` para simular as dependências essenciais (como `AgentState` e `QueueManager`) e invocar a função, validando que ela pode ser executada em um cenário controlado sem erros, estabelecendo assim a base para testes de lógica mais detalhados e refatoração segura.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_qyaqjai0)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:41:06.299306+00:00
- Objective: Para iniciar a refatoração da função `run_cycles` (CC: 89), que é a mais complexa do projeto, extraia a lógica de inicialização do ciclo (criação do `AgentState` e logs iniciais) para uma nova função auxiliar privada dentro de `agent/cycle_runner.py`. Em seguida, adicione um teste unitário no arquivo `tests/agent/test_cycle_runner.py` que valide especificamente o comportamento desta nova função extraída, garantindo um progresso incremental e seguro.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_v22kn3j2)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:31:44.352659+00:00
Consider this history to avoid repeating failures, build on successes, and identify gaps.


[PERFORMANCE ANALYSIS]
Performance Summary:
- Total Cycles: 8
- Successful Cycles: 5
- Failed Cycles: 3
- Success Rate: 62.50%
- Average Cycle Duration: N/A

Performance by Strategy (sorted by failures):
- Strategy 'SYNTAX_AND_PYTEST': Success Rate: 25.00% (Failures: 3/4)
- Strategy 'CREATE_NEW_TEST_FILE_STRATEGY': Success Rate: 100.00% (Failures: 0/4)


[CODE METRICS AND ANALYSIS]
Large Files (potential candidates for modularization):
  - agent/brain.py (LOC: 357)
  - agent/code_metrics.py (LOC: 362)
  - agent/hephaestus_agent.py (LOC: 369)
  - agent/patch_applicator.py (LOC: 697)
  - agent/cycle_runner.py (LOC: 485)
  - agent/project_scanner.py (LOC: 462)

Large Functions (potential candidates for refactoring/splitting):
  - agent/brain.py -> generate_next_objective() (LOC: 162)
  - agent/brain.py -> generate_capacitation_objective() (LOC: 59)
  - agent/brain.py -> generate_commit_message() (LOC: 98)
  - agent/code_metrics.py -> analyze_complexity() (LOC: 84)
  - agent/code_metrics.py -> calculate_quality_score() (LOC: 89)
  - agent/code_metrics.py -> detect_code_duplication() (LOC: 126)
  - agent/git_utils.py -> initialize_git_repository() (LOC: 208)
  - agent/patch_applicator.py -> _handle_replace() (LOC: 71)
  - agent/patch_applicator.py -> _handle_delete_block() (LOC: 78)
  - agent/patch_applicator.py -> apply_patches() (LOC: 285)
  - agent/cycle_runner.py -> run_cycles() (LOC: 460)
  - agent/prompt_builder.py -> build_meta_analysis_objective_prompt() (LOC: 62)
  - agent/prompt_builder.py -> build_standard_objective_prompt() (LOC: 100)
  - agent/project_scanner.py -> update_project_manifest() (LOC: 188)
  - agent/project_scanner.py -> analyze_code_metrics() (LOC: 208)
  - agent/config_loader.py -> load_config() (LOC: 53)
  - agent/utils/json_parser.py -> parse_json_response() (LOC: 75)

Complex Functions (high CC, potential candidates for refactoring/simplification):
  - agent/brain.py -> generate_next_objective() (CC: 43)
  - agent/brain.py -> generate_commit_message() (CC: 15)
  - agent/code_metrics.py -> analyze_complexity() (CC: 15)
  - agent/code_metrics.py -> calculate_quality_score() (CC: 23)
  - agent/code_metrics.py -> detect_code_duplication() (CC: 20)
  - agent/git_utils.py -> initialize_git_repository() (CC: 14)
  - agent/patch_applicator.py -> _handle_replace() (CC: 15)
  - agent/patch_applicator.py -> _handle_delete_block() (CC: 21)
  - agent/patch_applicator.py -> apply_patches() (CC: 65)
  - agent/cycle_runner.py -> run_cycles() (CC: 89)
  - agent/project_scanner.py -> update_project_manifest() (CC: 45)
  - agent/project_scanner.py -> analyze_code_metrics() (CC: 47)
  - agent/utils/json_parser.py -> parse_json_response() (CC: 25)

Modules without Corresponding Test Files (consider creating tests):
  - cli.py
  - app.py
  - run_agent.py
  - agent/brain.py
  - agent/code_metrics.py
  - agent/hephaestus_agent.py
  - agent/git_utils.py
  - agent/code_validator.py
  - agent/patch_applicator.py
  - agent/cycle_runner.py
  - agent/memory.py
  - agent/prompt_builder.py
  - agent/tool_executor.py
  - agent/project_scanner.py
  - agent/state.py
  - agent/config_loader.py
  - agent/validation_steps/pytest_validator.py
  - agent/validation_steps/__init__.py
  - agent/validation_steps/base.py
  - agent/validation_steps/patch_applicator.py
  - agent/validation_steps/syntax_validator.py
  - agent/validation_steps/pytest_new_file_validator.py
  - agent/agents/architect_agent.py
  - agent/agents/performance_analyzer.py
  - agent/agents/error_correction.py
  - agent/agents/maestro_agent.py
  - agent/agents/error_analyzer.py
  - agent/utils/json_parser.py
  - agent/utils/llm_client.py

[CAPABILITIES DOCUMENT (CAPABILITIES.md)]
# Manifesto de Capacidades do Hephaestus

Este documento descreve as capacidades atuais e desejadas do agente Hephaestus, servindo como um guia para o seu desenvolvimento e para a geração de objetivos estratégicos. O foco principal é o **Aprimoramento Auto Recursivo (RSI)**, onde o agente busca ativamente melhorar suas próprias funções e arquitetura.

---

## 1. Capacidades Atuais

### 1.1. Análise e Planejamento
- **Geração de Objetivos (`agent/brain.py`):**
  - Analisa métricas de código estático (complexidade, tamanho do arquivo/função, cobertura de testes).
  - Analisa o manifesto do projeto (`AGENTS.md`).
  - Gera um objetivo de desenvolvimento com base na análise.
  - **Agora considera a análise de performance (`evolution_log.csv`) para otimizar prompts e estratégias.**
- **Análise de Erros (`agent/agents/error_analyzer.py`):**
  - Classifica falhas (ex: erro de sintaxe, falha de teste).
  - Propõe um prompt de correção para o `ArchitectAgent`.
  - **Pode sugerir objetivos de meta-análise para questionar o objetivo ou a estratégia original.**
- **Planejamento de Patches (`agent/agents/architect_agent.py`):**
  - Recebe um objetivo e o manifesto do projeto.
  - Gera um plano de patches em formato JSON para modificar a base de código.
- **Seleção de Estratégia (`agent/agents/maestro_agent.py`):**
  - Analisa o plano de patches.
  - Escolhe uma estratégia de validação apropriada (ex: apenas sintaxe, sintaxe e testes).

### 1.2. Execução e Validação
- **Aplicação de Patches (`agent/patch_applicator.py`):**
  - Aplica as modificações de código propostas em um ambiente de sandbox.
- **Validação de Sintaxe (`agent/validation_steps/syntax_validator.py`):**
  - Verifica a sintaxe de arquivos Python e JSON.
- **Execução de Testes (`agent/validation_steps/pytest_validator.py`):**
  - Executa a suíte de testes `pytest` para validar as alterações.
- **Gerenciamento de Estado e Ciclo (`agent/state.py`, `agent/cycle_runner.py`):**
  - Orquestra o fluxo completo de um ciclo de evolução.
  - Mantém o estado do ciclo atual (objetivo, patches, resultado da validação).
  - **O `cycle_runner.py` agora interage com um `QueueManager` para processar objetivos de forma assíncrona.**

### 1.3. Memória e Versionamento
- **Memória Persistente (`agent/memory.py`):**
  - Registra o histórico de objetivos bem-sucedidos e falhos.
  - Fornece contexto histórico para as decisões dos agentes.
- **Versionamento com Git (`agent/git_utils.py`):**
  - Inicializa o repositório Git.
  - Realiza commits automáticos após a validação bem-sucedida das alterações.

### 1.4. Infraestrutura (Nova)
- **Servidor FastAPI (`app.py`):**
  - Executa o Hephaestus como um serviço em segundo plano.
  - Expõe endpoints para submissão de objetivos e verificação de status.
  - Gerencia um thread worker para processar objetivos da fila.
- **Gerenciamento de Fila (`agent/queue_manager.py`):**
  - Permite a comunicação assíncrona de objetivos entre o servidor e o worker do agente.
- **Carregamento de Configuração (`agent/config_loader.py`):**
  - Módulo dedicado para carregar a configuração do agente de forma centralizada.

---

## 2. Capacidades Desejadas (Roadmap RSI)

O desenvolvimento futuro deve focar em aprimorar a capacidade do agente de entender e melhorar a si mesmo.

### 2.1. Meta-Cognição e Análise de Performance
- **Análise de Performance do Agente:**
  - **Objetivo:** Desenvolver a capacidade de analisar o próprio log de evolução (`evolution_log.csv`) para identificar gargalos, estratégias ineficazes e padrões de falha.
  - **Status:** Implementado. O `PerformanceAnalysisAgent` agora fornece uma análise detalhada do `evolution_log.csv`, incluindo taxa de sucesso geral, taxa de sucesso por estratégia e tempo médio de ciclo. O `generate_next_objective` utiliza essa análise para informar a geração de objetivos.
- **Análise de Causa Raiz (Meta-Análise):**
  - **Objetivo:** Aprimorar o `ErrorAnalysisAgent` para que, diante de falhas repetidas, ele possa questionar a validade do objetivo ou da estratégia, em vez de apenas tentar corrigir o código.
  - **Status:** Iniciado. O `ErrorAnalysisAgent` agora pode sugerir objetivos de meta-análise, e o `generate_next_objective` em `agent/brain.py` foi aprimorado para detectar e processar esses objetivos, gerando um novo objetivo estratégico para abordar a causa raiz da falha.

### 2.2. Aprimoramento da Arquitetura e Estratégia
- **Estratégias de Validação Dinâmicas:**
  - **Objetivo:** Permitir que o `MaestroAgent` não apenas escolha, mas também proponha a criação de novas estratégias de validação com base no contexto da tarefa.
  - **Status:** Iniciado. O `generate_next_objective` agora inclui a otimização de prompts e estratégias como uma prioridade, permitindo que o agente proponha modificações em `hephaestus_config.json` ou refinamento de prompts existentes com base na análise de performance.
- **Refatoração Orientada a Capacidades:**
  - **Objetivo:** Garantir que os objetivos de refatoração estejam sempre ligados a um aprimoramento de capacidade, e não apenas à melhoria de métricas de código.
  - **Status:** Não iniciado. (A base para isso foi estabelecida com a meta-análise e otimização de prompts, mas a refatoração explícita orientada a capacidades ainda não foi implementada).

### 2.3. Expansão de Ferramentas
- **Auto-Aprimoramento de Ferramentas:**
  - **Objetivo:** Dar ao agente a capacidade de modificar e aprimorar suas próprias ferramentas (ex: `tool_executor.py`) quando uma tarefa falha devido a uma limitação da ferramenta.
  - **Status:** Não iniciado. (A meta-análise de falhas pode identificar a necessidade de aprimoramento de ferramentas, mas a implementação autônoma ainda não está presente).

- **Acesso e Raciocínio com Conhecimento Externo:**
  - **Objetivo:** Implementar uma ferramenta de busca na web (`web_search`) robusta, permitindo que o agente pesquise documentação de APIs, soluções para erros e novas bibliotecas para resolver problemas que estão além de seu conhecimento atual.
  - **Status:** Não iniciado.

- **Gerenciamento de Estratégias Dinâmicas:**
  - **Objetivo:** O `MaestroAgent` deve evoluir de um simples selecionador de estratégias para um arquiteto de estratégias. Ele deve ser capaz de propor, e até mesmo codificar, novas estratégias de validação em `hephaestus_config.json` com base nos requisitos de um objetivo.
  - **Status:** Iniciado. O `generate_next_objective` agora inclui a otimização de prompts e estratégias como uma prioridade, permitindo que o agente proponha modificações em `hephaestus_config.json` ou refinamento de prompts existentes com base na análise de performance.


[ROADMAP DOCUMENT (ROADMAP.md)]
# Roadmap de Evolução do Hephaestus

Este documento delineia a visão de alto nível para a evolução do Hephaestus como um agente de **Aprimoramento Auto Recursivo (RSI)**. Ele serve como um guia estratégico, enquanto o `CAPABILITIES.md` detalha os passos táticos.

---

## Fase 1: Consciência e Correção (Curto Prazo)

O foco desta fase é fazer com que o agente pare de executar tarefas cegamente e comece a entender seu próprio desempenho e a corrigir suas falhas de forma mais inteligente.

-   [x] **1. Análise de Performance:**
    -   **Visão:** O agente deve ser capaz de ler seu próprio log de performance (`evolution_log.csv`) e responder a perguntas como: "Qual é a minha taxa de sucesso?", "Quais estratégias falham mais?" e "Onde estou gastando mais tempo?".
    -   **Status:** Implementado. O `PerformanceAnalysisAgent` agora fornece uma análise detalhada do `evolution_log.csv`, incluindo taxa de sucesso geral, taxa de sucesso por estratégia e tempo médio de ciclo. O `generate_next_objective` utiliza essa análise para informar a geração de objetivos.

-   [x] **2. Meta-Análise de Falhas:**
    -   **Visão:** Quando uma tarefa falha repetidamente, o agente deve parar de tentar corrigir o código e, em vez disso, questionar o objetivo em si. Ele deve ser capaz de concluir: "Esta abordagem não está funcionando, preciso de uma nova estratégia ou de uma nova ferramenta".
    -   **Status:** Iniciado. O `ErrorAnalysisAgent` agora pode sugerir objetivos de meta-análise, e o `generate_next_objective` em `agent/brain.py` foi aprimorado para detectar e processar esses objetivos, gerando um novo objetivo estratégico para abordar a causa raiz da falha.

-   [ ] **3. Refatoração Orientada a Capacidades:**
    -   **Visão:** O agente só deve propor refatorações de código se elas estiverem diretamente ligadas a um objetivo de capacitação, como "preciso refatorar este módulo para conseguir implementar uma nova ferramenta de análise".
    -   **Status:** Não iniciado. (A base para isso foi estabelecida com a meta-análise e otimização de prompts, mas a refatoração explícita orientada a capacidades ainda não foi implementada).

---

## Fase 2: Expansão de Habilidades (Médio Prazo)

Com a consciência básica estabelecida, o foco se volta para a expansão proativa de suas próprias habilidades e ferramentas.

-   [ ] **1. Auto-Aprimoramento de Ferramentas:**
    -   **Visão:** O agente deve ser capaz de modificar suas próprias ferramentas (`tool_executor.py`, `validation_steps/`, etc.) quando encontrar uma limitação. Se uma validação é muito fraca ou uma ferramenta não tem um parâmetro necessário, ele deve ser capaz de adicioná-lo.
    -   **Status:** Não iniciado. (A meta-análise de falhas pode identificar a necessidade de aprimoramento de ferramentas, mas a implementação autônoma ainda não está presente).

-   [ ] **2. Acesso e Raciocínio com Conhecimento Externo:**
    -   **Visão:** Implementar uma ferramenta de busca na web (`web_search`) robusta, permitindo que o agente pesquise documentação de APIs, soluções para erros e novas bibliotecas para resolver problemas que estão além de seu conhecimento atual.
    -   **Status:** Não iniciado.

-   [x] **3. Gerenciamento de Estratégias Dinâmicas:**
    -   **Visão:** O `MaestroAgent` deve evoluir de um simples selecionador de estratégias para um arquiteto de estratégias. Ele deve ser capaz de propor, e até mesmo codificar, novas estratégias de validação em `hephaestus_config.json` com base nos requisitos de um objetivo.
    -   **Status:** Iniciado. O `generate_next_objective` agora inclui a otimização de prompts e estratégias como uma prioridade, permitindo que o agente proponha modificações em `hephaestus_config.json` ou refinamento de prompts existentes com base na análise de performance.

---

## Fase 3: Autonomia Estratégica (Longo Prazo)

Nesta fase, o agente transcende a execução de ciclos e começa a gerenciar seu próprio desenvolvimento de forma estratégica.

-   [ ] **1. Planejamento de Longo Prazo:**
    -   **Visão:** O agente deve ser capaz de analisar este próprio `ROADMAP.md` e o `CAPABILITIES.md` para gerar um plano de desenvolvimento de múltiplos passos para si mesmo, em vez de operar em um ciclo de objetivo único.
    -   **Status:** Não iniciado.

-   [ ] **2. Auto-Otimização de Modelos:**
    -   **Visão:** Capturar os prompts e as respostas de maior sucesso para criar conjuntos de dados de fine-tuning. O objetivo final é treinar versões especializadas dos modelos de LLM que sejam mais eficientes e precisas para as tarefas do Hephaestus.
    -   **Status:** Não iniciado.

-   [ ] **3. Arquitetura de Agentes Dinâmica:**
    -   **Visão:** O agente deve ser capaz de propor e implementar mudanças em sua própria arquitetura de agentes, como criar um novo agente especializado (ex: `DocumentationAgent`) ou dividir as responsabilidades de um agente existente, para melhorar a eficiência do sistema.
    -   **Status:** Não iniciado.

---

## Arquitetura de Servidor (Novo)

-   [x] **1. Transformação em Servidor FastAPI:**
    -   **Visão:** O Hephaestus opera como um servidor em segundo plano, permitindo a submissão assíncrona de objetivos e monitoramento de status via API.
    -   **Status:** Implementado. O `main.py` agora inicia um servidor FastAPI, e o agente é executado em um thread worker separado, utilizando um `QueueManager` para gerenciar os objetivos.



[CURRENT PROJECT MANIFEST (if existing)]
# MANIFESTO DO PROJETO HEPHAESTUS

## 1. ESTRUTURA DE ARQUIVOS (OTIMIZADA)
agente_autonomo/
    README.md
    hephaestus.log
    cli.py
    AGENTS.md
    poetry.lock
    CONTRIBUTING.md
    app.py
    HEPHAESTUS_MEMORY.json
    main.py
    ROADMAP.md
    hephaestus_config.json
    requirements.txt
    run_agent.py
    MANIFESTO.md
    evolution_log.csv
    CODE_OF_CONDUCT.md
    ANALISE_PERFORMANCE_HEPHAESTUS.md
    ISSUES.md
    ANALISE_TECNICA_HEPHAESTUS.md
    Sugestões de Melhoria para o Projeto Agente Autônomo.md
    CAPABILITIES.md
    pyproject.toml
    agent/
        brain.py
        __init__.py
        code_metrics.py
        hephaestus_agent.py
        git_utils.py
        code_validator.py
        patch_applicator.py
        cycle_runner.py
        memory.py
        prompt_builder.py
        tool_executor.py
        project_scanner.py
        queue_manager.py
        state.py
        config_loader.py
        validation_steps/
            pytest_validator.py
            __init__.py
            base.py
            patch_applicator.py
            syntax_validator.py
            pytest_new_file_validator.py
        agents/
            __init__.py
            architect_agent.py
            performance_analyzer.py
            error_correction.py
            maestro_agent.py
            error_analyzer.py
        utils/
            __init__.py
            json_parser.py
            llm_client.py
    config/
        example_config.yaml
        base_config.yaml
        default.yaml
        models/
            main.yaml
        validation_strategies/
            main.yaml

## 2. RESUMO DAS INTERFACES (APIs Internas)

### Arquivo: `cli.py`
- **Função:** `run(continuous: bool=typer.Option(False, '--continuous', '-c', help='Run in continuous mode'), max_cycles: int=typer.Option(None, '--max-cycles', '-m', help='Maximum number of evolution cycles'))`
  - *Run the Hephaestus agent*
- **Função:** `submit(objective: str)`
  - *Submit a new objective to the agent*
- **Função:** `status()`
  - *Check agent status*

### Arquivo: `app.py`
- **Classe:** `Objective(BaseModel)`
- **Função:** `startup_event()`
- **Função:** `submit_objective(obj: Objective)`
- **Função:** `get_status()`

### Arquivo: `main.py`

### Arquivo: `run_agent.py`

### Arquivo: `agent/brain.py`
- **Função:** `generate_next_objective(model_config: Dict[str, str], current_manifest: str, logger: logging.Logger, project_root_dir: str, config: Optional[Dict[str, Any]]=None, memory_summary: Optional[str]=None, current_objective: Optional[str]=None)`
  - *Generates the next evolutionary objective using a lightweight model and code analysis.*
- **Função:** `generate_capacitation_objective(model_config: Dict[str, str], engineer_analysis: str, memory_summary: Optional[str]=None, logger: Optional[logging.Logger]=None)`
  - *Generates an objective to create necessary new capabilities.*
- **Função:** `generate_commit_message(model_config: Dict[str, str], analysis_summary: str, objective: str, logger: logging.Logger)`
  - *Generates a concise and informative commit message using an LLM.*

### Arquivo: `agent/__init__.py`

### Arquivo: `agent/code_metrics.py`
- **Função:** `analyze_complexity(code_string: str)`
  - *Analyzes the cyclomatic complexity and other metrics of the given Python code string using Radon.*
- **Função:** `calculate_quality_score(complexity_report: dict, duplication_report: list)`
  - *Calculates a quality score based on complexity, duplication, and other code metrics.*
- **Função:** `_get_code_lines(code_string: str, strip_comments_blanks: bool=True)`
  - *Returns a list of (original_line_number, line_content) tuples.*
- **Função:** `_find_duplicates_for_block(block_to_check: list[str], all_lines: list[tuple[int, str]], start_index: int, min_lines: int)`
  - *Finds occurrences of block_to_check in all_lines, starting after start_index.*
- **Função:** `detect_code_duplication(code_string: str, min_lines: int=4, strip_comments_and_blanks: bool=True)`
  - *Detects duplicated code blocks in the given Python code string.*

### Arquivo: `agent/hephaestus_agent.py`
- **Classe:** `HephaestusAgent`
  - *Classe principal que encapsula a lógica do agente autônomo.*

### Arquivo: `agent/git_utils.py`
- **Função:** `initialize_git_repository(logger: logging.Logger)`
  - *Ensure a git repository exists and is configured.*

### Arquivo: `agent/code_validator.py`
- **Função:** `perform_deep_validation(file_path: Path, logger: logging.Logger)`
  - *Realiza uma análise profunda da qualidade do código Python.*
- **Função:** `validate_python_code(file_path: str | Path, logger: logging.Logger, perform_deep_analysis: bool=True)`
  - *Valida se o código Python em um arquivo é sintaticamente correto e, opcionalmente, realiza uma análise profunda.*
- **Função:** `validate_json_syntax(file_path: str | Path, logger: logging.Logger)`
  - *Valida se um arquivo contém JSON válido.*

### Arquivo: `agent/patch_applicator.py`
- **Função:** `_handle_insert(full_path: Path, lines: list[str], instruction: dict, logger: logging.Logger)`
  - *Apply an INSERT patch and return ``(success, updated_lines)``.*
- **Função:** `_handle_replace(full_path: Path, lines: list[str], instruction: dict, logger: logging.Logger)`
  - *Apply a REPLACE patch.*
- **Função:** `_handle_delete_block(full_path: Path, lines: list[str], instruction: dict, logger: logging.Logger)`
  - *Apply a DELETE_BLOCK patch.*
- **Função:** `apply_patches(instructions: list[dict], logger: logging.Logger, base_path: str='.')`
  - *Aplica uma lista de instruções de patch aos arquivos.*

### Arquivo: `agent/cycle_runner.py`
- **Função:** `run_cycles(agent: 'HephaestusAgent', queue_manager: QueueManager)`
  - *Execute the main evolution loop for the given agent.*

### Arquivo: `agent/memory.py`
- **Classe:** `Memory`
  - *Manages persistent memory for the Hephaestus agent, storing historical data*

### Arquivo: `agent/prompt_builder.py`
- **Função:** `build_memory_context_section(memory_summary: Optional[str])`
  - *Constrói a seção de contexto da memória para os prompts.*
- **Função:** `build_initial_objective_prompt(memory_context_section: str)`
  - *Constrói o prompt para gerar o objetivo inicial quando não há manifesto ou análise de código.*
- **Função:** `build_meta_analysis_objective_prompt(current_objective: str, original_failed_objective: str, error_reason_for_meta: str, performance_summary_str: str, memory_context_section: str, capabilities_content: str, roadmap_content: str)`
  - *Constrói o prompt para gerar um objetivo estratégico após uma meta-análise de falha.*
- **Função:** `build_standard_objective_prompt(memory_context_section: str, performance_summary_str: str, code_analysis_summary_str: str, current_manifest: str, capabilities_content: str, roadmap_content: str)`
  - *Constrói o prompt padrão para gerar o próximo objetivo estratégico.*

### Arquivo: `agent/tool_executor.py`
- **Função:** `run_pytest(test_dir: str='tests/', cwd: str | Path | None=None)`
  - *Executa testes pytest no diretório especificado e retorna resultados.*
- **Função:** `check_file_existence(file_paths: list[str])`
  - *Verifica se todos os arquivos especificados existem.*
- **Função:** `run_in_sandbox(temp_dir_path: str, objective: str)`
  - *Executa o main.py de um diretório isolado monitorando tempo e memória.*
- **Função:** `run_git_command(command: list[str])`
  - *Executa um comando Git e retorna o status e a saída.*
- **Função:** `web_search(query: str)`
  - *Realiza uma pesquisa na web usando a API DuckDuckGo e retorna os resultados.*

### Arquivo: `agent/project_scanner.py`
- **Função:** `_extract_elements(code_string: str)`
- **Função:** `_extract_skeleton(code_string: str)`
- **Função:** `update_project_manifest(root_dir: str, target_files: List[str], output_path: str='AGENTS.md', excluded_dir_patterns: Optional[List[str]]=None)`
- **Função:** `analyze_code_metrics(root_dir: str, excluded_dir_patterns: Optional[List[str]]=None, file_loc_threshold: int=300, func_loc_threshold: int=50, func_cc_threshold: int=10)`
  - *Analisa arquivos Python em um diretório para métricas de código como LOC e Complexidade Ciclomática.*

### Arquivo: `agent/queue_manager.py`
- **Classe:** `QueueManager`

### Arquivo: `agent/state.py`
- **Classe:** `AgentState`
  - *Representa o estado interno do agente Hephaestus durante um ciclo de processamento.*

### Arquivo: `agent/config_loader.py`
- **Função:** `load_config()`
  - *Load configuration using Hydra.*

### Arquivo: `agent/validation_steps/pytest_validator.py`
- **Classe:** `PytestValidator(ValidationStep)`
  - *Runs pytest as a validation step.*

### Arquivo: `agent/validation_steps/__init__.py`
- **Classe:** `BenchmarkValidator(ValidationStep)`
- **Classe:** `CheckFileExistenceValidator(ValidationStep)`
- **Classe:** `ValidateJsonSyntax(ValidationStep)`
- **Função:** `get_validation_step(name: str)`

### Arquivo: `agent/validation_steps/base.py`
- **Classe:** `ValidationStep(ABC)`
  - *Abstract base class for a validation step.*

### Arquivo: `agent/validation_steps/patch_applicator.py`
- **Classe:** `PatchApplicatorStep(ValidationStep)`
  - *Applies patches to the specified base path.*

### Arquivo: `agent/validation_steps/syntax_validator.py`
- **Classe:** `SyntaxValidator(ValidationStep)`
  - *Validates the syntax of Python and JSON files.*

### Arquivo: `agent/validation_steps/pytest_new_file_validator.py`
- **Classe:** `PytestNewFileValidator(ValidationStep)`
  - *A validation step that runs pytest specifically on newly created test files.*

### Arquivo: `agent/agents/__init__.py`

### Arquivo: `agent/agents/architect_agent.py`
- **Classe:** `ArchitectAgent`

### Arquivo: `agent/agents/performance_analyzer.py`
- **Classe:** `PerformanceAnalysisAgent`
  - *An agent dedicated to analyzing the performance of Hephaestus.*

### Arquivo: `agent/agents/error_correction.py`
- **Classe:** `ErrorCorrectionAgent`
  - *Agent for analyzing errors and generating corrective actions.*

### Arquivo: `agent/agents/maestro_agent.py`
- **Classe:** `MaestroAgent`

### Arquivo: `agent/agents/error_analyzer.py`
- **Classe:** `ErrorAnalysisAgent`

### Arquivo: `agent/utils/__init__.py`

### Arquivo: `agent/utils/json_parser.py`
- **Função:** `parse_json_response(raw_str: str, logger: logging.Logger)`
  - *Analisa uma string bruta que se espera conter JSON, limpando-a e decodificando-a.*

### Arquivo: `agent/utils/llm_client.py`
- **Função:** `call_gemini_api(model: str, prompt: str, temperature: float, max_tokens: Optional[int], logger: logging.Logger)`
  - *Calls the Google Gemini API.*
- **Função:** `call_openrouter_api(model: str, prompt: str, temperature: float, max_tokens: Optional[int], logger: logging.Logger)`
  - *Calls a generic OpenAI-compatible API (like OpenRouter).*
- **Função:** `call_llm_with_fallback(model_config: Dict[str, Any], prompt: str, temperature: float, logger: logging.Logger)`
  - *Orchestrates LLM calls with a primary and fallback model.*

## 3. CONTEÚDO COMPLETO DOS ARQUIVOS ALVO


[Examples of Smart and Self-Aware Objectives]
*   **Performance-Based Objectives:**
    *   "The agent's success rate is low. Analyze the `evolution_log.csv` to identify the most common causes of failure and propose a solution."
    *   "Given the high number of failed cycles, implement a more robust error analysis mechanism in `error_analyzer.py`."
*   **Prompt/Strategy Optimization Objectives (RSI Focus):**
    *   "The 'SYNTAX_ONLY' strategy has a high failure rate. Analyze the prompts used by the ArchitectAgent when this strategy is chosen and propose modifications to improve syntax correctness."
    *   "Propose a new validation strategy in `hephaestus_config.json` called 'ADVANCED_LINTING' that includes `ruff` checks before applying patches, to reduce syntax errors."
    *   "Analyze the `MaestroAgent`'s decision-making process for objectives related to documentation updates, as the 'DOC_UPDATE_STRATEGY' has a low success rate. Refine its prompt to improve accuracy."
*   **Metrics-Based Refactoring:**
    *   "Refactor the module `agent/brain.py` (LOC: 350) which is extensive, considering splitting responsibilities into smaller modules (e.g., `agent/prompt_builder.py` or `agent/analysis_processor.py`)."
    *   "The function `generate_next_objective` in `agent/brain.py` (LOC: 85, CC: 12) is long and complex. Propose a plan to refactor it into smaller, more focused functions."
    *   "Analyze the most complex functions (CC > 10) listed in the metrics and select one for refactoring."
*   **Test Creation (Generate New Test Files):**
    *   "The module `agent/project_scanner.py` is missing a test file. Create a new test file `tests/agent/test_project_scanner.py` with basic unit tests for the `analyze_code_metrics` function."
    *   "Module `agent/memory.py` lacks tests. Generate `tests/agent/test_memory.py` and include placeholder tests for its public functions."
    *   "Create unit tests for the module `agent/tool_executor.py` in a new file `tests/agent/test_tool_executor.py`, focusing on the `web_search` function."
    *   "The function `call_llm_api` in `agent/utils/llm_client.py` is critical. Ensure robust unit tests exist for it in `tests/agent/utils/test_llm_client.py`, covering success and failure cases. If the test file doesn't exist, create it."
*   **Test-Driven Development (TDD) Flow:**
    *   "The previous cycle successfully created a new test file `tests/agent/test_new_feature.py` which is now failing as expected. The next objective is to implement the minimal code in `agent/new_feature.py` required to make the tests in `tests/agent/test_new_feature.py` pass."
*   **Strategic Documentation Improvement:**
    *   "The manifest (`AGENTS.md`) does not describe the new metrics analysis functionality in `project_scanner.py`. Update it."
    *   "Improve docstrings for public functions in the `agent/memory.py` module to detail parameters and expected behavior."
*   **Development of New Capabilities (Agents/Tools):**
    *   "Create a new agent (e.g., `CodeQualityAgent` in `agent/agents.py`) dedicated to continuously monitoring code quality metrics and reporting regressions."
    *   "Develop a new tool in `agent/tool_executor.py` to automatically validate the syntax of JSON files before processing."
    *   "Propose a system for Hephaestus to evaluate the performance of its own operations and identify bottlenecks."
*   **Generic Objectives (when metrics/manifest are insufficient):**
    *   "Analyze the `agent/state.py` module to identify potential improvements in clarity or efficiency."
    *   "Review recent logs for frequent errors and propose an objective to fix them."

[Your Task]
Based on ALL the information provided (metrics, manifest, history), generate ONLY a single text string containing the NEXT STRATEGIC OBJECTIVE. The objective should be the most impactful and logical for the project's evolution at this moment.
Be concise, but specific enough to be actionable.

2025-07-03 20:02:32,205 - HephaestusAgent - INFO - Calling primary model: gemini/gemini-2.5-pro
2025-07-03 20:02:32,205 - HephaestusAgent - INFO - Attempting to call Gemini API with model: gemini/gemini-2.5-pro
2025-07-03 20:02:55,298 - HephaestusAgent - DEBUG - Gemini API Response: Considerando que a função `run_cycles` em `agent/cycle_runner.py` é a mais complexa do projeto (CC: 89) e não possui testes, e que tentativas recentes de refatorá-la ou testá-la falharam, o próximo passo estratégico é estabelecer a infraestrutura de teste de forma segura. Crie um novo arquivo de teste `tests/agent/test_cycle_runner.py` com uma estrutura básica e um teste placeholder, preparando o caminho para a futura refatoração segura desta função crítica.
2025-07-03 20:02:55,298 - HephaestusAgent - INFO - Próximo objetivo: Considerando que a função `run_cycles` em `agent/cycle_runner.py` é a mais complexa do projeto (CC: 89) e não possui testes, e que tentativas recentes de refatorá-la ou testá-la falharam, o próximo passo estratégico é estabelecer a infraestrutura de teste de forma segura. Crie um novo arquivo de teste `tests/agent/test_cycle_runner.py` com uma estrutura básica e um teste placeholder, preparando o caminho para a futura refatoração segura desta função crítica.
2025-07-03 20:02:55,300 - HephaestusAgent - INFO - Memória salva em HEPHAESTUS_MEMORY.json (6 completed, 4 failed)
2025-07-03 20:02:55,300 - HephaestusAgent - INFO - ==================== FIM DO CICLO DE EVOLUÇÃO ====================
2025-07-03 20:02:56,301 - HephaestusAgent - INFO - 

==================== INÍCIO DO CICLO DE EVOLUÇÃO (Ciclo #5) ====================
2025-07-03 20:02:56,301 - HephaestusAgent - INFO - OBJETIVO ATUAL: Considerando que a função `run_cycles` em `agent/cycle_runner.py` é a mais complexa do projeto (CC: 89) e não possui testes, e que tentativas recentes de refatorá-la ou testá-la falharam, o próximo passo estratégico é estabelecer a infraestrutura de teste de forma segura. Crie um novo arquivo de teste `tests/agent/test_cycle_runner.py` com uma estrutura básica e um teste placeholder, preparando o caminho para a futura refatoração segura desta função crítica.

2025-07-03 20:02:56,301 - HephaestusAgent - INFO - Gerando manifesto do projeto (AGENTS.md)...
2025-07-03 20:02:56,345 - HephaestusAgent - INFO - --- MANIFESTO GERADO (Tamanho: 11020 caracteres) ---
2025-07-03 20:02:56,345 - HephaestusAgent - INFO - 
Solicitando plano de ação do ArchitectAgent...
2025-07-03 20:02:56,345 - HephaestusAgent.ArchitectAgent - INFO - ArchitectAgent: Gerando plano de patches com os modelos: {'_target_': 'builtins.dict', 'temperature': 0.3, 'max_tokens': -1, 'primary': 'gemini/gemini-2.5-pro', 'fallback': 'deepseek/deepseek-r1-0528:free'}...
2025-07-03 20:02:56,345 - HephaestusAgent.ArchitectAgent - INFO - Calling primary model: gemini/gemini-2.5-pro
2025-07-03 20:02:56,346 - HephaestusAgent.ArchitectAgent - INFO - Attempting to call Gemini API with model: gemini/gemini-2.5-pro
2025-07-03 20:03:13,863 - HephaestusAgent.ArchitectAgent - DEBUG - Gemini API Response: ```json
{
  "analysis": "O objetivo é criar um novo arquivo de teste para estabelecer a infraestrutura de teste para a função `run_cycles` em `agent/cycle_runner.py`, que é altamente complexa e atualmente não testada. Este plano cria o arquivo `tests/agent/test_cycle_runner.py`. O novo arquivo conterá as importações necessárias (`pytest`, `MagicMock` e a própria função `run_cycles`) e um único teste de placeholder. Este teste está marcado para ser ignorado (`@pytest.mark.skip`) para que não falhe na suíte de testes, ao mesmo tempo que sinaliza claramente que a implementação está pendente. Esta abordagem prepara o terreno de forma segura para o desenvolvimento futuro de testes para esta função crítica.",
  "patches_to_apply": [
    {
      "file_path": "tests/agent/test_cycle_runner.py",
      "operation": "REPLACE",
      "block_to_replace": null,
      "content": "import pytest\nfrom unittest.mock import MagicMock\n\nfrom agent.cycle_runner import run_cycles\n\n\n@pytest.mark.skip(reason=\"Placeholder test for the complex run_cycles function. Implementation to follow.\")\ndef test_run_cycles_placeholder():\n    \"\"\"Placeholder test to establish the testing framework for run_cycles.\"\"\"\n    # TODO: Implement comprehensive tests for the run_cycles function.\n    # This will require mocking the HephaestusAgent and QueueManager objects,\n    # and simulating different agent states and queue contents to test various\n    # execution paths within the main evolution loop.\n\n    # Arrange\n    mock_agent = MagicMock()\n    mock_queue_manager = MagicMock()\n\n    # Act\n    # For now, we just ensure the file is created. The actual call is commented out.\n    # run_cycles(mock_agent, mock_queue_manager)\n\n    # Assert\n    # Assertions will be added here to verify the behavior of the cycle runner.\n    pass\n"
    }
  ]
}
```
2025-07-03 20:03:13,883 - HephaestusAgent.ArchitectAgent - DEBUG - parse_json_response: Raw response before cleaning: ```json
{
  "analysis": "O objetivo é criar um novo arquivo de teste para estabelecer a infraestrutura de teste para a função `run_cycles` em `agent/cycle_runner.py`, que é altamente complexa e atualmente não testada. Este plano cria o arquivo `tests/agent/test_cycle_runner.py`. O novo arquivo conte...
2025-07-03 20:03:13,883 - HephaestusAgent.ArchitectAgent - DEBUG - parse_json_response: Extracted JSON content based on braces: {
  "analysis": "O objetivo é criar um novo arquivo de teste para estabelecer a infraestrutura de teste para a função `run_cycles` em `agent/cycle_runner.py`, que é altamente complexa e atualmente não testada. Este plano cria o arquivo `tests/agent/test_cycle_runner.py`. O novo arquivo conterá as im...
2025-07-03 20:03:13,884 - HephaestusAgent.ArchitectAgent - DEBUG - parse_json_response: Final cleaned content before parsing: {
  "analysis": "O objetivo é criar um novo arquivo de teste para estabelecer a infraestrutura de teste para a função `run_cycles` em `agent/cycle_runner.py`, que é altamente complexa e atualmente não testada. Este plano cria o arquivo `tests/agent/test_cycle_runner.py`. O novo arquivo conterá as im...
2025-07-03 20:03:13,884 - HephaestusAgent - INFO - --- PLANO DE AÇÃO (PATCHES) GERADO PELO ARCHITECTAGENT ({'_target_': 'builtins.dict', 'temperature': 0.3, 'max_tokens': -1, 'primary': 'gemini/gemini-2.5-pro', 'fallback': 'deepseek/deepseek-r1-0528:free'}) ---
2025-07-03 20:03:13,884 - HephaestusAgent - DEBUG - Análise do Arquiteto: O objetivo é criar um novo arquivo de teste para estabelecer a infraestrutura de teste para a função `run_cycles` em `agent/cycle_runner.py`, que é altamente complexa e atualmente não testada. Este plano cria o arquivo `tests/agent/test_cycle_runner.py`. O novo arquivo conterá as importações necessárias (`pytest`, `MagicMock` e a própria função `run_cycles`) e um único teste de placeholder. Este teste está marcado para ser ignorado (`@pytest.mark.skip`) para que não falhe na suíte de testes, ao mesmo tempo que sinaliza claramente que a implementação está pendente. Esta abordagem prepara o terreno de forma segura para o desenvolvimento futuro de testes para esta função crítica.
2025-07-03 20:03:13,884 - HephaestusAgent - DEBUG - Patches: [
  {
    "file_path": "tests/agent/test_cycle_runner.py",
    "operation": "REPLACE",
    "block_to_replace": null,
    "content": "import pytest\nfrom unittest.mock import MagicMock\n\nfrom agent.cycle_runner import run_cycles\n\n\n@pytest.mark.skip(reason=\"Placeholder test for the complex run_cycles function. Implementation to follow.\")\ndef test_run_cycles_placeholder():\n    \"\"\"Placeholder test to establish the testing framework for run_cycles.\"\"\"\n    # TODO: Implement comprehensive tests for the run_cycles function.\n    # This will require mocking the HephaestusAgent and QueueManager objects,\n    # and simulating different agent states and queue contents to test various\n    # execution paths within the main evolution loop.\n\n    # Arrange\n    mock_agent = MagicMock()\n    mock_queue_manager = MagicMock()\n\n    # Act\n    # For now, we just ensure the file is created. The actual call is commented out.\n    # run_cycles(mock_agent, mock_queue_manager)\n\n    # Assert\n    # Assertions will be added here to verify the behavior of the cycle runner.\n    pass\n"
  }
]
2025-07-03 20:03:13,884 - HephaestusAgent - INFO - 
Solicitando decisão do MaestroAgent...
2025-07-03 20:03:13,884 - HephaestusAgent.MaestroAgent - INFO - MaestroAgent: Tentando decisão com os modelos: {'_target_': 'builtins.dict', 'temperature': 0.3, 'max_tokens': -1, 'primary': 'gemini/gemini-2.5-pro', 'fallback': 'deepseek/deepseek-r1-0528:free'}...
2025-07-03 20:03:13,884 - HephaestusAgent.MaestroAgent - DEBUG - MaestroAgent: Prompt for decision:

[IDENTITY]
You are the Maestro of the Hephaestus agent. Your task is to analyze the Engineer's proposal (patch plan) and recent history to decide the best course of action.

[CONTEXT AND HISTORY]

[HISTÓRICO RECENTE (OBJETIVOS E ESTRATÉGIAS USADAS)]
Completed Objectives (most recent first):
- Objective: Com base no sucesso contínuo em adicionar testes ao módulo `patch_applicator.py` e para continuar a aumentar a cobertura de teste em um dos módulos mais críticos e complexos (`apply_patches` CC: 65), o próximo passo é testar a última função auxiliar principal. Adicione um novo teste unitário ao arquivo `tests/agent/test_patch_applicator.py` para a função `_handle_delete_block` (CC: 21), que atualmente não possui testes. O teste deve validar a lógica de exclusão de bloco de forma isolada.
  Strategy: SYNTAX_AND_PYTEST
  Outcome: Strategy 'SYNTAX_AND_PYTEST' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T23:02:31.915409+00:00
- Objective: Dado o sucesso em criar o teste para a função `_handle_insert`, o próximo passo é continuar a construção da capacidade de teste no módulo `agent/patch_applicator.py` (CC: 65), que é crítico e complexo. Adicione um novo teste unitário ao arquivo `tests/agent/test_patch_applicator.py` para a função auxiliar `_handle_replace` (CC: 15), utilizando `unittest.mock.patch` para simular as interações com o sistema de arquivos e validar a lógica de substituição de forma isolada.
  Strategy: SYNTAX_AND_PYTEST
  Outcome: Strategy 'SYNTAX_AND_PYTEST' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T23:00:20.108938+00:00

Failed Objectives (most recent first):
- Objective: Dado o sucesso em criar o arquivo de teste para `cycle_runner`, o próximo passo é adicionar um teste de caracterização para a função `run_cycles` (CC: 89). Este teste deve usar `unittest.mock` para simular as dependências essenciais (como `AgentState` e `QueueManager`) e invocar a função, validando que ela pode ser executada em um cenário controlado sem erros, estabelecendo assim a base para testes de lógica mais detalhados e refatoração segura.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_qyaqjai0)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:41:06.299306+00:00
- Objective: Para iniciar a refatoração da função `run_cycles` (CC: 89), que é a mais complexa do projeto, extraia a lógica de inicialização do ciclo (criação do `AgentState` e logs iniciais) para uma nova função auxiliar privada dentro de `agent/cycle_runner.py`. Em seguida, adicione um teste unitário no arquivo `tests/agent/test_cycle_runner.py` que valide especificamente o comportamento desta nova função extraída, garantindo um progresso incremental e seguro.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_v22kn3j2)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:31:44.352659+00:00
Considere esse histórico em sua decisão. Evite repetir estratégias que falharam recentemente para objetivos semelhantes.


[ENGINEER'S PROPOSAL (PATCH PLAN)]
{
  "analysis": "O objetivo é criar um novo arquivo de teste para estabelecer a infraestrutura de teste para a função `run_cycles` em `agent/cycle_runner.py`, que é altamente complexa e atualmente não testada. Este plano cria o arquivo `tests/agent/test_cycle_runner.py`. O novo arquivo conterá as importações necessárias (`pytest`, `MagicMock` e a própria função `run_cycles`) e um único teste de placeholder. Este teste está marcado para ser ignorado (`@pytest.mark.skip`) para que não falhe na suíte de testes, ao mesmo tempo que sinaliza claramente que a implementação está pendente. Esta abordagem prepara o terreno de forma segura para o desenvolvimento futuro de testes para esta função crítica.",
  "patches_to_apply": [
    {
      "file_path": "tests/agent/test_cycle_runner.py",
      "operation": "REPLACE",
      "block_to_replace": null,
      "content": "import pytest\nfrom unittest.mock import MagicMock\n\nfrom agent.cycle_runner import run_cycles\n\n\n@pytest.mark.skip(reason=\"Placeholder test for the complex run_cycles function. Implementation to follow.\")\ndef test_run_cycles_placeholder():\n    \"\"\"Placeholder test to establish the testing framework for run_cycles.\"\"\"\n    # TODO: Implement comprehensive tests for the run_cycles function.\n    # This will require mocking the HephaestusAgent and QueueManager objects,\n    # and simulating different agent states and queue contents to test various\n    # execution paths within the main evolution loop.\n\n    # Arrange\n    mock_agent = MagicMock()\n    mock_queue_manager = MagicMock()\n\n    # Act\n    # For now, we just ensure the file is created. The actual call is commented out.\n    # run_cycles(mock_agent, mock_queue_manager)\n\n    # Assert\n    # Assertions will be added here to verify the behavior of the cycle runner.\n    pass\n"
    }
  ]
}

[YOUR DECISION]
Based on the proposal and history:
1. If the solution seems reasonable and does not require new capabilities, choose the most appropriate validation strategy.
2. If the solution requires new capabilities that Hephaestus needs to develop, respond with `CAPACITATION_REQUIRED`.

Available Validation Strategies: SYNTAX_ONLY, BENCHMARK_ONLY, SYNTAX_AND_PYTEST, FULL_VALIDATION, DOC_UPDATE_STRATEGY, CONFIG_UPDATE_STRATEGY, DISCARD, TEST_FIX_STRATEGY, CREATE_NEW_TEST_FILE_STRATEGY, AUTO_CORRECTION_STRATEGY
Additional Option: CAPACITATION_REQUIRED

[REQUIRED OUTPUT FORMAT]
Respond ONLY with a JSON object containing the "strategy_key" and the value being ONE of the available strategies OR "CAPACITATION_REQUIRED".
Example: {"strategy_key": "sandbox_pytest_validation"}
Example: {"strategy_key": "CAPACITATION_REQUIRED"}

2025-07-03 20:03:13,884 - HephaestusAgent.MaestroAgent - INFO - Calling primary model: gemini/gemini-2.5-pro
2025-07-03 20:03:13,884 - HephaestusAgent.MaestroAgent - INFO - Attempting to call Gemini API with model: gemini/gemini-2.5-pro
2025-07-03 20:03:26,664 - HephaestusAgent.MaestroAgent - DEBUG - Gemini API Response: ```json
{
  "strategy_key": "CREATE_NEW_TEST_FILE_STRATEGY"
}
```
2025-07-03 20:03:26,664 - HephaestusAgent.MaestroAgent - DEBUG - parse_json_response: Raw response before cleaning: ```json
{
  "strategy_key": "CREATE_NEW_TEST_FILE_STRATEGY"
}
```...
2025-07-03 20:03:26,664 - HephaestusAgent.MaestroAgent - DEBUG - parse_json_response: Extracted JSON content based on braces: {
  "strategy_key": "CREATE_NEW_TEST_FILE_STRATEGY"
}...
2025-07-03 20:03:26,664 - HephaestusAgent.MaestroAgent - DEBUG - parse_json_response: Final cleaned content before parsing: {
  "strategy_key": "CREATE_NEW_TEST_FILE_STRATEGY"
}...
2025-07-03 20:03:26,664 - HephaestusAgent - INFO - Estratégia escolhida pelo MaestroAgent (primary: gemini/gemini-2.5-pro, fallback: deepseek/deepseek-r1-0528:free): CREATE_NEW_TEST_FILE_STRATEGY
2025-07-03 20:03:26,664 - HephaestusAgent - INFO - 
Executing strategy 'CREATE_NEW_TEST_FILE_STRATEGY' with steps: ['validate_syntax', 'run_pytest_new_file', 'PatchApplicatorStep']
2025-07-03 20:03:26,664 - HephaestusAgent - INFO - Created temporary sandbox at: /tmp/hephaestus_sandbox_9s1zq_ur
2025-07-03 20:03:26,664 - HephaestusAgent - INFO - Copying project to sandbox: /tmp/hephaestus_sandbox_9s1zq_ur...
2025-07-03 20:03:26,677 - HephaestusAgent - INFO - Copy to sandbox complete.
2025-07-03 20:03:26,677 - HephaestusAgent - INFO - --- Validation/Execution Step: validate_syntax ---
2025-07-03 20:03:26,678 - HephaestusAgent - INFO - Starting syntax validation in: /tmp/hephaestus_sandbox_9s1zq_ur
2025-07-03 20:03:26,678 - HephaestusAgent - DEBUG - Validating syntax of: /tmp/hephaestus_sandbox_9s1zq_ur/tests/agent/test_cycle_runner.py
2025-07-03 20:03:26,678 - HephaestusAgent - WARNING - File /tmp/hephaestus_sandbox_9s1zq_ur/tests/agent/test_cycle_runner.py not found in '/tmp/hephaestus_sandbox_9s1zq_ur' for validation.
2025-07-03 20:03:26,678 - HephaestusAgent - INFO - Syntax validation in '/tmp/hephaestus_sandbox_9s1zq_ur': SUCCESS.
2025-07-03 20:03:26,678 - HephaestusAgent - INFO - --- Validation/Execution Step: run_pytest_new_file ---
2025-07-03 20:03:26,678 - HephaestusAgent - INFO - Executing PytestNewFileValidator...
2025-07-03 20:03:26,678 - HephaestusAgent - INFO - Test file /tmp/hephaestus_sandbox_9s1zq_ur/tests/agent/test_cycle_runner.py does not exist. Attempting to write from patch content for validation.
2025-07-03 20:03:26,678 - HephaestusAgent - INFO - Temporarily wrote content of tests/agent/test_cycle_runner.py for pytest validation.
2025-07-03 20:03:26,678 - HephaestusAgent - INFO - Running pytest on new file: /tmp/hephaestus_sandbox_9s1zq_ur/tests/agent/test_cycle_runner.py
2025-07-03 20:03:28,122 - HephaestusAgent - INFO - Pytest passed for new file tests/agent/test_cycle_runner.py.
STDOUT:
============================= test session starts ==============================
platform linux -- Python 3.11.9, pytest-8.4.1, pluggy-1.6.0
rootdir: /tmp/hephaestus_sandbox_9s1zq_ur
configfile: pyproject.toml
plugins: mock-3.14.1, anyio-4.9.0, hydra-core-1.3.2
collected 1 item

tests/agent/test_cycle_runner.py s                                       [100%]

============================== 1 skipped in 0.67s ==============================
2025-07-03 20:03:28,122 - HephaestusAgent - INFO - --- Validation/Execution Step: PatchApplicatorStep ---
2025-07-03 20:03:28,122 - HephaestusAgent - INFO - Applying 1 patches in '/tmp/hephaestus_sandbox_9s1zq_ur'...
2025-07-03 20:03:28,122 - HephaestusAgent - INFO - Aplicando patches com base_path: '/tmp/hephaestus_sandbox_9s1zq_ur'
2025-07-03 20:03:28,123 - HephaestusAgent - INFO - Processando patch 1/1: REPLACE em '/tmp/hephaestus_sandbox_9s1zq_ur/tests/agent/test_cycle_runner.py'
2025-07-03 20:03:28,123 - HephaestusAgent - INFO - REPLACE sem 'block_to_replace' para '/tmp/hephaestus_sandbox_9s1zq_ur/tests/agent/test_cycle_runner.py'. Arquivo será sobrescrito.
2025-07-03 20:03:28,123 - HephaestusAgent - INFO - Arquivo '/tmp/hephaestus_sandbox_9s1zq_ur/tests/agent/test_cycle_runner.py' salvo após operação 'REPLACE'.
2025-07-03 20:03:28,123 - HephaestusAgent - INFO - Todas as 1 instruções de patch processadas. Arquivos afetados (tentativas): {'/tmp/hephaestus_sandbox_9s1zq_ur/tests/agent/test_cycle_runner.py'}
2025-07-03 20:03:28,123 - HephaestusAgent - INFO - Patches applied successfully in '/tmp/hephaestus_sandbox_9s1zq_ur'.
2025-07-03 20:03:28,123 - HephaestusAgent - INFO - Cleaning up temporary sandbox: /tmp/hephaestus_sandbox_9s1zq_ur
2025-07-03 20:03:28,127 - HephaestusAgent - INFO - Sandbox cleaned.
2025-07-03 20:03:28,127 - HephaestusAgent - INFO - 
SUCESSO NA VALIDAÇÃO/APLICAÇÃO! Razão: VALIDATION_SUCCESS_NO_CHANGES
2025-07-03 20:03:28,127 - HephaestusAgent - INFO - Ciclo concluído com status: VALIDATION_SUCCESS_NO_CHANGES. Nenhuma alteração no código foi promovida. Gerando próximo objetivo evolutivo...
2025-07-03 20:03:28,127 - HephaestusAgent - INFO - Generating next objective...
2025-07-03 20:03:28,128 - HephaestusAgent - INFO - CAPABILITIES.md lido com sucesso.
2025-07-03 20:03:28,128 - HephaestusAgent - INFO - ROADMAP.md lido com sucesso.
2025-07-03 20:03:28,128 - HephaestusAgent - INFO - Analyzing code metrics in: .
2025-07-03 20:03:28,411 - HephaestusAgent - DEBUG - Code analysis summary:
Large Files (potential candidates for modularization):
  - agent/brain.py (LOC: 357)
  - agent/code_metrics.py (LOC: 362)
  - agent/hephaestus_agent.py (LOC: 369)
  - agent/patch_applicator.py (LOC: 697)
  - agent/cycle_runner.py (LOC: 485)
  - agent/project_scanner.py (LOC: 462)

Large Functions (potential candidates for refactoring/splitting):
  - agent/brain.py -> generate_next_objective() (LOC: 162)
  - agent/brain.py -> generate_capacitation_objective() (LOC: 59)
  - agent/brain.py -> generate_commit_message() (LOC: 98)
  - agent/code_metrics.py -> analyze_complexity() (LOC: 84)
  - agent/code_metrics.py -> calculate_quality_score() (LOC: 89)
  - agent/code_metrics.py -> detect_code_duplication() (LOC: 126)
  - agent/git_utils.py -> initialize_git_repository() (LOC: 208)
  - agent/patch_applicator.py -> _handle_replace() (LOC: 71)
  - agent/patch_applicator.py -> _handle_delete_block() (LOC: 78)
  - agent/patch_applicator.py -> apply_patches() (LOC: 285)
  - agent/cycle_runner.py -> run_cycles() (LOC: 460)
  - agent/prompt_builder.py -> build_meta_analysis_objective_prompt() (LOC: 62)
  - agent/prompt_builder.py -> build_standard_objective_prompt() (LOC: 100)
  - agent/project_scanner.py -> update_project_manifest() (LOC: 188)
  - agent/project_scanner.py -> analyze_code_metrics() (LOC: 208)
  - agent/config_loader.py -> load_config() (LOC: 53)
  - agent/utils/json_parser.py -> parse_json_response() (LOC: 75)

Complex Functions (high CC, potential candidates for refactoring/simplification):
  - agent/brain.py -> generate_next_objective() (CC: 43)
  - agent/brain.py -> generate_commit_message() (CC: 15)
  - agent/code_metrics.py -> analyze_complexity() (CC: 15)
  - agent/code_metrics.py -> calculate_quality_score() (CC: 23)
  - agent/code_metrics.py -> detect_code_duplication() (CC: 20)
  - agent/git_utils.py -> initialize_git_repository() (CC: 14)
  - agent/patch_applicator.py -> _handle_replace() (CC: 15)
  - agent/patch_applicator.py -> _handle_delete_block() (CC: 21)
  - agent/patch_applicator.py -> apply_patches() (CC: 65)
  - agent/cycle_runner.py -> run_cycles() (CC: 89)
  - agent/project_scanner.py -> update_project_manifest() (CC: 45)
  - agent/project_scanner.py -> analyze_code_metrics() (CC: 47)
  - agent/utils/json_parser.py -> parse_json_response() (CC: 25)

Modules without Corresponding Test Files (consider creating tests):
  - cli.py
  - app.py
  - run_agent.py
  - agent/brain.py
  - agent/code_metrics.py
  - agent/hephaestus_agent.py
  - agent/git_utils.py
  - agent/code_validator.py
  - agent/patch_applicator.py
  - agent/cycle_runner.py
  - agent/memory.py
  - agent/prompt_builder.py
  - agent/tool_executor.py
  - agent/project_scanner.py
  - agent/state.py
  - agent/config_loader.py
  - agent/validation_steps/pytest_validator.py
  - agent/validation_steps/__init__.py
  - agent/validation_steps/base.py
  - agent/validation_steps/patch_applicator.py
  - agent/validation_steps/syntax_validator.py
  - agent/validation_steps/pytest_new_file_validator.py
  - agent/agents/architect_agent.py
  - agent/agents/performance_analyzer.py
  - agent/agents/error_correction.py
  - agent/agents/maestro_agent.py
  - agent/agents/error_analyzer.py
  - agent/utils/json_parser.py
  - agent/utils/llm_client.py
2025-07-03 20:03:28,411 - HephaestusAgent - INFO - Analyzing performance log...
2025-07-03 20:03:28,417 - HephaestusAgent - DEBUG - Performance analysis summary:
Performance Summary:
- Total Cycles: 9
- Successful Cycles: 6
- Failed Cycles: 3
- Success Rate: 66.67%
- Average Cycle Duration: N/A

Performance by Strategy (sorted by failures):
- Strategy 'SYNTAX_AND_PYTEST': Success Rate: 40.00% (Failures: 3/5)
- Strategy 'CREATE_NEW_TEST_FILE_STRATEGY': Success Rate: 100.00% (Failures: 0/4)

2025-07-03 20:03:28,417 - HephaestusAgent - DEBUG - Prompt for generate_next_objective:

[Main Context]
You are the 'Planejador Estratégico Avançado' do agente autônomo Hephaestus. Sua principal responsabilidade é identificar e propor o próximo objetivo de desenvolvimento mais impactante para a evolução do agente ou do projeto em análise.

[Decision Process for the Next Objective]
1.  **Analyze Performance:** Review the `[PERFORMANCE ANALYSIS]` section.
2.  **Analyze Code Metrics:** Review the `[CODE METRICS AND ANALYSIS]` section.
3.  **Consider Strategic Documents:** Review `[CAPABILITIES DOCUMENT]` and `[ROADMAP DOCUMENT]` to understand current capabilities, desired future states, and strategic direction. Identify gaps or next steps.
4.  **Consider the Project Manifest:** If the `[CURRENT PROJECT MANIFEST]` is provided, use it for context.
5.  **Review Recent History:** The `[HISTÓRICO RECENTE DO PROJETO E DO AGENTE]` section provides context.
6.  **Prioritize RSI:** Focus on objectives that enhance the agent's ability to self-improve, improve its core logic, prompts, or strategies.
7.  **Prioritize Capabilities & Roadmap:** Generate objectives that fill gaps in `[CAPABILITIES DOCUMENT]` or advance items in `[ROADMAP DOCUMENT]`.
8.  **Prioritize Structural and Quality Improvements:** Based on metrics and strategic documents.
9.  **Be Specific and Actionable:** The objective should be clear, concise, and indicate a concrete action.

1.  **Analyze Performance:** Review the `[PERFORMANCE ANALYSIS]` section to understand the agent's overall success rate and identify trends, especially focusing on strategies with high failure rates.
2.  **Analyze Code Metrics:** Review the `[CODE METRICS AND ANALYSIS]` section below. It contains data on file size (LOC), function size (LOC), cyclomatic complexity (CC) of functions, and modules that may be missing tests.
3.  **Consider the Project Manifest:** If the `[CURRENT PROJECT MANIFEST]` is provided, use it to understand the overall goals, architecture, and areas already documented or needing attention.
4.  **Review Recent History:** The `[HISTÓRICO RECENTE DO PROJETO E DO AGENTE]` section provides context on recent tasks, successes, and failures. Avoid repeating objectives that recently failed in the same way, unless the cause of failure has been resolved. Use history to build on successes.
5.  **Prioritize Structural and Quality Improvements:** Based on metrics, identify opportunities to:
    *   Refactor very large modules or very long/complex functions.
    *   Create tests for critical/complex modules or functions that lack them.
    *   Improve documentation (docstrings, manifest) where crucial.
    *   Propose the creation of new capabilities (new agents, tools) if the analysis indicates a strategic need.
6.  **Prioritize Prompt and Strategy Optimization (RSI Focus):** If the performance analysis reveals strategies with consistently low success rates, consider objectives to:
    *   Refine the prompts used by agents (e.g., Architect, Maestro, ErrorAnalysis) for those failing strategies.
    *   Propose new or modified validation strategies in `hephaestus_config.json` to address specific failure patterns.
7.  **Be Specific and Actionable:** The objective should be clear, concise, and indicate a concrete action.


[HISTÓRICO RECENTE DO PROJETO E DO AGENTE]
Completed Objectives (most recent first):
- Objective: Considerando que a função `run_cycles` em `agent/cycle_runner.py` é a mais complexa do projeto (CC: 89) e não possui testes, e que tentativas recentes de refatorá-la ou testá-la falharam, o próximo passo estratégico é estabelecer a infraestrutura de teste de forma segura. Crie um novo arquivo de teste `tests/agent/test_cycle_runner.py` com uma estrutura básica e um teste placeholder, preparando o caminho para a futura refatoração segura desta função crítica.
  Strategy: CREATE_NEW_TEST_FILE_STRATEGY
  Outcome: Strategy 'CREATE_NEW_TEST_FILE_STRATEGY' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T23:03:28.127857+00:00
- Objective: Com base no sucesso contínuo em adicionar testes ao módulo `patch_applicator.py` e para continuar a aumentar a cobertura de teste em um dos módulos mais críticos e complexos (`apply_patches` CC: 65), o próximo passo é testar a última função auxiliar principal. Adicione um novo teste unitário ao arquivo `tests/agent/test_patch_applicator.py` para a função `_handle_delete_block` (CC: 21), que atualmente não possui testes. O teste deve validar a lógica de exclusão de bloco de forma isolada.
  Strategy: SYNTAX_AND_PYTEST
  Outcome: Strategy 'SYNTAX_AND_PYTEST' completed. Status: VALIDATION_SUCCESS_NO_CHANGES....
  Date: 2025-07-03T23:02:31.915409+00:00

Failed Objectives (most recent first):
- Objective: Dado o sucesso em criar o arquivo de teste para `cycle_runner`, o próximo passo é adicionar um teste de caracterização para a função `run_cycles` (CC: 89). Este teste deve usar `unittest.mock` para simular as dependências essenciais (como `AgentState` e `QueueManager`) e invocar a função, validando que ela pode ser executada em um cenário controlado sem erros, estabelecendo assim a base para testes de lógica mais detalhados e refatoração segura.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_qyaqjai0)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:41:06.299306+00:00
- Objective: Para iniciar a refatoração da função `run_cycles` (CC: 89), que é a mais complexa do projeto, extraia a lógica de inicialização do ciclo (criação do `AgentState` e logs iniciais) para uma nova função auxiliar privada dentro de `agent/cycle_runner.py`. Em seguida, adicione um teste unitário no arquivo `tests/agent/test_cycle_runner.py` que valide especificamente o comportamento desta nova função extraída, garantindo um progresso incremental e seguro.
  Reason: PYTEST_FAILURE_IN_SANDBOX
  Details: Pytest Command: pytest tests/ (CWD: /tmp/hephaestus_sandbox_v22kn3j2)
Exit Code: 1

Stdout:
============================= test session starts ========...
  Date: 2025-07-03T22:31:44.352659+00:00
Consider this history to avoid repeating failures, build on successes, and identify gaps.


[PERFORMANCE ANALYSIS]
Performance Summary:
- Total Cycles: 9
- Successful Cycles: 6
- Failed Cycles: 3
- Success Rate: 66.67%
- Average Cycle Duration: N/A

Performance by Strategy (sorted by failures):
- Strategy 'SYNTAX_AND_PYTEST': Success Rate: 40.00% (Failures: 3/5)
- Strategy 'CREATE_NEW_TEST_FILE_STRATEGY': Success Rate: 100.00% (Failures: 0/4)


[CODE METRICS AND ANALYSIS]
Large Files (potential candidates for modularization):
  - agent/brain.py (LOC: 357)
  - agent/code_metrics.py (LOC: 362)
  - agent/hephaestus_agent.py (LOC: 369)
  - agent/patch_applicator.py (LOC: 697)
  - agent/cycle_runner.py (LOC: 485)
  - agent/project_scanner.py (LOC: 462)

Large Functions (potential candidates for refactoring/splitting):
  - agent/brain.py -> generate_next_objective() (LOC: 162)
  - agent/brain.py -> generate_capacitation_objective() (LOC: 59)
  - agent/brain.py -> generate_commit_message() (LOC: 98)
  - agent/code_metrics.py -> analyze_complexity() (LOC: 84)
  - agent/code_metrics.py -> calculate_quality_score() (LOC: 89)
  - agent/code_metrics.py -> detect_code_duplication() (LOC: 126)
  - agent/git_utils.py -> initialize_git_repository() (LOC: 208)
  - agent/patch_applicator.py -> _handle_replace() (LOC: 71)
  - agent/patch_applicator.py -> _handle_delete_block() (LOC: 78)
  - agent/patch_applicator.py -> apply_patches() (LOC: 285)
  - agent/cycle_runner.py -> run_cycles() (LOC: 460)
  - agent/prompt_builder.py -> build_meta_analysis_objective_prompt() (LOC: 62)
  - agent/prompt_builder.py -> build_standard_objective_prompt() (LOC: 100)
  - agent/project_scanner.py -> update_project_manifest() (LOC: 188)
  - agent/project_scanner.py -> analyze_code_metrics() (LOC: 208)
  - agent/config_loader.py -> load_config() (LOC: 53)
  - agent/utils/json_parser.py -> parse_json_response() (LOC: 75)

Complex Functions (high CC, potential candidates for refactoring/simplification):
  - agent/brain.py -> generate_next_objective() (CC: 43)
  - agent/brain.py -> generate_commit_message() (CC: 15)
  - agent/code_metrics.py -> analyze_complexity() (CC: 15)
  - agent/code_metrics.py -> calculate_quality_score() (CC: 23)
  - agent/code_metrics.py -> detect_code_duplication() (CC: 20)
  - agent/git_utils.py -> initialize_git_repository() (CC: 14)
  - agent/patch_applicator.py -> _handle_replace() (CC: 15)
  - agent/patch_applicator.py -> _handle_delete_block() (CC: 21)
  - agent/patch_applicator.py -> apply_patches() (CC: 65)
  - agent/cycle_runner.py -> run_cycles() (CC: 89)
  - agent/project_scanner.py -> update_project_manifest() (CC: 45)
  - agent/project_scanner.py -> analyze_code_metrics() (CC: 47)
  - agent/utils/json_parser.py -> parse_json_response() (CC: 25)

Modules without Corresponding Test Files (consider creating tests):
  - cli.py
  - app.py
  - run_agent.py
  - agent/brain.py
  - agent/code_metrics.py
  - agent/hephaestus_agent.py
  - agent/git_utils.py
  - agent/code_validator.py
  - agent/patch_applicator.py
  - agent/cycle_runner.py
  - agent/memory.py
  - agent/prompt_builder.py
  - agent/tool_executor.py
  - agent/project_scanner.py
  - agent/state.py
  - agent/config_loader.py
  - agent/validation_steps/pytest_validator.py
  - agent/validation_steps/__init__.py
  - agent/validation_steps/base.py
  - agent/validation_steps/patch_applicator.py
  - agent/validation_steps/syntax_validator.py
  - agent/validation_steps/pytest_new_file_validator.py
  - agent/agents/architect_agent.py
  - agent/agents/performance_analyzer.py
  - agent/agents/error_correction.py
  - agent/agents/maestro_agent.py
  - agent/agents/error_analyzer.py
  - agent/utils/json_parser.py
  - agent/utils/llm_client.py

[CAPABILITIES DOCUMENT (CAPABILITIES.md)]
# Manifesto de Capacidades do Hephaestus

Este documento descreve as capacidades atuais e desejadas do agente Hephaestus, servindo como um guia para o seu desenvolvimento e para a geração de objetivos estratégicos. O foco principal é o **Aprimoramento Auto Recursivo (RSI)**, onde o agente busca ativamente melhorar suas próprias funções e arquitetura.

---

## 1. Capacidades Atuais

### 1.1. Análise e Planejamento
- **Geração de Objetivos (`agent/brain.py`):**
  - Analisa métricas de código estático (complexidade, tamanho do arquivo/função, cobertura de testes).
  - Analisa o manifesto do projeto (`AGENTS.md`).
  - Gera um objetivo de desenvolvimento com base na análise.
  - **Agora considera a análise de performance (`evolution_log.csv`) para otimizar prompts e estratégias.**
- **Análise de Erros (`agent/agents/error_analyzer.py`):**
  - Classifica falhas (ex: erro de sintaxe, falha de teste).
  - Propõe um prompt de correção para o `ArchitectAgent`.
  - **Pode sugerir objetivos de meta-análise para questionar o objetivo ou a estratégia original.**
- **Planejamento de Patches (`agent/agents/architect_agent.py`):**
  - Recebe um objetivo e o manifesto do projeto.
  - Gera um plano de patches em formato JSON para modificar a base de código.
- **Seleção de Estratégia (`agent/agents/maestro_agent.py`):**
  - Analisa o plano de patches.
  - Escolhe uma estratégia de validação apropriada (ex: apenas sintaxe, sintaxe e testes).

### 1.2. Execução e Validação
- **Aplicação de Patches (`agent/patch_applicator.py`):**
  - Aplica as modificações de código propostas em um ambiente de sandbox.
- **Validação de Sintaxe (`agent/validation_steps/syntax_validator.py`):**
  - Verifica a sintaxe de arquivos Python e JSON.
- **Execução de Testes (`agent/validation_steps/pytest_validator.py`):**
  - Executa a suíte de testes `pytest` para validar as alterações.
- **Gerenciamento de Estado e Ciclo (`agent/state.py`, `agent/cycle_runner.py`):**
  - Orquestra o fluxo completo de um ciclo de evolução.
  - Mantém o estado do ciclo atual (objetivo, patches, resultado da validação).
  - **O `cycle_runner.py` agora interage com um `QueueManager` para processar objetivos de forma assíncrona.**

### 1.3. Memória e Versionamento
- **Memória Persistente (`agent/memory.py`):**
  - Registra o histórico de objetivos bem-sucedidos e falhos.
  - Fornece contexto histórico para as decisões dos agentes.
- **Versionamento com Git (`agent/git_utils.py`):**
  - Inicializa o repositório Git.
  - Realiza commits automáticos após a validação bem-sucedida das alterações.

### 1.4. Infraestrutura (Nova)
- **Servidor FastAPI (`app.py`):**
  - Executa o Hephaestus como um serviço em segundo plano.
  - Expõe endpoints para submissão de objetivos e verificação de status.
  - Gerencia um thread worker para processar objetivos da fila.
- **Gerenciamento de Fila (`agent/queue_manager.py`):**
  - Permite a comunicação assíncrona de objetivos entre o servidor e o worker do agente.
- **Carregamento de Configuração (`agent/config_loader.py`):**
  - Módulo dedicado para carregar a configuração do agente de forma centralizada.

---

## 2. Capacidades Desejadas (Roadmap RSI)

O desenvolvimento futuro deve focar em aprimorar a capacidade do agente de entender e melhorar a si mesmo.

### 2.1. Meta-Cognição e Análise de Performance
- **Análise de Performance do Agente:**
  - **Objetivo:** Desenvolver a capacidade de analisar o próprio log de evolução (`evolution_log.csv`) para identificar gargalos, estratégias ineficazes e padrões de falha.
  - **Status:** Implementado. O `PerformanceAnalysisAgent` agora fornece uma análise detalhada do `evolution_log.csv`, incluindo taxa de sucesso geral, taxa de sucesso por estratégia e tempo médio de ciclo. O `generate_next_objective` utiliza essa análise para informar a geração de objetivos.
- **Análise de Causa Raiz (Meta-Análise):**
  - **Objetivo:** Aprimorar o `ErrorAnalysisAgent` para que, diante de falhas repetidas, ele possa questionar a validade do objetivo ou da estratégia, em vez de apenas tentar corrigir o código.
  - **Status:** Iniciado. O `ErrorAnalysisAgent` agora pode sugerir objetivos de meta-análise, e o `generate_next_objective` em `agent/brain.py` foi aprimorado para detectar e processar esses objetivos, gerando um novo objetivo estratégico para abordar a causa raiz da falha.

### 2.2. Aprimoramento da Arquitetura e Estratégia
- **Estratégias de Validação Dinâmicas:**
  - **Objetivo:** Permitir que o `MaestroAgent` não apenas escolha, mas também proponha a criação de novas estratégias de validação com base no contexto da tarefa.
  - **Status:** Iniciado. O `generate_next_objective` agora inclui a otimização de prompts e estratégias como uma prioridade, permitindo que o agente proponha modificações em `hephaestus_config.json` ou refinamento de prompts existentes com base na análise de performance.
- **Refatoração Orientada a Capacidades:**
  - **Objetivo:** Garantir que os objetivos de refatoração estejam sempre ligados a um aprimoramento de capacidade, e não apenas à melhoria de métricas de código.
  - **Status:** Não iniciado. (A base para isso foi estabelecida com a meta-análise e otimização de prompts, mas a refatoração explícita orientada a capacidades ainda não foi implementada).

### 2.3. Expansão de Ferramentas
- **Auto-Aprimoramento de Ferramentas:**
  - **Objetivo:** Dar ao agente a capacidade de modificar e aprimorar suas próprias ferramentas (ex: `tool_executor.py`) quando uma tarefa falha devido a uma limitação da ferramenta.
  - **Status:** Não iniciado. (A meta-análise de falhas pode identificar a necessidade de aprimoramento de ferramentas, mas a implementação autônoma ainda não está presente).

- **Acesso e Raciocínio com Conhecimento Externo:**
  - **Objetivo:** Implementar uma ferramenta de busca na web (`web_search`) robusta, permitindo que o agente pesquise documentação de APIs, soluções para erros e novas bibliotecas para resolver problemas que estão além de seu conhecimento atual.
  - **Status:** Não iniciado.

- **Gerenciamento de Estratégias Dinâmicas:**
  - **Objetivo:** O `MaestroAgent` deve evoluir de um simples selecionador de estratégias para um arquiteto de estratégias. Ele deve ser capaz de propor, e até mesmo codificar, novas estratégias de validação em `hephaestus_config.json` com base nos requisitos de um objetivo.
  - **Status:** Iniciado. O `generate_next_objective` agora inclui a otimização de prompts e estratégias como uma prioridade, permitindo que o agente proponha modificações em `hephaestus_config.json` ou refinamento de prompts existentes com base na análise de performance.


[ROADMAP DOCUMENT (ROADMAP.md)]
# Roadmap de Evolução do Hephaestus

Este documento delineia a visão de alto nível para a evolução do Hephaestus como um agente de **Aprimoramento Auto Recursivo (RSI)**. Ele serve como um guia estratégico, enquanto o `CAPABILITIES.md` detalha os passos táticos.

---

## Fase 1: Consciência e Correção (Curto Prazo)

O foco desta fase é fazer com que o agente pare de executar tarefas cegamente e comece a entender seu próprio desempenho e a corrigir suas falhas de forma mais inteligente.

-   [x] **1. Análise de Performance:**
    -   **Visão:** O agente deve ser capaz de ler seu próprio log de performance (`evolution_log.csv`) e responder a perguntas como: "Qual é a minha taxa de sucesso?", "Quais estratégias falham mais?" e "Onde estou gastando mais tempo?".
    -   **Status:** Implementado. O `PerformanceAnalysisAgent` agora fornece uma análise detalhada do `evolution_log.csv`, incluindo taxa de sucesso geral, taxa de sucesso por estratégia e tempo médio de ciclo. O `generate_next_objective` utiliza essa análise para informar a geração de objetivos.

-   [x] **2. Meta-Análise de Falhas:**
    -   **Visão:** Quando uma tarefa falha repetidamente, o agente deve parar de tentar corrigir o código e, em vez disso, questionar o objetivo em si. Ele deve ser capaz de concluir: "Esta abordagem não está funcionando, preciso de uma nova estratégia ou de uma nova ferramenta".
    -   **Status:** Iniciado. O `ErrorAnalysisAgent` agora pode sugerir objetivos de meta-análise, e o `generate_next_objective` em `agent/brain.py` foi aprimorado para detectar e processar esses objetivos, gerando um novo objetivo estratégico para abordar a causa raiz da falha.

-   [ ] **3. Refatoração Orientada a Capacidades:**
    -   **Visão:** O agente só deve propor refatorações de código se elas estiverem diretamente ligadas a um objetivo de capacitação, como "preciso refatorar este módulo para conseguir implementar uma nova ferramenta de análise".
    -   **Status:** Não iniciado. (A base para isso foi estabelecida com a meta-análise e otimização de prompts, mas a refatoração explícita orientada a capacidades ainda não foi implementada).

---

## Fase 2: Expansão de Habilidades (Médio Prazo)

Com a consciência básica estabelecida, o foco se volta para a expansão proativa de suas próprias habilidades e ferramentas.

-   [ ] **1. Auto-Aprimoramento de Ferramentas:**
    -   **Visão:** O agente deve ser capaz de modificar suas próprias ferramentas (`tool_executor.py`, `validation_steps/`, etc.) quando encontrar uma limitação. Se uma validação é muito fraca ou uma ferramenta não tem um parâmetro necessário, ele deve ser capaz de adicioná-lo.
    -   **Status:** Não iniciado. (A meta-análise de falhas pode identificar a necessidade de aprimoramento de ferramentas, mas a implementação autônoma ainda não está presente).

-   [ ] **2. Acesso e Raciocínio com Conhecimento Externo:**
    -   **Visão:** Implementar uma ferramenta de busca na web (`web_search`) robusta, permitindo que o agente pesquise documentação de APIs, soluções para erros e novas bibliotecas para resolver problemas que estão além de seu conhecimento atual.
    -   **Status:** Não iniciado.

-   [x] **3. Gerenciamento de Estratégias Dinâmicas:**
    -   **Visão:** O `MaestroAgent` deve evoluir de um simples selecionador de estratégias para um arquiteto de estratégias. Ele deve ser capaz de propor, e até mesmo codificar, novas estratégias de validação em `hephaestus_config.json` com base nos requisitos de um objetivo.
    -   **Status:** Iniciado. O `generate_next_objective` agora inclui a otimização de prompts e estratégias como uma prioridade, permitindo que o agente proponha modificações em `hephaestus_config.json` ou refinamento de prompts existentes com base na análise de performance.

---

## Fase 3: Autonomia Estratégica (Longo Prazo)

Nesta fase, o agente transcende a execução de ciclos e começa a gerenciar seu próprio desenvolvimento de forma estratégica.

-   [ ] **1. Planejamento de Longo Prazo:**
    -   **Visão:** O agente deve ser capaz de analisar este próprio `ROADMAP.md` e o `CAPABILITIES.md` para gerar um plano de desenvolvimento de múltiplos passos para si mesmo, em vez de operar em um ciclo de objetivo único.
    -   **Status:** Não iniciado.

-   [ ] **2. Auto-Otimização de Modelos:**
    -   **Visão:** Capturar os prompts e as respostas de maior sucesso para criar conjuntos de dados de fine-tuning. O objetivo final é treinar versões especializadas dos modelos de LLM que sejam mais eficientes e precisas para as tarefas do Hephaestus.
    -   **Status:** Não iniciado.

-   [ ] **3. Arquitetura de Agentes Dinâmica:**
    -   **Visão:** O agente deve ser capaz de propor e implementar mudanças em sua própria arquitetura de agentes, como criar um novo agente especializado (ex: `DocumentationAgent`) ou dividir as responsabilidades de um agente existente, para melhorar a eficiência do sistema.
    -   **Status:** Não iniciado.

---

## Arquitetura de Servidor (Novo)

-   [x] **1. Transformação em Servidor FastAPI:**
    -   **Visão:** O Hephaestus opera como um servidor em segundo plano, permitindo a submissão assíncrona de objetivos e monitoramento de status via API.
    -   **Status:** Implementado. O `main.py` agora inicia um servidor FastAPI, e o agente é executado em um thread worker separado, utilizando um `QueueManager` para gerenciar os objetivos.



[CURRENT PROJECT MANIFEST (if existing)]
# MANIFESTO DO PROJETO HEPHAESTUS

## 1. ESTRUTURA DE ARQUIVOS (OTIMIZADA)
agente_autonomo/
    README.md
    hephaestus.log
    cli.py
    AGENTS.md
    poetry.lock
    CONTRIBUTING.md
    app.py
    HEPHAESTUS_MEMORY.json
    main.py
    ROADMAP.md
    hephaestus_config.json
    requirements.txt
    run_agent.py
    MANIFESTO.md
    evolution_log.csv
    CODE_OF_CONDUCT.md
    ANALISE_PERFORMANCE_HEPHAESTUS.md
    ISSUES.md
    ANALISE_TECNICA_HEPHAESTUS.md
    Sugestões de Melhoria para o Projeto Agente Autônomo.md
    CAPABILITIES.md
    pyproject.toml
    agent/
        brain.py
        __init__.py
        code_metrics.py
        hephaestus_agent.py
        git_utils.py
        code_validator.py
        patch_applicator.py
        cycle_runner.py
        memory.py
        prompt_builder.py
        tool_executor.py
        project_scanner.py
        queue_manager.py
        state.py
        config_loader.py
        validation_steps/
            pytest_validator.py
            __init__.py
            base.py
            patch_applicator.py
            syntax_validator.py
            pytest_new_file_validator.py
        agents/
            __init__.py
            architect_agent.py
            performance_analyzer.py
            error_correction.py
            maestro_agent.py
            error_analyzer.py
        utils/
            __init__.py
            json_parser.py
            llm_client.py
    config/
        example_config.yaml
        base_config.yaml
        default.yaml
        models/
            main.yaml
        validation_strategies/
            main.yaml

## 2. RESUMO DAS INTERFACES (APIs Internas)

### Arquivo: `cli.py`
- **Função:** `run(continuous: bool=typer.Option(False, '--continuous', '-c', help='Run in continuous mode'), max_cycles: int=typer.Option(None, '--max-cycles', '-m', help='Maximum number of evolution cycles'))`
  - *Run the Hephaestus agent*
- **Função:** `submit(objective: str)`
  - *Submit a new objective to the agent*
- **Função:** `status()`
  - *Check agent status*

### Arquivo: `app.py`
- **Classe:** `Objective(BaseModel)`
- **Função:** `startup_event()`
- **Função:** `submit_objective(obj: Objective)`
- **Função:** `get_status()`

### Arquivo: `main.py`

### Arquivo: `run_agent.py`

### Arquivo: `agent/brain.py`
- **Função:** `generate_next_objective(model_config: Dict[str, str], current_manifest: str, logger: logging.Logger, project_root_dir: str, config: Optional[Dict[str, Any]]=None, memory_summary: Optional[str]=None, current_objective: Optional[str]=None)`
  - *Generates the next evolutionary objective using a lightweight model and code analysis.*
- **Função:** `generate_capacitation_objective(model_config: Dict[str, str], engineer_analysis: str, memory_summary: Optional[str]=None, logger: Optional[logging.Logger]=None)`
  - *Generates an objective to create necessary new capabilities.*
- **Função:** `generate_commit_message(model_config: Dict[str, str], analysis_summary: str, objective: str, logger: logging.Logger)`
  - *Generates a concise and informative commit message using an LLM.*

### Arquivo: `agent/__init__.py`

### Arquivo: `agent/code_metrics.py`
- **Função:** `analyze_complexity(code_string: str)`
  - *Analyzes the cyclomatic complexity and other metrics of the given Python code string using Radon.*
- **Função:** `calculate_quality_score(complexity_report: dict, duplication_report: list)`
  - *Calculates a quality score based on complexity, duplication, and other code metrics.*
- **Função:** `_get_code_lines(code_string: str, strip_comments_blanks: bool=True)`
  - *Returns a list of (original_line_number, line_content) tuples.*
- **Função:** `_find_duplicates_for_block(block_to_check: list[str], all_lines: list[tuple[int, str]], start_index: int, min_lines: int)`
  - *Finds occurrences of block_to_check in all_lines, starting after start_index.*
- **Função:** `detect_code_duplication(code_string: str, min_lines: int=4, strip_comments_and_blanks: bool=True)`
  - *Detects duplicated code blocks in the given Python code string.*

### Arquivo: `agent/hephaestus_agent.py`
- **Classe:** `HephaestusAgent`
  - *Classe principal que encapsula a lógica do agente autônomo.*

### Arquivo: `agent/git_utils.py`
- **Função:** `initialize_git_repository(logger: logging.Logger)`
  - *Ensure a git repository exists and is configured.*

### Arquivo: `agent/code_validator.py`
- **Função:** `perform_deep_validation(file_path: Path, logger: logging.Logger)`
  - *Realiza uma análise profunda da qualidade do código Python.*
- **Função:** `validate_python_code(file_path: str | Path, logger: logging.Logger, perform_deep_analysis: bool=True)`
  - *Valida se o código Python em um arquivo é sintaticamente correto e, opcionalmente, realiza uma análise profunda.*
- **Função:** `validate_json_syntax(file_path: str | Path, logger: logging.Logger)`
  - *Valida se um arquivo contém JSON válido.*

### Arquivo: `agent/patch_applicator.py`
- **Função:** `_handle_insert(full_path: Path, lines: list[str], instruction: dict, logger: logging.Logger)`
  - *Apply an INSERT patch and return ``(success, updated_lines)``.*
- **Função:** `_handle_replace(full_path: Path, lines: list[str], instruction: dict, logger: logging.Logger)`
  - *Apply a REPLACE patch.*
- **Função:** `_handle_delete_block(full_path: Path, lines: list[str], instruction: dict, logger: logging.Logger)`
  - *Apply a DELETE_BLOCK patch.*
- **Função:** `apply_patches(instructions: list[dict], logger: logging.Logger, base_path: str='.')`
  - *Aplica uma lista de instruções de patch aos arquivos.*

### Arquivo: `agent/cycle_runner.py`
- **Função:** `run_cycles(agent: 'HephaestusAgent', queue_manager: QueueManager)`
  - *Execute the main evolution loop for the given agent.*

### Arquivo: `agent/memory.py`
- **Classe:** `Memory`
  - *Manages persistent memory for the Hephaestus agent, storing historical data*

### Arquivo: `agent/prompt_builder.py`
- **Função:** `build_memory_context_section(memory_summary: Optional[str])`
  - *Constrói a seção de contexto da memória para os prompts.*
- **Função:** `build_initial_objective_prompt(memory_context_section: str)`
  - *Constrói o prompt para gerar o objetivo inicial quando não há manifesto ou análise de código.*
- **Função:** `build_meta_analysis_objective_prompt(current_objective: str, original_failed_objective: str, error_reason_for_meta: str, performance_summary_str: str, memory_context_section: str, capabilities_content: str, roadmap_content: str)`
  - *Constrói o prompt para gerar um objetivo estratégico após uma meta-análise de falha.*
- **Função:** `build_standard_objective_prompt(memory_context_section: str, performance_summary_str: str, code_analysis_summary_str: str, current_manifest: str, capabilities_content: str, roadmap_content: str)`
  - *Constrói o prompt padrão para gerar o próximo objetivo estratégico.*

### Arquivo: `agent/tool_executor.py`
- **Função:** `run_pytest(test_dir: str='tests/', cwd: str | Path | None=None)`
  - *Executa testes pytest no diretório especificado e retorna resultados.*
- **Função:** `check_file_existence(file_paths: list[str])`
  - *Verifica se todos os arquivos especificados existem.*
- **Função:** `run_in_sandbox(temp_dir_path: str, objective: str)`
  - *Executa o main.py de um diretório isolado monitorando tempo e memória.*
- **Função:** `run_git_command(command: list[str])`
  - *Executa um comando Git e retorna o status e a saída.*
- **Função:** `web_search(query: str)`
  - *Realiza uma pesquisa na web usando a API DuckDuckGo e retorna os resultados.*

### Arquivo: `agent/project_scanner.py`
- **Função:** `_extract_elements(code_string: str)`
- **Função:** `_extract_skeleton(code_string: str)`
- **Função:** `update_project_manifest(root_dir: str, target_files: List[str], output_path: str='AGENTS.md', excluded_dir_patterns: Optional[List[str]]=None)`
- **Função:** `analyze_code_metrics(root_dir: str, excluded_dir_patterns: Optional[List[str]]=None, file_loc_threshold: int=300, func_loc_threshold: int=50, func_cc_threshold: int=10)`
  - *Analisa arquivos Python em um diretório para métricas de código como LOC e Complexidade Ciclomática.*

### Arquivo: `agent/queue_manager.py`
- **Classe:** `QueueManager`

### Arquivo: `agent/state.py`
- **Classe:** `AgentState`
  - *Representa o estado interno do agente Hephaestus durante um ciclo de processamento.*

### Arquivo: `agent/config_loader.py`
- **Função:** `load_config()`
  - *Load configuration using Hydra.*

### Arquivo: `agent/validation_steps/pytest_validator.py`
- **Classe:** `PytestValidator(ValidationStep)`
  - *Runs pytest as a validation step.*

### Arquivo: `agent/validation_steps/__init__.py`
- **Classe:** `BenchmarkValidator(ValidationStep)`
- **Classe:** `CheckFileExistenceValidator(ValidationStep)`
- **Classe:** `ValidateJsonSyntax(ValidationStep)`
- **Função:** `get_validation_step(name: str)`

### Arquivo: `agent/validation_steps/base.py`
- **Classe:** `ValidationStep(ABC)`
  - *Abstract base class for a validation step.*

### Arquivo: `agent/validation_steps/patch_applicator.py`
- **Classe:** `PatchApplicatorStep(ValidationStep)`
  - *Applies patches to the specified base path.*

### Arquivo: `agent/validation_steps/syntax_validator.py`
- **Classe:** `SyntaxValidator(ValidationStep)`
  - *Validates the syntax of Python and JSON files.*

### Arquivo: `agent/validation_steps/pytest_new_file_validator.py`
- **Classe:** `PytestNewFileValidator(ValidationStep)`
  - *A validation step that runs pytest specifically on newly created test files.*

### Arquivo: `agent/agents/__init__.py`

### Arquivo: `agent/agents/architect_agent.py`
- **Classe:** `ArchitectAgent`

### Arquivo: `agent/agents/performance_analyzer.py`
- **Classe:** `PerformanceAnalysisAgent`
  - *An agent dedicated to analyzing the performance of Hephaestus.*

### Arquivo: `agent/agents/error_correction.py`
- **Classe:** `ErrorCorrectionAgent`
  - *Agent for analyzing errors and generating corrective actions.*

### Arquivo: `agent/agents/maestro_agent.py`
- **Classe:** `MaestroAgent`

### Arquivo: `agent/agents/error_analyzer.py`
- **Classe:** `ErrorAnalysisAgent`

### Arquivo: `agent/utils/__init__.py`

### Arquivo: `agent/utils/json_parser.py`
- **Função:** `parse_json_response(raw_str: str, logger: logging.Logger)`
  - *Analisa uma string bruta que se espera conter JSON, limpando-a e decodificando-a.*

### Arquivo: `agent/utils/llm_client.py`
- **Função:** `call_gemini_api(model: str, prompt: str, temperature: float, max_tokens: Optional[int], logger: logging.Logger)`
  - *Calls the Google Gemini API.*
- **Função:** `call_openrouter_api(model: str, prompt: str, temperature: float, max_tokens: Optional[int], logger: logging.Logger)`
  - *Calls a generic OpenAI-compatible API (like OpenRouter).*
- **Função:** `call_llm_with_fallback(model_config: Dict[str, Any], prompt: str, temperature: float, logger: logging.Logger)`
  - *Orchestrates LLM calls with a primary and fallback model.*

## 3. CONTEÚDO COMPLETO DOS ARQUIVOS ALVO


[Examples of Smart and Self-Aware Objectives]
*   **Performance-Based Objectives:**
    *   "The agent's success rate is low. Analyze the `evolution_log.csv` to identify the most common causes of failure and propose a solution."
    *   "Given the high number of failed cycles, implement a more robust error analysis mechanism in `error_analyzer.py`."
*   **Prompt/Strategy Optimization Objectives (RSI Focus):**
    *   "The 'SYNTAX_ONLY' strategy has a high failure rate. Analyze the prompts used by the ArchitectAgent when this strategy is chosen and propose modifications to improve syntax correctness."
    *   "Propose a new validation strategy in `hephaestus_config.json` called 'ADVANCED_LINTING' that includes `ruff` checks before applying patches, to reduce syntax errors."
    *   "Analyze the `MaestroAgent`'s decision-making process for objectives related to documentation updates, as the 'DOC_UPDATE_STRATEGY' has a low success rate. Refine its prompt to improve accuracy."
*   **Metrics-Based Refactoring:**
    *   "Refactor the module `agent/brain.py` (LOC: 350) which is extensive, considering splitting responsibilities into smaller modules (e.g., `agent/prompt_builder.py` or `agent/analysis_processor.py`)."
    *   "The function `generate_next_objective` in `agent/brain.py` (LOC: 85, CC: 12) is long and complex. Propose a plan to refactor it into smaller, more focused functions."
    *   "Analyze the most complex functions (CC > 10) listed in the metrics and select one for refactoring."
*   **Test Creation (Generate New Test Files):**
    *   "The module `agent/project_scanner.py` is missing a test file. Create a new test file `tests/agent/test_project_scanner.py` with basic unit tests for the `analyze_code_metrics` function."
    *   "Module `agent/memory.py` lacks tests. Generate `tests/agent/test_memory.py` and include placeholder tests for its public functions."
    *   "Create unit tests for the module `agent/tool_executor.py` in a new file `tests/agent/test_tool_executor.py`, focusing on the `web_search` function."
    *   "The function `call_llm_api` in `agent/utils/llm_client.py` is critical. Ensure robust unit tests exist for it in `tests/agent/utils/test_llm_client.py`, covering success and failure cases. If the test file doesn't exist, create it."
*   **Test-Driven Development (TDD) Flow:**
    *   "The previous cycle successfully created a new test file `tests/agent/test_new_feature.py` which is now failing as expected. The next objective is to implement the minimal code in `agent/new_feature.py` required to make the tests in `tests/agent/test_new_feature.py` pass."
*   **Strategic Documentation Improvement:**
    *   "The manifest (`AGENTS.md`) does not describe the new metrics analysis functionality in `project_scanner.py`. Update it."
    *   "Improve docstrings for public functions in the `agent/memory.py` module to detail parameters and expected behavior."
*   **Development of New Capabilities (Agents/Tools):**
    *   "Create a new agent (e.g., `CodeQualityAgent` in `agent/agents.py`) dedicated to continuously monitoring code quality metrics and reporting regressions."
    *   "Develop a new tool in `agent/tool_executor.py` to automatically validate the syntax of JSON files before processing."
    *   "Propose a system for Hephaestus to evaluate the performance of its own operations and identify bottlenecks."
*   **Generic Objectives (when metrics/manifest are insufficient):**
    *   "Analyze the `agent/state.py` module to identify potential improvements in clarity or efficiency."
    *   "Review recent logs for frequent errors and propose an objective to fix them."

[Your Task]
Based on ALL the information provided (metrics, manifest, history), generate ONLY a single text string containing the NEXT STRATEGIC OBJECTIVE. The objective should be the most impactful and logical for the project's evolution at this moment.
Be concise, but specific enough to be actionable.

2025-07-03 20:03:28,417 - HephaestusAgent - INFO - Calling primary model: gemini/gemini-2.5-pro
2025-07-03 20:03:28,417 - HephaestusAgent - INFO - Attempting to call Gemini API with model: gemini/gemini-2.5-pro
2025-07-03 20:04:04,237 - HephaestusAgent - DEBUG - Gemini API Response: Considerando que o módulo `agent/project_scanner.py` é um dos mais complexos do projeto (contendo as funções `analyze_code_metrics` com CC 47 e `update_project_manifest` com CC 45) e não possui qualquer cobertura de teste, e que as tentativas recentes de abordar o módulo `cycle_runner` (CC 89) falharam repetidamente, o próximo passo estratégico é mudar o foco para fortalecer a robustez de outro componente central. Crie um novo arquivo de teste `tests/agent/test_project_scanner.py` com uma estrutura básica e um teste placeholder, estabelecendo a base para testar e, futuramente, refatorar com segurança as capacidades de análise de código do agente.
2025-07-03 20:04:04,237 - HephaestusAgent - INFO - Próximo objetivo: Considerando que o módulo `agent/project_scanner.py` é um dos mais complexos do projeto (contendo as funções `analyze_code_metrics` com CC 47 e `update_project_manifest` com CC 45) e não possui qualquer cobertura de teste, e que as tentativas recentes de abordar o módulo `cycle_runner` (CC 89) falharam repetidamente, o próximo passo estratégico é mudar o foco para fortalecer a robustez de outro componente central. Crie um novo arquivo de teste `tests/agent/test_project_scanner.py` com uma estrutura básica e um teste placeholder, estabelecendo a base para testar e, futuramente, refatorar com segurança as capacidades de análise de código do agente.
2025-07-03 20:04:04,238 - HephaestusAgent - INFO - Memória salva em HEPHAESTUS_MEMORY.json (7 completed, 4 failed)
2025-07-03 20:04:04,238 - HephaestusAgent - INFO - ==================== FIM DO CICLO DE EVOLUÇÃO ====================
2025-07-03 20:04:05,239 - HephaestusAgent - INFO - 

==================== INÍCIO DO CICLO DE EVOLUÇÃO (Ciclo #6) ====================
2025-07-03 20:04:05,239 - HephaestusAgent - INFO - OBJETIVO ATUAL: Considerando que o módulo `agent/project_scanner.py` é um dos mais complexos do projeto (contendo as funções `analyze_code_metrics` com CC 47 e `update_project_manifest` com CC 45) e não possui qualquer cobertura de teste, e que as tentativas recentes de abordar o módulo `cycle_runner` (CC 89) falharam repetidamente, o próximo passo estratégico é mudar o foco para fortalecer a robustez de outro componente central. Crie um novo arquivo de teste `tests/agent/test_project_scanner.py` com uma estrutura básica e um teste placeholder, estabelecendo a base para testar e, futuramente, refatorar com segurança as capacidades de análise de código do agente.

2025-07-03 20:04:05,239 - HephaestusAgent - INFO - Gerando manifesto do projeto (AGENTS.md)...
2025-07-03 20:04:05,297 - HephaestusAgent - INFO - --- MANIFESTO GERADO (Tamanho: 34493 caracteres) ---
2025-07-03 20:04:05,297 - HephaestusAgent - INFO - 
Solicitando plano de ação do ArchitectAgent...
2025-07-03 20:04:05,297 - HephaestusAgent.ArchitectAgent - INFO - ArchitectAgent: Gerando plano de patches com os modelos: {'_target_': 'builtins.dict', 'temperature': 0.3, 'max_tokens': -1, 'primary': 'gemini/gemini-2.5-pro', 'fallback': 'deepseek/deepseek-r1-0528:free'}...
2025-07-03 20:04:05,297 - HephaestusAgent.ArchitectAgent - INFO - Calling primary model: gemini/gemini-2.5-pro
2025-07-03 20:04:05,297 - HephaestusAgent.ArchitectAgent - INFO - Attempting to call Gemini API with model: gemini/gemini-2.5-pro
