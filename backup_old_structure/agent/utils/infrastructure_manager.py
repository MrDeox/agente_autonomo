"""
Infrastructure Manager - Garantia de Infraestrutura B√°sica

Este m√≥dulo garante que toda a infraestrutura b√°sica necess√°ria esteja presente
e funcionando corretamente antes do sistema iniciar.
"""

import os
import sys
import logging
import shutil
from pathlib import Path
from typing import Dict, List, Tuple, Optional, Any
import subprocess
import json

class InfrastructureManager:
    """Gerenciador de infraestrutura b√°sica do sistema"""
    
    def __init__(self, logger: Optional[logging.Logger] = None):
        self.logger = logger or logging.getLogger(__name__)
        self.project_root = Path.cwd()
        
        # Diret√≥rios essenciais
        self.essential_dirs = [
            "logs",
            "reports",
            "reports/memory",
            "tests",
            "config"
        ]
        
        # Arquivos essenciais
        self.essential_files = {
            "logs/.gitkeep": "",
            "reports/.gitkeep": "",
            "reports/memory/.gitkeep": "",
            ".gitignore": self._get_default_gitignore()
        }
    
    def ensure_infrastructure(self) -> bool:
        """Garante que toda a infraestrutura necess√°ria esteja presente"""
        self.logger.info("üèóÔ∏è Verificando infraestrutura b√°sica...")
        
        success = True
        
        # 1. Criar diret√≥rios essenciais
        success &= self._ensure_directories()
        
        # 2. Criar arquivos essenciais
        success &= self._ensure_files()
        
        # 3. Verificar depend√™ncias
        success &= self._check_dependencies()
        
        # 4. Verificar configura√ß√µes
        success &= self._validate_configurations()
        
        if success:
            self.logger.info("‚úÖ Infraestrutura verificada com sucesso")
        else:
            self.logger.error("‚ùå Problemas encontrados na infraestrutura")
        
        return success
    
    def _ensure_directories(self) -> bool:
        """Garante que todos os diret√≥rios essenciais existam"""
        self.logger.info("üìÅ Criando diret√≥rios essenciais...")
        
        try:
            for dir_path in self.essential_dirs:
                full_path = self.project_root / dir_path
                if not full_path.exists():
                    full_path.mkdir(parents=True, exist_ok=True)
                    self.logger.info(f"   ‚úÖ Criado: {dir_path}")
                else:
                    self.logger.debug(f"   ‚úì Existente: {dir_path}")
            
            return True
            
        except Exception as e:
            self.logger.error(f"Erro ao criar diret√≥rios: {e}")
            return False
    
    def _ensure_files(self) -> bool:
        """Garante que todos os arquivos essenciais existam"""
        self.logger.info("üìÑ Criando arquivos essenciais...")
        
        try:
            for file_path, content in self.essential_files.items():
                full_path = self.project_root / file_path
                if not full_path.exists():
                    full_path.parent.mkdir(parents=True, exist_ok=True)
                    with open(full_path, 'w', encoding='utf-8') as f:
                        f.write(content)
                    self.logger.info(f"   ‚úÖ Criado: {file_path}")
                else:
                    self.logger.debug(f"   ‚úì Existente: {file_path}")
            
            return True
            
        except Exception as e:
            self.logger.error(f"Erro ao criar arquivos: {e}")
            return False
    
    def _check_dependencies(self) -> bool:
        """Verifica e corrige problemas de depend√™ncias"""
        self.logger.info("üì¶ Verificando depend√™ncias...")
        
        try:
            # Verificar se temos pyproject.toml E requirements.txt
            has_pyproject = (self.project_root / "pyproject.toml").exists()
            has_requirements = (self.project_root / "requirements.txt").exists()
            
            if has_pyproject and has_requirements:
                self.logger.warning("‚ö†Ô∏è Depend√™ncias duplicadas detectadas:")
                self.logger.warning("   ‚Ä¢ pyproject.toml (Poetry)")
                self.logger.warning("   ‚Ä¢ requirements.txt (pip)")
                
                # Sugerir a√ß√£o
                self.logger.info("üí° Recomenda√ß√£o: Use apenas Poetry (pyproject.toml)")
                self.logger.info("   Para gerar requirements.txt do Poetry:")
                self.logger.info("   poetry export -f requirements.txt --output requirements.txt")
                
                return True  # N√£o √© erro fatal, apenas aviso
            
            elif has_pyproject:
                self.logger.info("‚úÖ Usando Poetry (pyproject.toml)")
                return True
            
            elif has_requirements:
                self.logger.info("‚úÖ Usando pip (requirements.txt)")
                return True
            
            else:
                self.logger.error("‚ùå Nenhum arquivo de depend√™ncias encontrado!")
                return False
            
        except Exception as e:
            self.logger.error(f"Erro ao verificar depend√™ncias: {e}")
            return False
    
    def _validate_configurations(self) -> bool:
        """Valida configura√ß√µes cr√≠ticas"""
        self.logger.info("‚öôÔ∏è Validando configura√ß√µes...")
        
        try:
            # Verificar hephaestus_config.json
            config_path = self.project_root / "hephaestus_config.json"
            if config_path.exists():
                try:
                    with open(config_path, 'r', encoding='utf-8') as f:
                        config = json.load(f)
                    self.logger.info("   ‚úÖ hephaestus_config.json v√°lido")
                    
                    # Verificar se tem estrat√©gias
                    strategies = config.get("validation_strategies", {})
                    if strategies:
                        self.logger.info(f"   ‚úÖ {len(strategies)} estrat√©gias carregadas")
                    else:
                        self.logger.warning("   ‚ö†Ô∏è Nenhuma estrat√©gia encontrada")
                    
                except json.JSONDecodeError as e:
                    self.logger.error(f"   ‚ùå JSON inv√°lido: {e}")
                    return False
            else:
                self.logger.warning("   ‚ö†Ô∏è hephaestus_config.json n√£o encontrado")
            
            # Verificar configura√ß√µes Hydra
            hydra_config = self.project_root / "config" / "default.yaml"
            if hydra_config.exists():
                self.logger.info("   ‚úÖ Configura√ß√£o Hydra encontrada")
            else:
                self.logger.warning("   ‚ö†Ô∏è Configura√ß√£o Hydra n√£o encontrada")
            
            return True
            
        except Exception as e:
            self.logger.error(f"Erro ao validar configura√ß√µes: {e}")
            return False
    
    def _get_default_gitignore(self) -> str:
        """Retorna conte√∫do padr√£o do .gitignore"""
        return """# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
.hypothesis/
.pytest_cache/

# Virtual environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
logs/*.log
logs/*.csv
reports/
*.tmp
.hydra/
outputs/

# API Keys (security)
.env.local
.env.*.local
config/local/
secrets/
"""
    
    def diagnose_system(self) -> Dict[str, Any]:
        """Faz diagn√≥stico completo do sistema"""
        self.logger.info("üîç Executando diagn√≥stico completo...")
        
        diagnosis = {
            "directories": {},
            "files": {},
            "dependencies": {},
            "configurations": {},
            "issues": [],
            "recommendations": []
        }
        
        # Verificar diret√≥rios
        for dir_path in self.essential_dirs:
            full_path = self.project_root / dir_path
            diagnosis["directories"][dir_path] = {
                "exists": full_path.exists(),
                "writable": full_path.exists() and os.access(full_path, os.W_OK)
            }
            
            if not full_path.exists():
                diagnosis["issues"].append(f"Diret√≥rio ausente: {dir_path}")
                diagnosis["recommendations"].append(f"Criar diret√≥rio: {dir_path}")
        
        # Verificar arquivos
        for file_path in self.essential_files:
            full_path = self.project_root / file_path
            diagnosis["files"][file_path] = {
                "exists": full_path.exists(),
                "readable": full_path.exists() and os.access(full_path, os.R_OK)
            }
        
        # Verificar depend√™ncias
        has_pyproject = (self.project_root / "pyproject.toml").exists()
        has_requirements = (self.project_root / "requirements.txt").exists()
        
        diagnosis["dependencies"] = {
            "pyproject_toml": has_pyproject,
            "requirements_txt": has_requirements,
            "duplicated": has_pyproject and has_requirements
        }
        
        if has_pyproject and has_requirements:
            diagnosis["issues"].append("Depend√™ncias duplicadas (pyproject.toml + requirements.txt)")
            diagnosis["recommendations"].append("Usar apenas Poetry ou sincronizar arquivos")
        
        # Verificar configura√ß√µes
        config_files = [
            "hephaestus_config.json",
            "config/default.yaml",
            "config/base_config.yaml"
        ]
        
        for config_file in config_files:
            full_path = self.project_root / config_file
            is_valid = True
            
            if full_path.exists():
                try:
                    if config_file.endswith('.json'):
                        with open(full_path, 'r') as f:
                            json.load(f)
                    # YAML validation would require PyYAML
                except:
                    is_valid = False
            
            diagnosis["configurations"][config_file] = {
                "exists": full_path.exists(),
                "valid": is_valid
            }
        
        return diagnosis
    
    def fix_infrastructure_issues(self, diagnosis: Optional[Dict] = None) -> bool:
        """Corrige problemas de infraestrutura identificados"""
        if not diagnosis:
            diagnosis = self.diagnose_system()
        
        self.logger.info("üîß Corrigindo problemas de infraestrutura...")
        
        fixed_issues = 0
        total_issues = len(diagnosis.get("issues", []))
        
        try:
            # Corrigir diret√≥rios ausentes
            for dir_path, info in diagnosis["directories"].items():
                if not info["exists"]:
                    full_path = self.project_root / dir_path
                    full_path.mkdir(parents=True, exist_ok=True)
                    self.logger.info(f"   ‚úÖ Corrigido: Criado diret√≥rio {dir_path}")
                    fixed_issues += 1
            
            # Corrigir arquivos ausentes
            for file_path, info in diagnosis["files"].items():
                if not info["exists"]:
                    full_path = self.project_root / file_path
                    full_path.parent.mkdir(parents=True, exist_ok=True)
                    content = self.essential_files.get(file_path, "")
                    with open(full_path, 'w', encoding='utf-8') as f:
                        f.write(content)
                    self.logger.info(f"   ‚úÖ Corrigido: Criado arquivo {file_path}")
                    fixed_issues += 1
            
            self.logger.info(f"üéØ Corrigidos {fixed_issues}/{total_issues} problemas")
            return fixed_issues == total_issues
            
        except Exception as e:
            self.logger.error(f"Erro ao corrigir infraestrutura: {e}")
            return False
    
    def get_system_status(self) -> Dict[str, Any]:
        """Retorna status detalhado do sistema"""
        diagnosis = self.diagnose_system()
        
        total_dirs = len(diagnosis["directories"])
        healthy_dirs = sum(1 for info in diagnosis["directories"].values() if info["exists"])
        
        total_files = len(diagnosis["files"])
        healthy_files = sum(1 for info in diagnosis["files"].values() if info["exists"])
        
        total_configs = len(diagnosis["configurations"])
        healthy_configs = sum(1 for info in diagnosis["configurations"].values() if info["exists"] and info["valid"])
        
        return {
            "overall_health": "healthy" if len(diagnosis["issues"]) == 0 else "issues_detected",
            "directories": f"{healthy_dirs}/{total_dirs}",
            "files": f"{healthy_files}/{total_files}",
            "configurations": f"{healthy_configs}/{total_configs}",
            "total_issues": len(diagnosis["issues"]),
            "diagnosis": diagnosis
        }


def ensure_basic_infrastructure(logger: Optional[logging.Logger] = None) -> bool:
    """Fun√ß√£o utilit√°ria para garantir infraestrutura b√°sica"""
    manager = InfrastructureManager(logger)
    return manager.ensure_infrastructure()


def diagnose_and_fix_infrastructure(logger: Optional[logging.Logger] = None) -> bool:
    """Fun√ß√£o utilit√°ria para diagnosticar e corrigir infraestrutura"""
    manager = InfrastructureManager(logger)
    diagnosis = manager.diagnose_system()
    
    if diagnosis["issues"]:
        return manager.fix_infrastructure_issues(diagnosis)
    else:
        if logger:
            logger.info("‚úÖ Nenhum problema de infraestrutura encontrado")
        return True


# Fun√ß√£o para integra√ß√£o com outros m√≥dulos
def get_infrastructure_manager(logger: Optional[logging.Logger] = None) -> InfrastructureManager:
    """Retorna inst√¢ncia do gerenciador de infraestrutura"""
    return InfrastructureManager(logger) 