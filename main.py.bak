from dotenv import load_dotenv
import os
import sys
from agent.project_scanner import update_project_manifest
from agent.brain import get_ai_suggestion
from agent.file_manager import apply_changes
from agent.code_validator import validate_python_code
from agent.tool_executor import run_pytest

# Objetivo inicial fixo conforme especificado
initial_objective = (
    "O projeto contém um arquivo de backup obsoleto ('agent/project_scanner.py.bak') que precisa ser removido. "
    "Sua tarefa é: 1. Se necessário, adicionar uma nova ferramenta ao 'tool_executor.py' para deletar um arquivo. "
    "2. Modificar o fluxo principal para usar essa nova ferramenta e deletar o arquivo 'agent/project_scanner.py.bak'."
)

def run_evolution_cycle(api_key, model_list, objective):
    """Executa um ciclo completo de evolução: scan -> think -> validate -> test -> apply
    
    Retorna:
        tuple: (success: bool, reason: str | None, context: str | None)
    """
    try:
        # Determina arquivos alvo com base no objetivo
        target_files = []
        if "project_scanner.py" in objective:
            target_files.append("agent/project_scanner.py")
        
        # Passo 1: Gerar manifesto do projeto (AGENTS.md)
        print("Gerando manifesto do projeto (AGENTS.md)...")
        update_project_manifest(root_dir=".", target_files=target_files)
        
        # Passo 2: Carregar manifesto para contexto
        print("Carregando manifesto...")
        with open("AGENTS.md", "r", encoding="utf-8") as f:
            manifesto_content = f.read()
        
        # Exibe preview do manifesto
        print("\n--- MANIFESTO GERADO (PRIMEIROS 1000 CARACTERES) ---")
        print(f"Tamanho total do manifesto: {len(manifesto_content)} caracteres")
        print(manifesto_content[:1000] + "...")
        
        # Obtém sugestão da IA com fallback
        print("\nSolicitando análise da IA...")
        attempt_logs = get_ai_suggestion(
            api_key=api_key,
            model_list=model_list,
            project_snapshot=manifesto_content,
            objective=objective
        )

        # Processa os logs para encontrar a primeira tentativa bem-sucedida
        successful_attempt = None
        for attempt in attempt_logs:
            if attempt["success"]:
                successful_attempt = attempt
                break

        # Trata cenários de sucesso/falha
        if not successful_attempt:
            error_logs = "\n".join([f"Modelo {a['model']}: {a['raw_response']}" for a in attempt_logs])
            return (False, "ALL_MODELS_FAILED", error_logs)
            
        parsed_json = successful_attempt["parsed_json"]
        model_used = successful_attempt["model"]
        print(f"Resposta válida obtida do modelo: {model_used}")
        
        # Verificação crítica da resposta da IA
        if parsed_json is None:
            return (False, "INVALID_AI_RESPONSE", successful_attempt["raw_response"])
            
        # Validação de sintaxe do código gerado
        files_to_update = parsed_json.get("files_to_update", [])
        for file_update in files_to_update:
            is_valid, error = validate_python_code(file_update['new_content'])
            if not is_valid:
                return (False, "SYNTAX_ERROR", f"Arquivo {file_update['file_path']}: {error}")
                
        # Validação com testes pytest
        test_code = parsed_json.get("validation_pytest_code", "").strip()
        temp_test_path = "tests/test_generated_by_agent.py"
        
        if test_code:
            print("\n--- EXECUTANDO TESTES DE VALIDAÇÃO GERADOS PELA IA ---")
            try:
                os.makedirs("tests", exist_ok=True)
                with open(temp_test_path, "w", encoding="utf-8") as test_file:
                    test_file.write(test_code)
                
                tests_passed, pytest_output = run_pytest()
                
                if not tests_passed:
                    return (False, "PYTEST_FAILURE", pytest_output)
            except Exception as e:
                return (False, "TEST_EXECUTION_ERROR", str(e))
            finally:
                if os.path.exists(temp_test_path):
                    os.remove(temp_test_path)
        
        # Exibe a análise da IA
        print("\n--- ANÁLISE DA IA ---")
        print(parsed_json.get("analysis_summary", ""))
        print(f"(Modelo usado: {model_used})")
        
        # Confirmação do usuário
        user_input = input("\nAplicar as mudanças? (s/n): ").strip().lower()
        if user_input != 's':
            return (False, "USER_CANCELLED", "Operação cancelada pelo usuário")
            
        # Aplica mudanças
        print("\nAplicando mudanças...")
        report = apply_changes(files_to_update)
        print("\n--- RELATÓRIO DE MUDANÇAS ---")
        print(f"Status geral: {report['status']}")
        
        if report['changes']:
            print("\nArquivos modificados:")
            for change in report['changes']:
                print(f"- {change['file']} (backup: {change['backup']})")
                
        if report['errors']:
            print("\nErros encontrados:")
            for error in report['errors']:
                print(f"- {error}")
        
        return (True, "APPLIED", "Mudança aplicada com sucesso")
            
    except Exception as e:
        return (False, "UNEXPECTED_ERROR", str(e))

if __name__ == "__main__":
    # Carrega variáveis de ambiente
    load_dotenv()
    
    # Obtém a chave da API
    api_key = os.getenv("OPENROUTER_API_KEY")
    if not api_key:
        print("Erro: Chave da API não encontrada. Defina OPENROUTER_API_KEY no arquivo .env")
        sys.exit(1)
    
    # Define lista de fallback de modelos
    MODEL_FALLBACK_LIST = [
        "deepseek/deepseek-r1-0528:free",
        "mistralai/devstral-small:free"
    ]
    
    current_objective = initial_objective
    previous_objective = None
    
    while True:
        print(f"\n=== INICIANDO CICLO COM OBJETIVO ===\n{current_objective}")
        
        # Executa o ciclo de evolução
        success, reason, context = run_evolution_cycle(api_key, MODEL_FALLBACK_LIST, current_objective)
        
        # Trata resultado do ciclo
        if success:
            print("\nCiclo concluído com sucesso! Atualizando manifesto...")
            update_project_manifest(root_dir=".", target_files=[])
            break
            
        elif reason in ["PYTEST_FAILURE", "SYNTAX_ERROR"]:
            print(f"\n!!! FALHA NO CICLO: {reason} !!!")
            print(context)
            
            # Gera novo objetivo para auto-correção
            previous_objective = current_objective
            current_objective = (
                f"[TAREFA DE CORREÇÃO] A tentativa anterior de alcançar o objetivo falhou. "
                f"Objetivo Original: \"{previous_objective}\". Erro: {reason}. "
                f"Detalhes: {context}. Sua nova missão é analisar o erro e propor uma correção."
            )
            print(f"\nNovo objetivo gerado: {current_objective}")
            continue
            
        else:
            print(f"\n!!! FALHA NÃO RECUPERÁVEL: {reason} !!!")
            print(context)
            break
